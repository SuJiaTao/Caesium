; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30148.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	__imp_fabs:PROC
PUBLIC	CInternalPipelineRasterizeTri
;	COMDAT pdata
pdata	SEGMENT
$pdata$CInternalPipelineRasterizeTri DD imagerel $LN292
	DD	imagerel $LN292+1557
	DD	imagerel $unwind$CInternalPipelineRasterizeTri
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$CInternalPipelineRasterizeTri DD imagerel $LN292+1557
	DD	imagerel $LN292+2088
	DD	imagerel $chain$8$CInternalPipelineRasterizeTri
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$CInternalPipelineRasterizeTri DD imagerel $LN292+2088
	DD	imagerel $LN292+5358
	DD	imagerel $chain$13$CInternalPipelineRasterizeTri
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$CInternalPipelineRasterizeTri DD imagerel $LN292+5358
	DD	imagerel $LN292+5389
	DD	imagerel $chain$14$CInternalPipelineRasterizeTri
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_drawFlatTopTri DD imagerel _drawFlatTopTri
	DD	imagerel _drawFlatTopTri+372
	DD	imagerel $unwind$_drawFlatTopTri
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$_drawFlatTopTri DD imagerel _drawFlatTopTri+372
	DD	imagerel _drawFlatTopTri+1888
	DD	imagerel $chain$9$_drawFlatTopTri
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$_drawFlatTopTri DD imagerel _drawFlatTopTri+1888
	DD	imagerel _drawFlatTopTri+1957
	DD	imagerel $chain$10$_drawFlatTopTri
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_drawFlatBottomTri DD imagerel _drawFlatBottomTri
	DD	imagerel _drawFlatBottomTri+314
	DD	imagerel $unwind$_drawFlatBottomTri
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_drawFlatBottomTri DD imagerel _drawFlatBottomTri+314
	DD	imagerel _drawFlatBottomTri+382
	DD	imagerel $chain$0$_drawFlatBottomTri
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$_drawFlatBottomTri DD imagerel _drawFlatBottomTri+382
	DD	imagerel _drawFlatBottomTri+1913
	DD	imagerel $chain$9$_drawFlatBottomTri
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$_drawFlatBottomTri DD imagerel _drawFlatBottomTri+1913
	DD	imagerel _drawFlatBottomTri+1922
	DD	imagerel $chain$10$_drawFlatBottomTri
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$_drawFlatBottomTri DD imagerel _drawFlatBottomTri+1922
	DD	imagerel _drawFlatBottomTri+1988
	DD	imagerel $chain$11$_drawFlatBottomTri
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_prepareAndDrawFragment DD imagerel _prepareAndDrawFragment
	DD	imagerel _prepareAndDrawFragment+64
	DD	imagerel $unwind$_prepareAndDrawFragment
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_prepareAndDrawFragment DD imagerel _prepareAndDrawFragment+64
	DD	imagerel _prepareAndDrawFragment+402
	DD	imagerel $chain$1$_prepareAndDrawFragment
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$_prepareAndDrawFragment DD imagerel _prepareAndDrawFragment+402
	DD	imagerel _prepareAndDrawFragment+1347
	DD	imagerel $chain$7$_prepareAndDrawFragment
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_prepareAndDrawFragment DD imagerel _prepareAndDrawFragment+1347
	DD	imagerel _prepareAndDrawFragment+1404
	DD	imagerel $chain$2$_prepareAndDrawFragment
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_prepareFragmentInputValues DD imagerel _prepareFragmentInputValues
	DD	imagerel _prepareFragmentInputValues+621
	DD	imagerel $unwind$_prepareFragmentInputValues
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_generateBarycentricWeights DD imagerel _generateBarycentricWeights
	DD	imagerel _generateBarycentricWeights+315
	DD	imagerel $unwind$_generateBarycentricWeights
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_sortTriByVerticality DD imagerel _sortTriByVerticality
	DD	imagerel _sortTriByVerticality+1458
	DD	imagerel $unwind$_sortTriByVerticality
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_swapInputLists DD imagerel _swapInputLists
	DD	imagerel _swapInputLists+386
	DD	imagerel $unwind$_swapInputLists
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_drawFragment DD imagerel _drawFragment
	DD	imagerel _drawFragment+341
	DD	imagerel $unwind$_drawFragment
;	COMDAT xdata
xdata	SEGMENT
$unwind$_drawFragment DD 082119H
	DD	0105412H
	DD	0f3412H
	DD	0e00e9212H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_swapInputLists DQ 00049010700020701r	; 2.78179e-307
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_sortTriByVerticality DQ 00049010700020701r ; 2.78179e-307
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_generateBarycentricWeights DQ 00003c83f00103f01r ; 5.25981e-309
	DQ	00005a8330004b839r		; 7.86707e-309
	DQ	0000788270006982dr		; 1.04743e-308
	DQ	00009681800087821r		; 1.30815e-308
	DD	015010aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_prepareFragmentInputValues DQ 000009827000a2701r ; 8.26539e-310
	DQ	0000278160001881fr		; 3.43369e-309
	DQ	0300272060003680cr		; 1.99122e-77
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_prepareAndDrawFragment DD 021H
	DD	imagerel _prepareAndDrawFragment
	DD	imagerel _prepareAndDrawFragment+64
	DD	imagerel $unwind$_prepareAndDrawFragment
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$_prepareAndDrawFragment DD 0a1921H
	DD	01cf419H
	DD	01d7415H
	DD	0236411H
	DD	0225408H
	DD	0213404H
	DD	imagerel _prepareAndDrawFragment+1347
	DD	imagerel _prepareAndDrawFragment+1404
	DD	imagerel $chain$2$_prepareAndDrawFragment
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_prepareAndDrawFragment DD 040f21H
	DD	07c80fH
	DD	09a806H
	DD	imagerel _prepareAndDrawFragment
	DD	imagerel _prepareAndDrawFragment+64
	DD	imagerel $unwind$_prepareAndDrawFragment
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_prepareAndDrawFragment DD 0d3919H
	DD	08b82aH
	DD	0a9824H
	DD	0b881eH
	DD	0c7818H
	DD	0d6812H
	DD	01e010cH
	DD	0e005H
	DD	imagerel __GSHandlerCheck
	DD	068H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$_drawFlatBottomTri DD 021H
	DD	imagerel _drawFlatBottomTri
	DD	imagerel _drawFlatBottomTri+314
	DD	imagerel $unwind$_drawFlatBottomTri
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$_drawFlatBottomTri DD 021H
	DD	imagerel _drawFlatBottomTri+314
	DD	imagerel _drawFlatBottomTri+382
	DD	imagerel $chain$0$_drawFlatBottomTri
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$_drawFlatBottomTri DD 0124b21H
	DD	0ed84bH
	DD	0fc842H
	DD	010b839H
	DD	02cf430H
	DD	02de428H
	DD	02ec420H
	DD	02f7418H
	DD	0306410H
	DD	0363408H
	DD	imagerel _drawFlatBottomTri+314
	DD	imagerel _drawFlatBottomTri+382
	DD	imagerel $chain$0$_drawFlatBottomTri
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_drawFlatBottomTri DD 020921H
	DD	0cf809H
	DD	imagerel _drawFlatBottomTri
	DD	imagerel _drawFlatBottomTri+314
	DD	imagerel $unwind$_drawFlatBottomTri
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_drawFlatBottomTri DD 0104619H
	DD	0de838H
	DD	011a830H
	DD	0129828H
	DD	0138823H
	DD	014781eH
	DD	0156819H
	DD	0310114H
	DD	05004d006H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$_drawFlatTopTri DD 021H
	DD	imagerel _drawFlatTopTri
	DD	imagerel _drawFlatTopTri+372
	DD	imagerel $unwind$_drawFlatTopTri
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$_drawFlatTopTri DD 0145421H
	DD	0ed854H
	DD	0fc84bH
	DD	010b842H
	DD	011a839H
	DD	02cf430H
	DD	02de428H
	DD	02ec420H
	DD	02f7418H
	DD	0306410H
	DD	0363408H
	DD	imagerel _drawFlatTopTri
	DD	imagerel _drawFlatTopTri+372
	DD	imagerel $unwind$_drawFlatTopTri
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_drawFlatTopTri DD 0104619H
	DD	0cf838H
	DD	0de830H
	DD	0129828H
	DD	0138823H
	DD	014781eH
	DD	0156819H
	DD	0310114H
	DD	05004d006H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$CInternalPipelineRasterizeTri DD 021H
	DD	imagerel $LN292
	DD	imagerel $LN292+1557
	DD	imagerel $unwind$CInternalPipelineRasterizeTri
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$CInternalPipelineRasterizeTri DD 0a4f21H
	DD	0f0d84fH
	DD	01f0f43aH
	DD	01f1e429H
	DD	01f2c410H
	DD	01fa3408H
	DD	imagerel $LN292+1557
	DD	imagerel $LN292+2088
	DD	imagerel $chain$8$CInternalPipelineRasterizeTri
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$CInternalPipelineRasterizeTri DD 012b121H
	DD	0eef8b1H
	DD	0efe87eH
	DD	0f1c854H
	DD	0f2b843H
	DD	0f3a83aH
	DD	0f49831H
	DD	0f58828H
	DD	0f6781fH
	DD	0f76809H
	DD	imagerel $LN292
	DD	imagerel $LN292+1557
	DD	imagerel $unwind$CInternalPipelineRasterizeTri
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CInternalPipelineRasterizeTri DD 062619H
	DD	01f30115H
	DD	07004d006H
	DD	050026003H
	DD	imagerel __GSHandlerCheck
	DD	0ed0H
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
;	COMDAT _drawFragment
_TEXT	SEGMENT
$T1 = 48
rCol$3 = 64
rCol$4 = 64
fragColor$ = 64
__$ArrayPad$ = 72
triContext$ = 112
_drawFragment PROC					; COMDAT

; 17   : static __forceinline void _drawFragment(PCIPTriContext triContext) {

	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 18   : 	PCRenderBuffer renderBuffer = triContext->renderBuffer;

	mov	rdi, QWORD PTR [rcx+648]
	mov	rsi, rcx

; 19   : 	// generate frag position
; 20   : 	INT fragPosX = triContext->fragContext.fragPos.x;

	mov	ebp, DWORD PTR [rcx+624]

; 21   : 	INT fragPosY = triContext->fragContext.fragPos.y;

	mov	r14d, DWORD PTR [rcx+628]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 157  : 	colorOut[0] = _findColorPtr(handle, x, y)[0];

	mov	ecx, DWORD PTR [rdi+4]
	mov	rax, QWORD PTR [rdi+8]
	sub	ecx, r14d
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 30   : 	if (triContext->material != NULL) {

	mov	r10, QWORD PTR [rsi+656]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 63   : 	return b->color + (x + ((b->height - y - 1) * b->width));

	dec	ecx
	imul	ecx, DWORD PTR [rdi]
	add	ecx, ebp

; 157  : 	colorOut[0] = _findColorPtr(handle, x, y)[0];

	mov	ebx, DWORD PTR [rax+rcx*4]
; File C:\Bailey\Programming\Caesium\csm.c

; 57   : 	rCol.g = g;

	mov	WORD PTR rCol$3[rsp+1], 0

; 58   : 	rCol.b = b;

	mov	BYTE PTR rCol$3[rsp], 0

; 59   : 	rCol.a = a;

	mov	BYTE PTR rCol$3[rsp+3], 0
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 29   : 	CColor fragColor = CMakeColor4(0, 0, 0, 0);

	mov	eax, DWORD PTR rCol$3[rsp]
	mov	DWORD PTR fragColor$[rsp], eax

; 30   : 	if (triContext->material != NULL) {

	test	r10, r10
	je	SHORT $LN2@drawFragme

; 31   : 		// apply fragment shader
; 32   : 		BOOL keepFrag = triContext->material->fragmentShader(

	mov	eax, DWORD PTR [rsi+632]
	lea	rcx, QWORD PTR [rsi+40]
	vmovsd	xmm0, QWORD PTR [rsi+624]
	mov	r8d, DWORD PTR [rsi+16]
	lea	r9, QWORD PTR $T1[rsp]
	mov	edx, DWORD PTR [rsi+20]
	mov	DWORD PTR $T1[rsp+8], eax
	lea	rax, QWORD PTR fragColor$[rsp]
	mov	QWORD PTR [rsp+32], rax
	vmovsd	QWORD PTR $T1[rsp], xmm0
	call	QWORD PTR [r10+16]

; 33   : 			&triContext->fragContext,
; 34   : 			triContext->triangleID,
; 35   : 			triContext->instanceID,
; 36   : 			triContext->fragContext.fragPos,
; 37   : 			&fragColor
; 38   : 		);
; 39   : 		if (keepFrag == FALSE) return; // cull if needed

	test	eax, eax
	je	$LN18@drawFragme

; 40   : 	}

	mov	eax, DWORD PTR fragColor$[rsp]
	jmp	SHORT $LN3@drawFragme
$LN2@drawFragme:
; File C:\Bailey\Programming\Caesium\csm.c

; 48   : 	rCol.g = g;

	mov	WORD PTR rCol$4[rsp+1], 65280		; 0000ff00H

; 49   : 	rCol.b = b;

	mov	BYTE PTR rCol$4[rsp], 255		; 000000ffH

; 50   : 	rCol.a = 255;

	mov	BYTE PTR rCol$4[rsp+3], 255		; 000000ffH
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 44   : 		fragColor = CMakeColor3(255, 0, 255);

	mov	eax, DWORD PTR rCol$4[rsp]
	mov	DWORD PTR fragColor$[rsp], eax
$LN3@drawFragme:

; 45   : 	}
; 46   : 
; 47   : 	// if color alpha is 0, cull
; 48   : 	if (fragColor.a == 0) return;

	mov	ecx, eax
	shr	ecx, 24
	test	cl, cl
	je	SHORT $LN18@drawFragme

; 49   : 
; 50   : 	// apply alpha blend (if needed)
; 51   : 	if (fragColor.a != 255)

	cmp	cl, 255					; 000000ffH
	je	SHORT $LN6@drawFragme

; 52   : 		fragColor = CFragmentBlendColor(belowColor, fragColor);

	mov	edx, eax
	mov	ecx, ebx
	call	CFragmentBlendColor
	mov	DWORD PTR fragColor$[rsp], eax
$LN6@drawFragme:
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	mov	edx, DWORD PTR [rdi+4]

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	mov	rcx, QWORD PTR [rdi+16]

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	sub	edx, r14d
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 55   : 	CRenderBufferUnsafeSetFragment(

	vmovss	xmm2, DWORD PTR [rsi+632]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	dec	edx
	imul	edx, DWORD PTR [rdi]
	add	edx, ebp

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	vmovss	xmm0, DWORD PTR [rcx+rdx*4]

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	vsubss	xmm1, xmm0, xmm2
	vcomiss	xmm1, DWORD PTR __real@ba83126f
	jae	SHORT $LN18@drawFragme

; 167  : 	_findColorPtr(handle, x, y)[0] = color;

	mov	rcx, QWORD PTR [rdi+8]
	mov	DWORD PTR [rcx+rdx*4], eax

; 168  : 	_findDepthPtr(handle, x, y)[0] = depth;

	mov	ecx, DWORD PTR [rdi+4]
	mov	rax, QWORD PTR [rdi+16]
	sub	ecx, r14d

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	dec	ecx
	imul	ecx, DWORD PTR [rdi]
	add	ecx, ebp

; 168  : 	_findDepthPtr(handle, x, y)[0] = depth;

	vmovss	DWORD PTR [rax+rcx*4], xmm2
$LN18@drawFragme:
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 62   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+120]
	mov	rbp, QWORD PTR [rsp+128]
	add	rsp, 80					; 00000050H
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
_drawFragment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
;	COMDAT _prepareAndDrawFragment
_TEXT	SEGMENT
$T7 = 48
p2$9 = 48
p3$10 = 64
p1$11 = 80
rCol$12 = 96
rCol$13 = 96
fragColor$14 = 96
__$ArrayPad$ = 104
triContext$ = 256
drawX$ = 264
drawY$ = 272
_prepareAndDrawFragment PROC				; COMDAT

; 193  : static __forceinline void _prepareAndDrawFragment(PCIPTriContext triContext, INT drawX, INT drawY) {

	mov	r11, rsp
	push	r14
	sub	rsp, 240				; 000000f0H
	vmovaps	XMMWORD PTR [r11-40], xmm6
	vmovaps	XMMWORD PTR [r11-56], xmm7
	vmovaps	XMMWORD PTR [r11-72], xmm8
	vmovaps	XMMWORD PTR [r11-88], xmm9
	vmovaps	XMMWORD PTR [r11-120], xmm11
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 196  : 		CMakeVect3F(drawX, drawY, 0.0f);
; 197  : 	CVect3F bWeights =

	mov	r9, QWORD PTR [rcx+32]
	mov	r14, rcx
	vmovaps	XMMWORD PTR [r11-104], xmm10
	mov	r10d, edx
	vmovaps	XMMWORD PTR [rsp+112], xmm12
	vxorps	xmm4, xmm4, xmm4

; 124  : 	CVect3F p3 = triangle->verts[2];

	vmovsd	xmm12, QWORD PTR [r9+1752]
	vmovsd	xmm11, QWORD PTR [r9+1740]
	vmovsd	xmm0, QWORD PTR [r9+1728]
	mov	eax, DWORD PTR [r9+1748]

; 128  : 	FLOAT invDenom = _fltInv((p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y));

	vshufps	xmm10, xmm0, xmm0, 85			; 00000055H
	vmovsd	QWORD PTR p1$11[rsp], xmm0
	vmovss	xmm8, DWORD PTR p1$11[rsp]
	vsubss	xmm1, xmm12, xmm11

; 194  : 	// create fragment with interpolated depth
; 195  : 	CVect3F drawVect =

	vcvtsi2ss xmm4, xmm4, edx

; 198  : 		_generateBarycentricWeights(triContext->screenTriAndData, drawVect);
; 199  : 	drawVect.z = _interpolateDepth(bWeights, triContext->screenTriAndData);
; 200  : 
; 201  : 	// early depth test
; 202  : 	if (CRenderBufferUnsafeDepthTest(triContext->renderBuffer, drawX, drawY, drawVect.z) == FALSE) return;

	mov	rdx, QWORD PTR [rcx+648]

; 129  : 	FLOAT dv3x = vert.x - p3.x;

	vsubss	xmm4, xmm4, xmm12
	vmovsd	QWORD PTR p3$10[rsp], xmm12
	vmovss	xmm9, DWORD PTR p3$10[rsp+4]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	mov	ecx, DWORD PTR [rdx+4]
	sub	ecx, r8d
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 123  : 	CVect3F p2 = triangle->verts[1];

	mov	DWORD PTR p2$9[rsp+8], eax
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	mov	rax, QWORD PTR [rdx+16]

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	dec	ecx
	imul	ecx, DWORD PTR [rdx]
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 128  : 	FLOAT invDenom = _fltInv((p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y));

	vsubss	xmm0, xmm10, xmm9
	vmulss	xmm2, xmm1, xmm0
	vsubss	xmm1, xmm8, xmm12
	vmovsd	QWORD PTR p2$9[rsp], xmm11
	vmovss	xmm6, DWORD PTR p2$9[rsp+4]
	vsubss	xmm0, xmm6, xmm9
	vmulss	xmm1, xmm1, xmm0
	vaddss	xmm3, xmm2, xmm1
	vxorps	xmm2, xmm2, xmm2

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vmovss3	xmm7, xmm2, xmm3

; 131  : 	weights.x = ((p2.y - p3.y) * (dv3x) + (p3.x - p2.x) * (dv3y)) * invDenom;

	vsubss	xmm0, xmm12, xmm11
	vsubss	xmm1, xmm6, xmm9
	vmulss	xmm2, xmm1, xmm4

; 132  : 	weights.y = ((p3.y - p1.y) * (dv3x) + (p1.x - p3.x) * (dv3y)) * invDenom;

	vsubss	xmm1, xmm9, xmm10
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	vmovaps	xmm10, XMMWORD PTR [r11-104]

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	add	ecx, r10d
	vxorps	xmm5, xmm5, xmm5
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vrcpss	xmm7, xmm7, xmm7

; 194  : 	// create fragment with interpolated depth
; 195  : 	CVect3F drawVect =

	vcvtsi2ss xmm5, xmm5, r8d

; 130  : 	FLOAT dv3y = vert.y - p3.y;

	vsubss	xmm5, xmm5, xmm9
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	vmovss	xmm9, DWORD PTR __real@ba83126f
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 131  : 	weights.x = ((p2.y - p3.y) * (dv3x) + (p3.x - p2.x) * (dv3y)) * invDenom;

	vmulss	xmm3, xmm0, xmm5
	vaddss	xmm0, xmm3, xmm2
	vmulss	xmm11, xmm0, xmm7

; 132  : 	weights.y = ((p3.y - p1.y) * (dv3x) + (p1.x - p3.x) * (dv3y)) * invDenom;

	vmulss	xmm3, xmm1, xmm4
	vsubss	xmm0, xmm8, xmm12
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	vmovaps	xmm12, XMMWORD PTR [rsp+112]
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 132  : 	weights.y = ((p3.y - p1.y) * (dv3x) + (p1.x - p3.x) * (dv3y)) * invDenom;

	vmulss	xmm2, xmm0, xmm5

; 133  : 	weights.z = 1 - weights.x - weights.y;

	vmovss	xmm0, DWORD PTR __real@3f800000
	vaddss	xmm1, xmm3, xmm2

; 144  : 	weights.x *= (triangle->invDepths[0]);

	vmulss	xmm2, xmm11, DWORD PTR [r9+1764]

; 132  : 	weights.y = ((p3.y - p1.y) * (dv3x) + (p1.x - p3.x) * (dv3y)) * invDenom;

	vmulss	xmm7, xmm1, xmm7

; 133  : 	weights.z = 1 - weights.x - weights.y;

	vsubss	xmm1, xmm0, xmm11

; 145  : 	weights.y *= (triangle->invDepths[1]);

	vmulss	xmm0, xmm7, DWORD PTR [r9+1768]

; 133  : 	weights.z = 1 - weights.x - weights.y;

	vsubss	xmm8, xmm1, xmm7

; 146  : 	weights.z *= (triangle->invDepths[2]);

	vmulss	xmm1, xmm8, DWORD PTR [r9+1772]

; 147  : 
; 148  : 	return _fltInv(weights.x + weights.y + weights.z);

	vaddss	xmm0, xmm0, xmm2
	vaddss	xmm3, xmm0, xmm1
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	vmovss	xmm0, DWORD PTR [rax+rcx*4]
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vrcpss	xmm4, xmm3, xmm3
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	vsubss	xmm1, xmm0, xmm4
	vcomiss	xmm1, xmm9
	jae	$LN45@prepareAnd
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 205  : 	PCIPFragContext fContext = &triContext->fragContext;

	mov	QWORD PTR [r11+16], rbx
	mov	QWORD PTR [r11+24], rbp
	mov	ebp, 4
	mov	QWORD PTR [r11+32], rsi
	mov	QWORD PTR [r11-16], rdi
	mov	QWORD PTR [r11-24], r15
	lea	r15, QWORD PTR [r14+40]

; 206  : 	fContext->barycentricWeightings = bWeights;

	vmovss	DWORD PTR [r15+596], xmm11
	vmovss	DWORD PTR [r15+600], xmm7
	vmovss	DWORD PTR [r15+604], xmm8

; 207  : 	fContext->fragPos.x = drawX;
; 208  : 	fContext->fragPos.y = drawY;

	mov	DWORD PTR [r15+588], r8d
	lea	r8, QWORD PTR [r15+80]

; 209  : 	fContext->fragPos.depth = drawVect.z;

	vmovss	DWORD PTR [r15+592], xmm4
	mov	DWORD PTR [r15+584], r10d

; 210  : 
; 211  : 	_prepareFragmentInputValues(&fContext->fragInputs, triContext->screenTriAndData, bWeights);

	mov	r9, QWORD PTR [r14+32]
	mov	rsi, r9
	sub	rsi, r15

; 154  : 	PCIPVertOutputList fragInputList2 = &triData->vertOutputs[1];

	lea	r11, QWORD PTR [r9+576]

; 205  : 	PCIPFragContext fContext = &triContext->fragContext;

	sub	r11, r15

; 155  : 	PCIPVertOutputList fragInputList3 = &triData->vertOutputs[2];

	lea	rbx, QWORD PTR [r9+1152]

; 205  : 	PCIPFragContext fContext = &triContext->fragContext;

	sub	rbx, r15
$LL22@prepareAnd:

; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rsi+r8-80]
	lea	rdi, QWORD PTR [rsi+r8]
	test	eax, eax
	je	SHORT $LN20@prepareAnd

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r10d, r10d
	test	eax, eax
	je	SHORT $LN20@prepareAnd
	npad	9
$LL25@prepareAnd:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm11, DWORD PTR [r9+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [rdi+r10*4-76]
	vmulss	xmm4, xmm7, DWORD PTR [r9+1768]
	vmulss	xmm5, xmm8, DWORD PTR [r9+1772]
	lea	rax, QWORD PTR [r11+r8]
	vmulss	xmm1, xmm4, DWORD PTR [rax+r10*4-76]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [r8+rbx]
	vmulss	xmm1, xmm5, DWORD PTR [rcx+r10*4-76]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm4, xmm6
	vaddss	xmm2, xmm0, xmm5
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [r8+r10*4-68], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [rdi-80]
	inc	r10d
	mov	DWORD PTR [r8-72], eax
	cmp	r10d, DWORD PTR [rdi-80]
	jb	SHORT $LL25@prepareAnd
$LN20@prepareAnd:

; 159  : 		// get frag inputs
; 160  : 		PCIPVertOutput vertOutput1 = fragInputList1->outputs + inputID;
; 161  : 		PCIPVertOutput vertOutput2 = fragInputList2->outputs + inputID;
; 162  : 		PCIPVertOutput vertOutput3 = fragInputList3->outputs + inputID;
; 163  : 		PCIPVertOutput outVertOutput = inOutVertList->outputs + inputID;
; 164  : 
; 165  : 		// if componentcount is 0, skip
; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rsi+r8-44]
	lea	rdi, QWORD PTR [rsi+r8]
	test	eax, eax
	je	SHORT $LN63@prepareAnd

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r10d, r10d
	test	eax, eax
	je	SHORT $LN63@prepareAnd
	npad	9
$LL62@prepareAnd:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm11, DWORD PTR [r9+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [rdi+r10*4-40]
	vmulss	xmm4, xmm7, DWORD PTR [r9+1768]
	vmulss	xmm5, xmm8, DWORD PTR [r9+1772]
	lea	rax, QWORD PTR [r11+r8]
	vmulss	xmm1, xmm4, DWORD PTR [rax+r10*4-40]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [r8+r10*4]
	vmulss	xmm1, xmm5, DWORD PTR [rcx+rbx-40]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm4, xmm6
	vaddss	xmm2, xmm0, xmm5
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [r8+r10*4-32], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [rdi-44]
	inc	r10d
	mov	DWORD PTR [r8-36], eax
	cmp	r10d, DWORD PTR [rdi-44]
	jb	SHORT $LL62@prepareAnd
$LN63@prepareAnd:

; 159  : 		// get frag inputs
; 160  : 		PCIPVertOutput vertOutput1 = fragInputList1->outputs + inputID;
; 161  : 		PCIPVertOutput vertOutput2 = fragInputList2->outputs + inputID;
; 162  : 		PCIPVertOutput vertOutput3 = fragInputList3->outputs + inputID;
; 163  : 		PCIPVertOutput outVertOutput = inOutVertList->outputs + inputID;
; 164  : 
; 165  : 		// if componentcount is 0, skip
; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rsi+r8-8]
	lea	rdi, QWORD PTR [rsi+r8]
	test	eax, eax
	je	SHORT $LN66@prepareAnd

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r10d, r10d
	test	eax, eax
	je	SHORT $LN66@prepareAnd
	npad	10
$LL65@prepareAnd:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm11, DWORD PTR [r9+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [rdi+r10*4-4]
	vmulss	xmm4, xmm7, DWORD PTR [r9+1768]
	vmulss	xmm5, xmm8, DWORD PTR [r9+1772]
	lea	rax, QWORD PTR [r11+r8]
	vmulss	xmm1, xmm4, DWORD PTR [rax+r10*4-4]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [r8+r10*4]
	vmulss	xmm1, xmm5, DWORD PTR [rcx+rbx-4]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm4, xmm6
	vaddss	xmm2, xmm0, xmm5
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [r8+r10*4+4], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [rdi-8]
	inc	r10d
	mov	DWORD PTR [r8], eax
	cmp	r10d, DWORD PTR [rdi-8]
	jb	SHORT $LL65@prepareAnd
$LN66@prepareAnd:

; 159  : 		// get frag inputs
; 160  : 		PCIPVertOutput vertOutput1 = fragInputList1->outputs + inputID;
; 161  : 		PCIPVertOutput vertOutput2 = fragInputList2->outputs + inputID;
; 162  : 		PCIPVertOutput vertOutput3 = fragInputList3->outputs + inputID;
; 163  : 		PCIPVertOutput outVertOutput = inOutVertList->outputs + inputID;
; 164  : 
; 165  : 		// if componentcount is 0, skip
; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rsi+r8+28]
	lea	rdi, QWORD PTR [rsi+r8]
	test	eax, eax
	je	SHORT $LN69@prepareAnd

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r10d, r10d
	test	eax, eax
	je	SHORT $LN69@prepareAnd
	npad	11
$LL68@prepareAnd:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm11, DWORD PTR [r9+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [rdi+r10*4+32]
	vmulss	xmm4, xmm7, DWORD PTR [r9+1768]
	vmulss	xmm5, xmm8, DWORD PTR [r9+1772]
	lea	rax, QWORD PTR [r11+r8]
	vmulss	xmm1, xmm4, DWORD PTR [rax+r10*4+32]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [r8+r10*4]
	vmulss	xmm1, xmm5, DWORD PTR [rcx+rbx+32]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm4, xmm6
	vaddss	xmm2, xmm0, xmm5
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [r8+r10*4+40], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [rdi+28]
	inc	r10d
	mov	DWORD PTR [r8+36], eax
	cmp	r10d, DWORD PTR [rdi+28]
	jb	SHORT $LL68@prepareAnd
$LN69@prepareAnd:

; 156  : 
; 157  : 	// interpolate all input values based on fragment
; 158  : 	for (UINT32 inputID = 0; inputID < CSM_CLASS_MAX_VERTEX_DATA; inputID++) {

	add	r8, 144					; 00000090H
	sub	rbp, 1
	jne	$LL22@prepareAnd

; 18   : 	PCRenderBuffer renderBuffer = triContext->renderBuffer;

	mov	rdi, QWORD PTR [r14+648]

; 19   : 	// generate frag position
; 20   : 	INT fragPosX = triContext->fragContext.fragPos.x;
; 21   : 	INT fragPosY = triContext->fragContext.fragPos.y;

	mov	ebp, DWORD PTR [r14+628]
	mov	esi, DWORD PTR [r14+624]

; 30   : 	if (triContext->material != NULL) {

	mov	r10, QWORD PTR [r14+656]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 157  : 	colorOut[0] = _findColorPtr(handle, x, y)[0];

	mov	ecx, DWORD PTR [rdi+4]
	mov	rax, QWORD PTR [rdi+8]
	sub	ecx, ebp

; 63   : 	return b->color + (x + ((b->height - y - 1) * b->width));

	dec	ecx
	imul	ecx, DWORD PTR [rdi]
	add	ecx, esi

; 157  : 	colorOut[0] = _findColorPtr(handle, x, y)[0];

	mov	ebx, DWORD PTR [rax+rcx*4]
; File C:\Bailey\Programming\Caesium\csm.c

; 57   : 	rCol.g = g;

	mov	WORD PTR rCol$12[rsp+1], 0

; 58   : 	rCol.b = b;

	mov	BYTE PTR rCol$12[rsp], 0

; 59   : 	rCol.a = a;

	mov	BYTE PTR rCol$12[rsp+3], 0
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 29   : 	CColor fragColor = CMakeColor4(0, 0, 0, 0);

	mov	eax, DWORD PTR rCol$12[rsp]
	mov	DWORD PTR fragColor$14[rsp], eax

; 30   : 	if (triContext->material != NULL) {

	test	r10, r10
	je	SHORT $LN29@prepareAnd

; 31   : 		// apply fragment shader
; 32   : 		BOOL keepFrag = triContext->material->fragmentShader(

	mov	eax, DWORD PTR [r14+632]
	lea	r9, QWORD PTR $T7[rsp]
	vmovsd	xmm0, QWORD PTR [r14+624]
	mov	r8d, DWORD PTR [r14+16]
	mov	rcx, r15
	mov	edx, DWORD PTR [r14+20]
	mov	DWORD PTR $T7[rsp+8], eax
	lea	rax, QWORD PTR fragColor$14[rsp]
	mov	QWORD PTR [rsp+32], rax
	vmovsd	QWORD PTR $T7[rsp], xmm0
	call	QWORD PTR [r10+16]

; 33   : 			&triContext->fragContext,
; 34   : 			triContext->triangleID,
; 35   : 			triContext->instanceID,
; 36   : 			triContext->fragContext.fragPos,
; 37   : 			&fragColor
; 38   : 		);
; 39   : 		if (keepFrag == FALSE) return; // cull if needed

	test	eax, eax
	je	SHORT $LN86@prepareAnd

; 40   : 	}

	mov	eax, DWORD PTR fragColor$14[rsp]
	jmp	SHORT $LN30@prepareAnd
$LN29@prepareAnd:
; File C:\Bailey\Programming\Caesium\csm.c

; 48   : 	rCol.g = g;

	mov	WORD PTR rCol$13[rsp+1], 65280		; 0000ff00H

; 49   : 	rCol.b = b;

	mov	BYTE PTR rCol$13[rsp], 255		; 000000ffH

; 50   : 	rCol.a = 255;

	mov	BYTE PTR rCol$13[rsp+3], 255		; 000000ffH
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 44   : 		fragColor = CMakeColor3(255, 0, 255);

	mov	eax, DWORD PTR rCol$13[rsp]
	mov	DWORD PTR fragColor$14[rsp], eax
$LN30@prepareAnd:

; 45   : 	}
; 46   : 
; 47   : 	// if color alpha is 0, cull
; 48   : 	if (fragColor.a == 0) return;

	mov	ecx, eax
	shr	ecx, 24
	test	cl, cl
	je	SHORT $LN86@prepareAnd

; 49   : 
; 50   : 	// apply alpha blend (if needed)
; 51   : 	if (fragColor.a != 255)

	cmp	cl, 255					; 000000ffH
	je	SHORT $LN33@prepareAnd

; 52   : 		fragColor = CFragmentBlendColor(belowColor, fragColor);

	mov	edx, eax
	mov	ecx, ebx
	call	CFragmentBlendColor
	mov	DWORD PTR fragColor$14[rsp], eax
$LN33@prepareAnd:
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	mov	edx, DWORD PTR [rdi+4]

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	mov	rcx, QWORD PTR [rdi+16]

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	sub	edx, ebp
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 55   : 	CRenderBufferUnsafeSetFragment(

	vmovss	xmm2, DWORD PTR [r14+632]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	dec	edx
	imul	edx, DWORD PTR [rdi]
	add	edx, esi

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	vmovss	xmm0, DWORD PTR [rcx+rdx*4]

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	vsubss	xmm1, xmm0, xmm2
	vcomiss	xmm1, xmm9
	jae	SHORT $LN86@prepareAnd

; 167  : 	_findColorPtr(handle, x, y)[0] = color;

	mov	rcx, QWORD PTR [rdi+8]
	mov	DWORD PTR [rcx+rdx*4], eax

; 168  : 	_findDepthPtr(handle, x, y)[0] = depth;

	mov	ecx, DWORD PTR [rdi+4]
	mov	rax, QWORD PTR [rdi+16]
	sub	ecx, ebp

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	dec	ecx
	imul	ecx, DWORD PTR [rdi]
	add	ecx, esi

; 168  : 	_findDepthPtr(handle, x, y)[0] = depth;

	vmovss	DWORD PTR [rax+rcx*4], xmm2
$LN86@prepareAnd:
	mov	rdi, QWORD PTR [rsp+232]
	mov	rsi, QWORD PTR [rsp+280]
	mov	rbp, QWORD PTR [rsp+272]
	mov	rbx, QWORD PTR [rsp+264]
	mov	r15, QWORD PTR [rsp+224]
$LN45@prepareAnd:
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 215  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+240]
	vmovaps	xmm6, XMMWORD PTR [r11-32]
	vmovaps	xmm7, XMMWORD PTR [r11-48]
	vmovaps	xmm8, XMMWORD PTR [r11-64]
	vmovaps	xmm9, XMMWORD PTR [r11-80]
	vmovaps	xmm11, XMMWORD PTR [r11-112]
	mov	rsp, r11
	pop	r14
	ret	0
_prepareAndDrawFragment ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
;	COMDAT _drawFlatBottomTri
_TEXT	SEGMENT
drawY$1$ = 48
rCol$11 = 52
rCol$12 = 56
LBase$2$ = 60
DRAW_X_END$1$ = 64
invSlopeR$1$ = 68
invSlopeL$1$ = 72
DRAW_Y_END$1$ = 76
renderBuff$1$ = 80
top$ = 80
p1$13 = 96
RBase$ = 96
p3$14 = 112
LBase$ = 112
$T7 = 128
temp$15 = 128
tv2294 = 144
tv2284 = 152
p2$16 = 160
fragColor$17 = 176
__$ArrayPad$ = 184
triContext$ = 416
subTri$ = 424
_drawFlatBottomTri PROC					; COMDAT

; 217  : static __forceinline void _drawFlatBottomTri(PCIPTriContext triContext, PCIPTriData subTri) {

	mov	rax, rsp
	push	rbp
	push	r13
	lea	rbp, QWORD PTR [rax-152]
	sub	rsp, 392				; 00000188H
	vmovaps	XMMWORD PTR [rax-72], xmm6
	vmovaps	XMMWORD PTR [rax-88], xmm7
	vmovaps	XMMWORD PTR [rax-104], xmm8
	vmovaps	XMMWORD PTR [rax-120], xmm9
	vmovaps	XMMWORD PTR [rax-136], xmm10
	vmovaps	XMMWORD PTR [rax-200], xmm14
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 218  : 
; 219  : 	// generate each position
; 220  : 	CVect3F top = subTri->verts[0];
; 221  : 	CVect3F LBase = subTri->verts[1];

	vmovsd	xmm7, QWORD PTR [rdx+1740]

; 222  : 	CVect3F RBase = subTri->verts[2];

	vmovsd	xmm14, QWORD PTR [rdx+1752]

; 223  : 
; 224  : 	// swap to maintain left if necessary
; 225  : 	if (LBase.x > RBase.x) {

	vcomiss	xmm7, xmm14
	vmovsd	xmm0, QWORD PTR [rdx+1728]
	mov	r13, rcx
	vmovsd	QWORD PTR top$[rsp], xmm0
	vmovsd	QWORD PTR tv2284[rbp-256], xmm7
	vmovsd	QWORD PTR tv2294[rbp-256], xmm14
	vmovsd	QWORD PTR LBase$[rsp], xmm7
	vmovsd	QWORD PTR RBase$[rsp], xmm14
	jbe	SHORT $LN115@drawFlatBo

; 65   : 	CVect3F temp = *v1;

	mov	eax, DWORD PTR [rdx+1748]

; 66   : 	*v1 = *v2;

	vmovss	xmm8, DWORD PTR RBase$[rsp+4]
	vmovaps	xmm0, xmm7
	vmovaps	xmm7, xmm14

; 67   : 	*v2 = temp;

	vmovaps	xmm14, xmm0
	vmovsd	QWORD PTR temp$15[rbp-256], xmm0

; 71   : 	FLOAT temp = *d1;

	vmovss	xmm0, DWORD PTR [rdx+1764]

; 65   : 	CVect3F temp = *v1;

	mov	DWORD PTR temp$15[rbp-248], eax

; 72   : 	*d1 = *d2;

	mov	eax, DWORD PTR [rdx+1768]

; 73   : 	*d2 = temp;

	vmovss	DWORD PTR [rdx+1768], xmm0

; 66   : 	*v1 = *v2;

	vmovsd	QWORD PTR tv2284[rbp-256], xmm7

; 67   : 	*v2 = temp;

	vmovsd	QWORD PTR tv2294[rbp-256], xmm14

; 72   : 	*d1 = *d2;

	mov	DWORD PTR [rdx+1764], eax

; 223  : 
; 224  : 	// swap to maintain left if necessary
; 225  : 	if (LBase.x > RBase.x) {

	jmp	SHORT $LN120@drawFlatBo
$LN115@drawFlatBo:
	vmovss	xmm8, DWORD PTR LBase$[rsp+4]
$LN120@drawFlatBo:

; 226  : 		_swapVerts(&LBase, &RBase);
; 227  : 		_swapDepths(subTri->invDepths + 0, subTri->invDepths + 1);
; 228  : 	}
; 229  : 
; 230  : 	// generate inverse slopes
; 231  : 	FLOAT invDY = _fltInv(top.y - LBase.y);
; 232  : 	FLOAT invSlopeL = (top.x - LBase.x) * invDY;

	vmovss	xmm1, DWORD PTR top$[rsp]
	vmovss	xmm6, DWORD PTR top$[rsp+4]
	vsubss	xmm0, xmm1, xmm7
	vsubss	xmm2, xmm6, xmm8

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vrcpss	xmm3, xmm2, xmm2

; 226  : 		_swapVerts(&LBase, &RBase);
; 227  : 		_swapDepths(subTri->invDepths + 0, subTri->invDepths + 1);
; 228  : 	}
; 229  : 
; 230  : 	// generate inverse slopes
; 231  : 	FLOAT invDY = _fltInv(top.y - LBase.y);
; 232  : 	FLOAT invSlopeL = (top.x - LBase.x) * invDY;

	vmulss	xmm10, xmm0, xmm3

; 233  : 	FLOAT invSlopeR = (top.x - RBase.x) * invDY;

	vsubss	xmm1, xmm1, xmm14
	vmulss	xmm9, xmm1, xmm3

; 234  : 
; 235  : 	// on bad values, don't draw
; 236  : 	if (isinf(invSlopeL) || isinf(invSlopeR)) return;

	vmovaps	xmm0, xmm10
	vmovss	DWORD PTR LBase$2$[rsp], xmm8
	vmovss	DWORD PTR invSlopeL$1$[rsp], xmm10
	vmovss	DWORD PTR invSlopeR$1$[rsp], xmm9
	call	_fdclass
	cmp	ax, 1
	je	$LN10@drawFlatBo
	vmovaps	xmm0, xmm9
	call	_fdclass
	cmp	ax, 1
	je	$LN10@drawFlatBo

; 237  : 
; 238  : 	// walk up from bottom to top
; 239  : 	PCRenderBuffer renderBuff = triContext->renderBuffer;

	mov	rcx, QWORD PTR [r13+648]
	vmovaps	XMMWORD PTR [rsp+192], xmm15
	vxorps	xmm15, xmm15, xmm15
	vmaxss	xmm0, xmm15, xmm8

; 240  : 
; 241  : 	const INT DRAW_Y_START = max(0, LBase.y);
; 242  : 	const INT DRAW_Y_END   = min(renderBuff->height - 1, top.y);

	mov	eax, DWORD PTR [rcx+4]
	vcvttss2si r8d, xmm0
	dec	eax
	mov	QWORD PTR renderBuff$1$[rsp], rcx
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, rax
	vminss	xmm1, xmm0, xmm6
	vcvttss2si eax, xmm1
	mov	DWORD PTR drawY$1$[rsp], r8d
	mov	DWORD PTR DRAW_Y_END$1$[rsp], eax

; 243  : 
; 244  : 	for (INT drawY = DRAW_Y_START; drawY <= DRAW_Y_END; drawY++) {

	cmp	r8d, eax
	jg	$LN119@drawFlatBo
	mov	QWORD PTR [rsp+432], rbx
	mov	QWORD PTR [rsp+384], rsi
	mov	QWORD PTR [rsp+376], rdi
	mov	QWORD PTR [rsp+368], r12
	mov	QWORD PTR [rsp+360], r14
	mov	QWORD PTR [rsp+352], r15
	vmovaps	XMMWORD PTR [rsp+256], xmm11
	vmovaps	XMMWORD PTR [rsp+240], xmm12
	vmovaps	XMMWORD PTR [rsp+224], xmm13
	vmovss	xmm13, DWORD PTR __real@ba83126f
	npad	15
$LL4@drawFlatBo:

; 245  : 
; 246  : 		// get distance travelled from start Y
; 247  : 		// yDist has the potential to be < 0 due to floating point math, so we clamp it
; 248  : 		FLOAT yDist = max(0.0f, drawY - LBase.y);
; 249  : 
; 250  : 		// generate start and end X positions
; 251  : 		const INT DRAW_X_START =
; 252  : 			max(0, LBase.x + (invSlopeL * yDist));
; 253  : 		const INT DRAW_X_END =

	mov	eax, DWORD PTR [rcx]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, r8d
	vsubss	xmm1, xmm0, xmm8
	vmaxss	xmm3, xmm15, xmm1
	dec	eax
	vmulss	xmm0, xmm3, xmm10
	vaddss	xmm2, xmm0, xmm7
	vmaxss	xmm1, xmm15, xmm2
	vxorps	xmm2, xmm2, xmm2
	vcvttss2si r12d, xmm1
	vcvtsi2ss xmm2, xmm2, rax
	vmulss	xmm0, xmm3, xmm9
	vaddss	xmm1, xmm0, xmm14
	vminss	xmm2, xmm2, xmm1
	vcvttss2si eax, xmm2
	mov	DWORD PTR DRAW_X_END$1$[rsp], eax

; 257  : 		for (INT drawX = DRAW_X_START; drawX <= DRAW_X_END; drawX++) {

	cmp	r12d, eax
	jg	$LN2@drawFlatBo
	vmovss	xmm14, DWORD PTR __real@3f800000
	vxorps	xmm15, xmm15, xmm15
	vcvtsi2ss xmm15, xmm15, r8d
$LL7@drawFlatBo:

; 197  : 	CVect3F bWeights =

	mov	rcx, QWORD PTR [r13+32]

; 198  : 		_generateBarycentricWeights(triContext->screenTriAndData, drawVect);
; 199  : 	drawVect.z = _interpolateDepth(bWeights, triContext->screenTriAndData);
; 200  : 
; 201  : 	// early depth test
; 202  : 	if (CRenderBufferUnsafeDepthTest(triContext->renderBuffer, drawX, drawY, drawVect.z) == FALSE) return;

	mov	rdx, QWORD PTR [r13+648]
	vxorps	xmm4, xmm4, xmm4

; 189  : 		}
; 190  : 	}
; 191  : }
; 192  : 
; 193  : static __forceinline void _prepareAndDrawFragment(PCIPTriContext triContext, INT drawX, INT drawY) {
; 194  : 	// create fragment with interpolated depth
; 195  : 	CVect3F drawVect =

	vcvtsi2ss xmm4, xmm4, r12d

; 123  : 	CVect3F p2 = triangle->verts[1];

	vmovsd	xmm11, QWORD PTR [rcx+1740]

; 124  : 	CVect3F p3 = triangle->verts[2];

	vmovsd	xmm0, QWORD PTR [rcx+1752]
	vmovsd	xmm1, QWORD PTR [rcx+1728]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	mov	rax, QWORD PTR [rdx+16]
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 128  : 	FLOAT invDenom = _fltInv((p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y));

	vshufps	xmm10, xmm0, xmm0, 85			; 00000055H
	vmovsd	QWORD PTR p3$14[rsp], xmm0
	vmovss	xmm9, DWORD PTR p3$14[rsp]
	vmovsd	QWORD PTR p1$13[rsp], xmm1
	vmovss	xmm8, DWORD PTR p1$13[rsp]
	vshufps	xmm12, xmm1, xmm1, 85			; 00000055H

; 129  : 	FLOAT dv3x = vert.x - p3.x;

	vsubss	xmm4, xmm4, xmm9
	vsubss	xmm0, xmm9, xmm11
	vsubss	xmm1, xmm12, xmm10
	vmulss	xmm2, xmm1, xmm0
	vsubss	xmm1, xmm8, xmm9
	vmovsd	QWORD PTR p2$16[rbp-256], xmm11
	vmovss	xmm6, DWORD PTR p2$16[rbp-252]
	vsubss	xmm0, xmm6, xmm10
	vmulss	xmm1, xmm1, xmm0
	vaddss	xmm3, xmm2, xmm1
	vxorps	xmm2, xmm2, xmm2

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vmovss3	xmm7, xmm2, xmm3

; 131  : 	weights.x = ((p2.y - p3.y) * (dv3x) + (p3.x - p2.x) * (dv3y)) * invDenom;

	vsubss	xmm0, xmm9, xmm11
	vsubss	xmm5, xmm15, xmm10
	vmulss	xmm3, xmm0, xmm5
	vsubss	xmm1, xmm6, xmm10
	vmulss	xmm2, xmm1, xmm4
	vaddss	xmm0, xmm3, xmm2

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vrcpss	xmm7, xmm7, xmm7

; 131  : 	weights.x = ((p2.y - p3.y) * (dv3x) + (p3.x - p2.x) * (dv3y)) * invDenom;

	vmulss	xmm11, xmm0, xmm7

; 132  : 	weights.y = ((p3.y - p1.y) * (dv3x) + (p1.x - p3.x) * (dv3y)) * invDenom;

	vsubss	xmm0, xmm8, xmm9
	vmulss	xmm2, xmm0, xmm5
	vsubss	xmm1, xmm10, xmm12
	vmulss	xmm3, xmm1, xmm4
	vaddss	xmm1, xmm3, xmm2

; 144  : 	weights.x *= (triangle->invDepths[0]);

	vmulss	xmm2, xmm11, DWORD PTR [rcx+1764]

; 132  : 	weights.y = ((p3.y - p1.y) * (dv3x) + (p1.x - p3.x) * (dv3y)) * invDenom;

	vmulss	xmm7, xmm1, xmm7

; 133  : 	weights.z = 1 - weights.x - weights.y;

	vsubss	xmm0, xmm14, xmm11
	vsubss	xmm8, xmm0, xmm7

; 145  : 	weights.y *= (triangle->invDepths[1]);

	vmulss	xmm0, xmm7, DWORD PTR [rcx+1768]

; 146  : 	weights.z *= (triangle->invDepths[2]);

	vmulss	xmm1, xmm8, DWORD PTR [rcx+1772]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	mov	ecx, DWORD PTR [rdx+4]
	sub	ecx, r8d
	dec	ecx
	imul	ecx, DWORD PTR [rdx]
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 148  : 	return _fltInv(weights.x + weights.y + weights.z);

	vaddss	xmm0, xmm0, xmm2
	vaddss	xmm1, xmm0, xmm1
	vxorps	xmm2, xmm2, xmm2

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vmovss3	xmm4, xmm2, xmm1
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	add	ecx, r12d
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vrcpss	xmm4, xmm4, xmm4
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	vmovss	xmm0, DWORD PTR [rax+rcx*4]

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	vsubss	xmm1, xmm0, xmm4
	vcomiss	xmm1, xmm13
	jae	$LN5@drawFlatBo
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 205  : 	PCIPFragContext fContext = &triContext->fragContext;

	lea	r15, QWORD PTR [r13+40]
	mov	r14d, 4

; 206  : 	fContext->barycentricWeightings = bWeights;

	vmovss	DWORD PTR [r15+596], xmm11
	vmovss	DWORD PTR [r15+600], xmm7
	vmovss	DWORD PTR [r15+604], xmm8

; 207  : 	fContext->fragPos.x = drawX;
; 208  : 	fContext->fragPos.y = drawY;

	mov	DWORD PTR [r15+588], r8d
	lea	r8, QWORD PTR [r15+80]

; 209  : 	fContext->fragPos.depth = drawVect.z;

	vmovss	DWORD PTR [r15+592], xmm4
	mov	DWORD PTR [r15+584], r12d

; 210  : 
; 211  : 	_prepareFragmentInputValues(&fContext->fragInputs, triContext->screenTriAndData, bWeights);

	mov	r9, QWORD PTR [r13+32]
	mov	rsi, r9
	sub	rsi, r15

; 154  : 	PCIPVertOutputList fragInputList2 = &triData->vertOutputs[1];

	lea	rbx, QWORD PTR [r9+576]

; 205  : 	PCIPFragContext fContext = &triContext->fragContext;

	sub	rbx, r15

; 155  : 	PCIPVertOutputList fragInputList3 = &triData->vertOutputs[2];

	lea	rdi, QWORD PTR [r9+1152]

; 205  : 	PCIPFragContext fContext = &triContext->fragContext;

	sub	rdi, r15
	npad	4
$LL47@drawFlatBo:

; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rsi+r8-80]
	lea	r11, QWORD PTR [rsi+r8]
	test	eax, eax
	je	SHORT $LN45@drawFlatBo

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r10d, r10d
	test	eax, eax
	je	SHORT $LN45@drawFlatBo
	npad	12
$LL50@drawFlatBo:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm11, DWORD PTR [r9+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [r11+r10*4-76]
	vmulss	xmm4, xmm7, DWORD PTR [r9+1768]
	vmulss	xmm5, xmm8, DWORD PTR [r9+1772]
	lea	rax, QWORD PTR [r8+rbx]
	vmulss	xmm1, xmm4, DWORD PTR [rax+r10*4-76]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [rdi+r8]
	vmulss	xmm1, xmm5, DWORD PTR [rcx+r10*4-76]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm4, xmm6
	vaddss	xmm2, xmm0, xmm5
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [r8+r10*4-68], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [r11-80]
	inc	r10d
	mov	DWORD PTR [r8-72], eax
	cmp	r10d, DWORD PTR [r11-80]
	jb	SHORT $LL50@drawFlatBo
$LN45@drawFlatBo:

; 159  : 		// get frag inputs
; 160  : 		PCIPVertOutput vertOutput1 = fragInputList1->outputs + inputID;
; 161  : 		PCIPVertOutput vertOutput2 = fragInputList2->outputs + inputID;
; 162  : 		PCIPVertOutput vertOutput3 = fragInputList3->outputs + inputID;
; 163  : 		PCIPVertOutput outVertOutput = inOutVertList->outputs + inputID;
; 164  : 
; 165  : 		// if componentcount is 0, skip
; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rsi+r8-44]
	lea	r11, QWORD PTR [rsi+r8]
	test	eax, eax
	je	SHORT $LN92@drawFlatBo

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r10d, r10d
	test	eax, eax
	je	SHORT $LN92@drawFlatBo
	npad	8
$LL91@drawFlatBo:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm11, DWORD PTR [r9+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [r11+r10*4-40]
	vmulss	xmm4, xmm7, DWORD PTR [r9+1768]
	vmulss	xmm5, xmm8, DWORD PTR [r9+1772]
	lea	rax, QWORD PTR [r8+r10*4]
	vmulss	xmm1, xmm4, DWORD PTR [rax+rbx-40]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [rdi+r10*4]
	vmulss	xmm1, xmm5, DWORD PTR [rcx+r8-40]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm4, xmm6
	vaddss	xmm2, xmm0, xmm5
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [r8+r10*4-32], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [r11-44]
	inc	r10d
	mov	DWORD PTR [r8-36], eax
	cmp	r10d, DWORD PTR [r11-44]
	jb	SHORT $LL91@drawFlatBo
$LN92@drawFlatBo:

; 159  : 		// get frag inputs
; 160  : 		PCIPVertOutput vertOutput1 = fragInputList1->outputs + inputID;
; 161  : 		PCIPVertOutput vertOutput2 = fragInputList2->outputs + inputID;
; 162  : 		PCIPVertOutput vertOutput3 = fragInputList3->outputs + inputID;
; 163  : 		PCIPVertOutput outVertOutput = inOutVertList->outputs + inputID;
; 164  : 
; 165  : 		// if componentcount is 0, skip
; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rsi+r8-8]
	lea	r11, QWORD PTR [rsi+r8]
	test	eax, eax
	je	SHORT $LN95@drawFlatBo

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r10d, r10d
	test	eax, eax
	je	SHORT $LN95@drawFlatBo
	npad	9
$LL94@drawFlatBo:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm11, DWORD PTR [r9+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [r11+r10*4-4]
	vmulss	xmm4, xmm7, DWORD PTR [r9+1768]
	vmulss	xmm5, xmm8, DWORD PTR [r9+1772]
	lea	rax, QWORD PTR [r8+r10*4]
	vmulss	xmm1, xmm4, DWORD PTR [rax+rbx-4]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [rdi+r10*4]
	vmulss	xmm1, xmm5, DWORD PTR [rcx+r8-4]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm4, xmm6
	vaddss	xmm2, xmm0, xmm5
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [r8+r10*4+4], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [r11-8]
	inc	r10d
	mov	DWORD PTR [r8], eax
	cmp	r10d, DWORD PTR [r11-8]
	jb	SHORT $LL94@drawFlatBo
$LN95@drawFlatBo:

; 159  : 		// get frag inputs
; 160  : 		PCIPVertOutput vertOutput1 = fragInputList1->outputs + inputID;
; 161  : 		PCIPVertOutput vertOutput2 = fragInputList2->outputs + inputID;
; 162  : 		PCIPVertOutput vertOutput3 = fragInputList3->outputs + inputID;
; 163  : 		PCIPVertOutput outVertOutput = inOutVertList->outputs + inputID;
; 164  : 
; 165  : 		// if componentcount is 0, skip
; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rsi+r8+28]
	lea	r11, QWORD PTR [rsi+r8]
	test	eax, eax
	je	SHORT $LN98@drawFlatBo

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r10d, r10d
	test	eax, eax
	je	SHORT $LN98@drawFlatBo
	npad	10
$LL97@drawFlatBo:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm11, DWORD PTR [r9+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [r11+r10*4+32]
	vmulss	xmm4, xmm7, DWORD PTR [r9+1768]
	vmulss	xmm5, xmm8, DWORD PTR [r9+1772]
	lea	rax, QWORD PTR [r8+r10*4]
	vmulss	xmm1, xmm4, DWORD PTR [rax+rbx+32]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [rdi+r10*4]
	vmulss	xmm1, xmm5, DWORD PTR [rcx+r8+32]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm4, xmm6
	vaddss	xmm2, xmm0, xmm5
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [r8+r10*4+40], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [r11+28]
	inc	r10d
	mov	DWORD PTR [r8+36], eax
	cmp	r10d, DWORD PTR [r11+28]
	jb	SHORT $LL97@drawFlatBo
$LN98@drawFlatBo:

; 156  : 
; 157  : 	// interpolate all input values based on fragment
; 158  : 	for (UINT32 inputID = 0; inputID < CSM_CLASS_MAX_VERTEX_DATA; inputID++) {

	add	r8, 144					; 00000090H
	sub	r14, 1
	jne	$LL47@drawFlatBo

; 18   : 	PCRenderBuffer renderBuffer = triContext->renderBuffer;

	mov	rdi, QWORD PTR [r13+648]

; 19   : 	// generate frag position
; 20   : 	INT fragPosX = triContext->fragContext.fragPos.x;
; 21   : 	INT fragPosY = triContext->fragContext.fragPos.y;

	mov	r14d, DWORD PTR [r13+628]
	mov	esi, DWORD PTR [r13+624]

; 30   : 	if (triContext->material != NULL) {

	mov	r10, QWORD PTR [r13+656]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 157  : 	colorOut[0] = _findColorPtr(handle, x, y)[0];

	mov	ecx, DWORD PTR [rdi+4]
	mov	rax, QWORD PTR [rdi+8]
	sub	ecx, r14d

; 63   : 	return b->color + (x + ((b->height - y - 1) * b->width));

	dec	ecx
; File C:\Bailey\Programming\Caesium\csm.c

; 57   : 	rCol.g = g;

	mov	WORD PTR rCol$11[rsp+1], 0
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 63   : 	return b->color + (x + ((b->height - y - 1) * b->width));

	imul	ecx, DWORD PTR [rdi]
; File C:\Bailey\Programming\Caesium\csm.c

; 58   : 	rCol.b = b;

	mov	BYTE PTR rCol$11[rsp], 0

; 59   : 	rCol.a = a;

	mov	BYTE PTR rCol$11[rsp+3], 0
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 63   : 	return b->color + (x + ((b->height - y - 1) * b->width));

	add	ecx, esi

; 157  : 	colorOut[0] = _findColorPtr(handle, x, y)[0];

	mov	ebx, DWORD PTR [rax+rcx*4]
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 29   : 	CColor fragColor = CMakeColor4(0, 0, 0, 0);

	mov	eax, DWORD PTR rCol$11[rsp]
	mov	DWORD PTR fragColor$17[rbp-256], eax

; 30   : 	if (triContext->material != NULL) {

	test	r10, r10
	je	SHORT $LN54@drawFlatBo

; 31   : 		// apply fragment shader
; 32   : 		BOOL keepFrag = triContext->material->fragmentShader(

	mov	eax, DWORD PTR [r13+632]
	lea	r9, QWORD PTR $T7[rbp-256]
	vmovsd	xmm0, QWORD PTR [r13+624]
	mov	r8d, DWORD PTR [r13+16]
	mov	rcx, r15
	mov	edx, DWORD PTR [r13+20]
	mov	DWORD PTR $T7[rbp-248], eax
	lea	rax, QWORD PTR fragColor$17[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	vmovsd	QWORD PTR $T7[rbp-256], xmm0
	call	QWORD PTR [r10+16]

; 33   : 			&triContext->fragContext,
; 34   : 			triContext->triangleID,
; 35   : 			triContext->instanceID,
; 36   : 			triContext->fragContext.fragPos,
; 37   : 			&fragColor
; 38   : 		);
; 39   : 		if (keepFrag == FALSE) return; // cull if needed

	test	eax, eax
	je	$LN118@drawFlatBo

; 40   : 	}

	mov	eax, DWORD PTR fragColor$17[rbp-256]
	jmp	SHORT $LN55@drawFlatBo
$LN54@drawFlatBo:
; File C:\Bailey\Programming\Caesium\csm.c

; 48   : 	rCol.g = g;

	mov	WORD PTR rCol$12[rsp+1], 65280		; 0000ff00H

; 49   : 	rCol.b = b;

	mov	BYTE PTR rCol$12[rsp], 255		; 000000ffH

; 50   : 	rCol.a = 255;

	mov	BYTE PTR rCol$12[rsp+3], 255		; 000000ffH
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 44   : 		fragColor = CMakeColor3(255, 0, 255);

	mov	eax, DWORD PTR rCol$12[rsp]
	mov	DWORD PTR fragColor$17[rbp-256], eax
$LN55@drawFlatBo:

; 45   : 	}
; 46   : 
; 47   : 	// if color alpha is 0, cull
; 48   : 	if (fragColor.a == 0) return;

	mov	ecx, eax
	shr	ecx, 24
	test	cl, cl
	je	SHORT $LN118@drawFlatBo

; 49   : 
; 50   : 	// apply alpha blend (if needed)
; 51   : 	if (fragColor.a != 255)

	cmp	cl, 255					; 000000ffH
	je	SHORT $LN58@drawFlatBo

; 52   : 		fragColor = CFragmentBlendColor(belowColor, fragColor);

	mov	edx, eax
	mov	ecx, ebx
	call	CFragmentBlendColor
	mov	DWORD PTR fragColor$17[rbp-256], eax
$LN58@drawFlatBo:
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	mov	edx, DWORD PTR [rdi+4]

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	mov	rcx, QWORD PTR [rdi+16]

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	sub	edx, r14d
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 55   : 	CRenderBufferUnsafeSetFragment(

	vmovss	xmm2, DWORD PTR [r13+632]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	mov	r8d, DWORD PTR drawY$1$[rsp]

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	dec	edx
	imul	edx, DWORD PTR [rdi]
	add	edx, esi

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	vmovss	xmm0, DWORD PTR [rcx+rdx*4]

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	vsubss	xmm1, xmm0, xmm2
	vcomiss	xmm1, xmm13
	jae	SHORT $LN5@drawFlatBo

; 167  : 	_findColorPtr(handle, x, y)[0] = color;

	mov	rcx, QWORD PTR [rdi+8]
	mov	DWORD PTR [rcx+rdx*4], eax

; 168  : 	_findDepthPtr(handle, x, y)[0] = depth;

	mov	ecx, DWORD PTR [rdi+4]
	mov	rax, QWORD PTR [rdi+16]
	sub	ecx, r14d

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	dec	ecx
	imul	ecx, DWORD PTR [rdi]
	add	ecx, esi

; 168  : 	_findDepthPtr(handle, x, y)[0] = depth;

	vmovss	DWORD PTR [rax+rcx*4], xmm2

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	jmp	SHORT $LN5@drawFlatBo
$LN118@drawFlatBo:
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 257  : 		for (INT drawX = DRAW_X_START; drawX <= DRAW_X_END; drawX++) {

	mov	r8d, DWORD PTR drawY$1$[rsp]
$LN5@drawFlatBo:
	inc	r12d
	cmp	r12d, DWORD PTR DRAW_X_END$1$[rsp]
	jle	$LL7@drawFlatBo
	vmovsd	xmm14, QWORD PTR tv2294[rbp-256]
	vmovsd	xmm7, QWORD PTR tv2284[rbp-256]
	vmovss	xmm8, DWORD PTR LBase$2$[rsp]
	vmovss	xmm9, DWORD PTR invSlopeR$1$[rsp]
	vmovss	xmm10, DWORD PTR invSlopeL$1$[rsp]
	mov	rcx, QWORD PTR renderBuff$1$[rsp]
	vxorps	xmm15, xmm15, xmm15
$LN2@drawFlatBo:

; 243  : 
; 244  : 	for (INT drawY = DRAW_Y_START; drawY <= DRAW_Y_END; drawY++) {

	inc	r8d
	mov	DWORD PTR drawY$1$[rsp], r8d
	cmp	r8d, DWORD PTR DRAW_Y_END$1$[rsp]
	jle	$LL4@drawFlatBo
	vmovaps	xmm13, XMMWORD PTR [rsp+224]
	vmovaps	xmm12, XMMWORD PTR [rsp+240]
	vmovaps	xmm11, XMMWORD PTR [rsp+256]
	mov	r15, QWORD PTR [rsp+352]
	mov	r14, QWORD PTR [rsp+360]
	mov	r12, QWORD PTR [rsp+368]
	mov	rdi, QWORD PTR [rsp+376]
	mov	rsi, QWORD PTR [rsp+384]
	mov	rbx, QWORD PTR [rsp+432]
$LN119@drawFlatBo:
	vmovaps	xmm15, XMMWORD PTR [rsp+192]
$LN10@drawFlatBo:

; 258  : 			// prepare and draw fragment
; 259  : 			_prepareAndDrawFragment(triContext, drawX, drawY);
; 260  : 		}
; 261  : 	}
; 262  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+392]
	vmovaps	xmm6, XMMWORD PTR [r11-56]
	vmovaps	xmm7, XMMWORD PTR [r11-72]
	vmovaps	xmm8, XMMWORD PTR [r11-88]
	vmovaps	xmm9, XMMWORD PTR [r11-104]
	vmovaps	xmm10, XMMWORD PTR [r11-120]
	vmovaps	xmm14, XMMWORD PTR [r11-184]
	mov	rsp, r11
	pop	r13
	pop	rbp
	ret	0
_drawFlatBottomTri ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
;	COMDAT _drawFlatTopTri
_TEXT	SEGMENT
drawY$1$ = 48
rCol$11 = 52
rCol$12 = 56
LBase$2$ = 60
DRAW_X_END$1$ = 64
invSlopeR$1$ = 68
invSlopeL$1$ = 72
DRAW_Y_END$1$ = 76
renderBuff$1$ = 80
bottom$ = 80
p1$13 = 96
RBase$ = 96
p3$14 = 112
LBase$ = 112
$T7 = 128
temp$15 = 128
tv2279 = 144
tv2269 = 152
p2$16 = 160
fragColor$17 = 176
__$ArrayPad$ = 184
triContext$ = 416
subTri$ = 424
_drawFlatTopTri PROC					; COMDAT

; 264  : static __forceinline void _drawFlatTopTri(PCIPTriContext triContext, PCIPTriData subTri) {

	mov	rax, rsp
	push	rbp
	push	r13
	lea	rbp, QWORD PTR [rax-152]
	sub	rsp, 392				; 00000188H
	vmovaps	XMMWORD PTR [rax-72], xmm6
	vmovaps	XMMWORD PTR [rax-88], xmm7
	vmovaps	XMMWORD PTR [rax-104], xmm8
	vmovaps	XMMWORD PTR [rax-120], xmm9
	vmovaps	XMMWORD PTR [rax-200], xmm14
	vmovaps	XMMWORD PTR [rax-216], xmm15
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 265  : 
; 266  : 	// generate each position
; 267  : 	CVect3F LBase  = subTri->verts[0];

	vmovsd	xmm15, QWORD PTR [rdx+1728]

; 268  : 	CVect3F RBase  = subTri->verts[1];

	vmovsd	xmm14, QWORD PTR [rdx+1740]

; 269  : 	CVect3F bottom = subTri->verts[2];
; 270  : 
; 271  : 	// swap to maintain left if necessary
; 272  : 	if (LBase.x > RBase.x) {

	vcomiss	xmm15, xmm14
	vmovsd	xmm0, QWORD PTR [rdx+1752]
	mov	r13, rcx
	vmovsd	QWORD PTR tv2269[rbp-256], xmm15
	vmovsd	QWORD PTR tv2279[rbp-256], xmm14
	vmovsd	QWORD PTR bottom$[rsp], xmm0
	vmovsd	QWORD PTR LBase$[rsp], xmm15
	vmovsd	QWORD PTR RBase$[rsp], xmm14
	jbe	SHORT $LN113@drawFlatTo

; 65   : 	CVect3F temp = *v1;

	mov	eax, DWORD PTR [rdx+1736]

; 66   : 	*v1 = *v2;

	vmovss	xmm7, DWORD PTR RBase$[rsp+4]
	vmovaps	xmm0, xmm15
	vmovaps	xmm15, xmm14

; 67   : 	*v2 = temp;

	vmovaps	xmm14, xmm0
	vmovsd	QWORD PTR temp$15[rbp-256], xmm0

; 71   : 	FLOAT temp = *d1;

	vmovss	xmm0, DWORD PTR [rdx+1764]

; 65   : 	CVect3F temp = *v1;

	mov	DWORD PTR temp$15[rbp-248], eax

; 72   : 	*d1 = *d2;

	mov	eax, DWORD PTR [rdx+1768]

; 73   : 	*d2 = temp;

	vmovss	DWORD PTR [rdx+1768], xmm0

; 66   : 	*v1 = *v2;

	vmovsd	QWORD PTR tv2269[rbp-256], xmm15

; 67   : 	*v2 = temp;

	vmovsd	QWORD PTR tv2279[rbp-256], xmm14

; 72   : 	*d1 = *d2;

	mov	DWORD PTR [rdx+1764], eax

; 269  : 	CVect3F bottom = subTri->verts[2];
; 270  : 
; 271  : 	// swap to maintain left if necessary
; 272  : 	if (LBase.x > RBase.x) {

	jmp	SHORT $LN117@drawFlatTo
$LN113@drawFlatTo:
	vmovss	xmm7, DWORD PTR LBase$[rsp+4]
$LN117@drawFlatTo:

; 273  : 		_swapVerts(&LBase, &RBase);
; 274  : 		_swapDepths(subTri->invDepths + 0, subTri->invDepths + 1);
; 275  : 	}
; 276  : 
; 277  : 	// generate inverse slopes
; 278  : 	FLOAT invDY = _fltInv(bottom.y - LBase.y);
; 279  : 	FLOAT invSlopeL = (bottom.x - LBase.x) * invDY;

	vmovss	xmm1, DWORD PTR bottom$[rsp]
	vmovss	xmm6, DWORD PTR bottom$[rsp+4]
	vsubss	xmm0, xmm1, xmm15
	vsubss	xmm2, xmm6, xmm7

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vrcpss	xmm3, xmm2, xmm2

; 273  : 		_swapVerts(&LBase, &RBase);
; 274  : 		_swapDepths(subTri->invDepths + 0, subTri->invDepths + 1);
; 275  : 	}
; 276  : 
; 277  : 	// generate inverse slopes
; 278  : 	FLOAT invDY = _fltInv(bottom.y - LBase.y);
; 279  : 	FLOAT invSlopeL = (bottom.x - LBase.x) * invDY;

	vmulss	xmm9, xmm0, xmm3

; 280  : 	FLOAT invSlopeR = (bottom.x - RBase.x) * invDY;

	vsubss	xmm1, xmm1, xmm14
	vmulss	xmm8, xmm1, xmm3

; 281  : 
; 282  : 	// on bad values, don't draw
; 283  : 	if (isinf(invSlopeL) || isinf(invSlopeR)) return;

	vmovaps	xmm0, xmm9
	vmovss	DWORD PTR LBase$2$[rsp], xmm7
	vmovss	DWORD PTR invSlopeL$1$[rsp], xmm9
	vmovss	DWORD PTR invSlopeR$1$[rsp], xmm8
	call	_fdclass
	cmp	ax, 1
	je	$LN10@drawFlatTo
	vmovaps	xmm0, xmm8
	call	_fdclass
	cmp	ax, 1
	je	$LN10@drawFlatTo

; 284  : 
; 285  : 	// walk down from top to bottom
; 286  : 	PCRenderBuffer renderBuff = triContext->renderBuffer;

	mov	rcx, QWORD PTR [r13+648]
	vxorps	xmm0, xmm0, xmm0
	vxorps	xmm4, xmm4, xmm4
	mov	QWORD PTR renderBuff$1$[rsp], rcx

; 287  : 
; 288  : 	// calculate top and bottom
; 289  : 	const INT DRAW_Y_START = min(renderBuff->height - 1, LBase.y);

	mov	eax, DWORD PTR [rcx+4]
	dec	eax
	vcvtsi2ss xmm0, xmm0, rax
	vminss	xmm1, xmm0, xmm7
	vcvttss2si r8d, xmm1
	vmaxss	xmm0, xmm4, xmm6

; 290  : 	const INT DRAW_Y_END = max(0, bottom.y);

	vcvttss2si eax, xmm0
	mov	DWORD PTR drawY$1$[rsp], r8d
	mov	DWORD PTR DRAW_Y_END$1$[rsp], eax

; 291  : 
; 292  : 	// note: Y walks downwards
; 293  : 	for (INT drawY = DRAW_Y_START; drawY >= DRAW_Y_END; drawY--) {

	cmp	r8d, eax
	jl	$LN10@drawFlatTo
	mov	QWORD PTR [rsp+432], rbx
	mov	QWORD PTR [rsp+384], rsi
	mov	QWORD PTR [rsp+376], rdi
	mov	QWORD PTR [rsp+368], r12
	mov	QWORD PTR [rsp+360], r14
	mov	QWORD PTR [rsp+352], r15
	vmovaps	XMMWORD PTR [rsp+272], xmm10
	vmovaps	XMMWORD PTR [rsp+256], xmm11
	vmovaps	XMMWORD PTR [rsp+240], xmm12
	vmovaps	XMMWORD PTR [rsp+224], xmm13
	vmovss	xmm13, DWORD PTR __real@ba83126f
$LL4@drawFlatTo:

; 294  : 
; 295  : 		// get distance travelled from start Y
; 296  : 		FLOAT yDist = LBase.y - drawY;
; 297  : 
; 298  : 		// generate start and end X positions
; 299  : 		const INT DRAW_X_START =
; 300  : 			max(0, LBase.x - (invSlopeL * yDist));
; 301  : 		const INT DRAW_X_END =

	mov	eax, DWORD PTR [rcx]
	vxorps	xmm0, xmm0, xmm0
	vcvtsi2ss xmm0, xmm0, r8d
	vsubss	xmm3, xmm7, xmm0
	dec	eax
	vmulss	xmm1, xmm3, xmm9
	vsubss	xmm2, xmm15, xmm1
	vmaxss	xmm0, xmm4, xmm2
	vcvttss2si r12d, xmm0
	vxorps	xmm2, xmm2, xmm2
	vcvtsi2ss xmm2, xmm2, rax
	vmulss	xmm0, xmm3, xmm8
	vsubss	xmm1, xmm14, xmm0
	vminss	xmm2, xmm2, xmm1
	vcvttss2si eax, xmm2
	mov	DWORD PTR DRAW_X_END$1$[rsp], eax

; 305  : 		for (INT drawX = DRAW_X_START; drawX <= DRAW_X_END; drawX++) {

	cmp	r12d, eax
	jg	$LN2@drawFlatTo
	vmovss	xmm14, DWORD PTR __real@3f800000
	vxorps	xmm15, xmm15, xmm15
	vcvtsi2ss xmm15, xmm15, r8d
	npad	5
$LL7@drawFlatTo:

; 197  : 	CVect3F bWeights =

	mov	rcx, QWORD PTR [r13+32]

; 198  : 		_generateBarycentricWeights(triContext->screenTriAndData, drawVect);
; 199  : 	drawVect.z = _interpolateDepth(bWeights, triContext->screenTriAndData);
; 200  : 
; 201  : 	// early depth test
; 202  : 	if (CRenderBufferUnsafeDepthTest(triContext->renderBuffer, drawX, drawY, drawVect.z) == FALSE) return;

	mov	rdx, QWORD PTR [r13+648]
	vxorps	xmm4, xmm4, xmm4

; 189  : 		}
; 190  : 	}
; 191  : }
; 192  : 
; 193  : static __forceinline void _prepareAndDrawFragment(PCIPTriContext triContext, INT drawX, INT drawY) {
; 194  : 	// create fragment with interpolated depth
; 195  : 	CVect3F drawVect =

	vcvtsi2ss xmm4, xmm4, r12d

; 124  : 	CVect3F p3 = triangle->verts[2];

	vmovsd	xmm11, QWORD PTR [rcx+1752]
	vmovsd	xmm0, QWORD PTR [rcx+1740]
	vmovsd	xmm12, QWORD PTR [rcx+1728]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	mov	rax, QWORD PTR [rdx+16]
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 128  : 	FLOAT invDenom = _fltInv((p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y));

	vshufps	xmm9, xmm0, xmm0, 85			; 00000055H
	vmovsd	QWORD PTR p2$16[rbp-256], xmm0

; 129  : 	FLOAT dv3x = vert.x - p3.x;

	vsubss	xmm4, xmm4, xmm11
	vsubss	xmm1, xmm12, xmm11
	vmovsd	QWORD PTR p3$14[rsp], xmm11
	vmovss	xmm10, DWORD PTR p3$14[rsp+4]
	vsubss	xmm0, xmm9, xmm10
	vmulss	xmm2, xmm1, xmm0
	vsubss	xmm0, xmm11, DWORD PTR p2$16[rbp-256]

; 130  : 	FLOAT dv3y = vert.y - p3.y;

	vsubss	xmm6, xmm15, xmm10
	vmovsd	QWORD PTR p1$13[rsp], xmm12
	vmovss	xmm8, DWORD PTR p1$13[rsp+4]
	vsubss	xmm1, xmm8, xmm10
	vmulss	xmm1, xmm1, xmm0

; 131  : 	weights.x = ((p2.y - p3.y) * (dv3x) + (p3.x - p2.x) * (dv3y)) * invDenom;

	vsubss	xmm0, xmm11, DWORD PTR p2$16[rbp-256]
	vaddss	xmm3, xmm2, xmm1
	vxorps	xmm2, xmm2, xmm2

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vmovss3	xmm7, xmm2, xmm3

; 131  : 	weights.x = ((p2.y - p3.y) * (dv3x) + (p3.x - p2.x) * (dv3y)) * invDenom;

	vmulss	xmm3, xmm0, xmm6
	vsubss	xmm1, xmm9, xmm10
	vmulss	xmm2, xmm1, xmm4
	vaddss	xmm0, xmm3, xmm2

; 132  : 	weights.y = ((p3.y - p1.y) * (dv3x) + (p1.x - p3.x) * (dv3y)) * invDenom;

	vsubss	xmm1, xmm10, xmm8
	vmulss	xmm3, xmm1, xmm4

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vrcpss	xmm7, xmm7, xmm7

; 131  : 	weights.x = ((p2.y - p3.y) * (dv3x) + (p3.x - p2.x) * (dv3y)) * invDenom;

	vmulss	xmm9, xmm0, xmm7

; 132  : 	weights.y = ((p3.y - p1.y) * (dv3x) + (p1.x - p3.x) * (dv3y)) * invDenom;

	vsubss	xmm0, xmm12, xmm11
	vmulss	xmm2, xmm0, xmm6
	vaddss	xmm1, xmm3, xmm2

; 144  : 	weights.x *= (triangle->invDepths[0]);

	vmulss	xmm2, xmm9, DWORD PTR [rcx+1764]

; 132  : 	weights.y = ((p3.y - p1.y) * (dv3x) + (p1.x - p3.x) * (dv3y)) * invDenom;

	vmulss	xmm7, xmm1, xmm7

; 133  : 	weights.z = 1 - weights.x - weights.y;

	vsubss	xmm0, xmm14, xmm9
	vsubss	xmm8, xmm0, xmm7

; 146  : 	weights.z *= (triangle->invDepths[2]);

	vmulss	xmm1, xmm8, DWORD PTR [rcx+1772]
	vmulss	xmm0, xmm7, DWORD PTR [rcx+1768]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	mov	ecx, DWORD PTR [rdx+4]
	sub	ecx, r8d
	dec	ecx
	imul	ecx, DWORD PTR [rdx]
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 148  : 	return _fltInv(weights.x + weights.y + weights.z);

	vaddss	xmm0, xmm0, xmm2
	vaddss	xmm3, xmm0, xmm1

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vrcpss	xmm4, xmm3, xmm3
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	add	ecx, r12d

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	vmovss	xmm0, DWORD PTR [rax+rcx*4]

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	vsubss	xmm1, xmm0, xmm4
	vcomiss	xmm1, xmm13
	jae	$LN5@drawFlatTo
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 205  : 	PCIPFragContext fContext = &triContext->fragContext;

	lea	r15, QWORD PTR [r13+40]
	mov	r14d, 4

; 206  : 	fContext->barycentricWeightings = bWeights;

	vmovss	DWORD PTR [r15+596], xmm9
	vmovss	DWORD PTR [r15+600], xmm7
	vmovss	DWORD PTR [r15+604], xmm8

; 207  : 	fContext->fragPos.x = drawX;
; 208  : 	fContext->fragPos.y = drawY;

	mov	DWORD PTR [r15+588], r8d
	lea	r8, QWORD PTR [r15+80]

; 209  : 	fContext->fragPos.depth = drawVect.z;

	vmovss	DWORD PTR [r15+592], xmm4
	mov	DWORD PTR [r15+584], r12d

; 210  : 
; 211  : 	_prepareFragmentInputValues(&fContext->fragInputs, triContext->screenTriAndData, bWeights);

	mov	r9, QWORD PTR [r13+32]
	mov	rsi, r9
	sub	rsi, r15

; 154  : 	PCIPVertOutputList fragInputList2 = &triData->vertOutputs[1];

	lea	rbx, QWORD PTR [r9+576]

; 205  : 	PCIPFragContext fContext = &triContext->fragContext;

	sub	rbx, r15

; 155  : 	PCIPVertOutputList fragInputList3 = &triData->vertOutputs[2];

	lea	rdi, QWORD PTR [r9+1152]

; 205  : 	PCIPFragContext fContext = &triContext->fragContext;

	sub	rdi, r15
	npad	7
$LL45@drawFlatTo:

; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rsi+r8-80]
	lea	r11, QWORD PTR [rsi+r8]
	test	eax, eax
	je	SHORT $LN43@drawFlatTo

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r10d, r10d
	test	eax, eax
	je	SHORT $LN43@drawFlatTo
	npad	12
$LL48@drawFlatTo:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm9, DWORD PTR [r9+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [r11+r10*4-76]
	vmulss	xmm5, xmm7, DWORD PTR [r9+1768]
	vmulss	xmm4, xmm8, DWORD PTR [r9+1772]
	lea	rax, QWORD PTR [r8+r10*4]
	vmulss	xmm1, xmm5, DWORD PTR [rax+rbx-76]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [r8+r10*4]
	vmulss	xmm1, xmm4, DWORD PTR [rcx+rdi-76]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm5, xmm6
	vaddss	xmm2, xmm0, xmm4
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [r8+r10*4-68], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [r11-80]
	inc	r10d
	mov	DWORD PTR [r8-72], eax
	cmp	r10d, DWORD PTR [r11-80]
	jb	SHORT $LL48@drawFlatTo
$LN43@drawFlatTo:

; 159  : 		// get frag inputs
; 160  : 		PCIPVertOutput vertOutput1 = fragInputList1->outputs + inputID;
; 161  : 		PCIPVertOutput vertOutput2 = fragInputList2->outputs + inputID;
; 162  : 		PCIPVertOutput vertOutput3 = fragInputList3->outputs + inputID;
; 163  : 		PCIPVertOutput outVertOutput = inOutVertList->outputs + inputID;
; 164  : 
; 165  : 		// if componentcount is 0, skip
; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rsi+r8-44]
	lea	r11, QWORD PTR [rsi+r8]
	test	eax, eax
	je	SHORT $LN90@drawFlatTo

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r10d, r10d
	test	eax, eax
	je	SHORT $LN90@drawFlatTo
	npad	10
$LL89@drawFlatTo:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm9, DWORD PTR [r9+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [r11+r10*4-40]
	vmulss	xmm5, xmm7, DWORD PTR [r9+1768]
	vmulss	xmm4, xmm8, DWORD PTR [r9+1772]
	lea	rax, QWORD PTR [r8+r10*4]
	vmulss	xmm1, xmm5, DWORD PTR [rax+rbx-40]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [r8+r10*4]
	vmulss	xmm1, xmm4, DWORD PTR [rcx+rdi-40]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm5, xmm6
	vaddss	xmm2, xmm0, xmm4
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [r8+r10*4-32], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [r11-44]
	inc	r10d
	mov	DWORD PTR [r8-36], eax
	cmp	r10d, DWORD PTR [r11-44]
	jb	SHORT $LL89@drawFlatTo
$LN90@drawFlatTo:

; 159  : 		// get frag inputs
; 160  : 		PCIPVertOutput vertOutput1 = fragInputList1->outputs + inputID;
; 161  : 		PCIPVertOutput vertOutput2 = fragInputList2->outputs + inputID;
; 162  : 		PCIPVertOutput vertOutput3 = fragInputList3->outputs + inputID;
; 163  : 		PCIPVertOutput outVertOutput = inOutVertList->outputs + inputID;
; 164  : 
; 165  : 		// if componentcount is 0, skip
; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rsi+r8-8]
	lea	r11, QWORD PTR [rsi+r8]
	test	eax, eax
	je	SHORT $LN93@drawFlatTo

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r10d, r10d
	test	eax, eax
	je	SHORT $LN93@drawFlatTo
	npad	10
$LL92@drawFlatTo:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm9, DWORD PTR [r9+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [r11+r10*4-4]
	vmulss	xmm5, xmm7, DWORD PTR [r9+1768]
	vmulss	xmm4, xmm8, DWORD PTR [r9+1772]
	lea	rax, QWORD PTR [r8+r10*4]
	vmulss	xmm1, xmm5, DWORD PTR [rax+rbx-4]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [r8+r10*4]
	vmulss	xmm1, xmm4, DWORD PTR [rcx+rdi-4]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm5, xmm6
	vaddss	xmm2, xmm0, xmm4
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [r8+r10*4+4], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [r11-8]
	inc	r10d
	mov	DWORD PTR [r8], eax
	cmp	r10d, DWORD PTR [r11-8]
	jb	SHORT $LL92@drawFlatTo
$LN93@drawFlatTo:

; 159  : 		// get frag inputs
; 160  : 		PCIPVertOutput vertOutput1 = fragInputList1->outputs + inputID;
; 161  : 		PCIPVertOutput vertOutput2 = fragInputList2->outputs + inputID;
; 162  : 		PCIPVertOutput vertOutput3 = fragInputList3->outputs + inputID;
; 163  : 		PCIPVertOutput outVertOutput = inOutVertList->outputs + inputID;
; 164  : 
; 165  : 		// if componentcount is 0, skip
; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rsi+r8+28]
	lea	r11, QWORD PTR [rsi+r8]
	test	eax, eax
	je	SHORT $LN96@drawFlatTo

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r10d, r10d
	test	eax, eax
	je	SHORT $LN96@drawFlatTo
	npad	11
$LL95@drawFlatTo:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm9, DWORD PTR [r9+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [r11+r10*4+32]
	vmulss	xmm5, xmm7, DWORD PTR [r9+1768]
	vmulss	xmm4, xmm8, DWORD PTR [r9+1772]
	lea	rax, QWORD PTR [r8+r10*4]
	vmulss	xmm1, xmm5, DWORD PTR [rax+rbx+32]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [r8+r10*4]
	vmulss	xmm1, xmm4, DWORD PTR [rcx+rdi+32]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm5, xmm6
	vaddss	xmm2, xmm0, xmm4
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [r8+r10*4+40], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [r11+28]
	inc	r10d
	mov	DWORD PTR [r8+36], eax
	cmp	r10d, DWORD PTR [r11+28]
	jb	SHORT $LL95@drawFlatTo
$LN96@drawFlatTo:

; 156  : 
; 157  : 	// interpolate all input values based on fragment
; 158  : 	for (UINT32 inputID = 0; inputID < CSM_CLASS_MAX_VERTEX_DATA; inputID++) {

	add	r8, 144					; 00000090H
	sub	r14, 1
	jne	$LL45@drawFlatTo

; 18   : 	PCRenderBuffer renderBuffer = triContext->renderBuffer;

	mov	rdi, QWORD PTR [r13+648]

; 19   : 	// generate frag position
; 20   : 	INT fragPosX = triContext->fragContext.fragPos.x;
; 21   : 	INT fragPosY = triContext->fragContext.fragPos.y;

	mov	r14d, DWORD PTR [r13+628]
	mov	esi, DWORD PTR [r13+624]

; 30   : 	if (triContext->material != NULL) {

	mov	r10, QWORD PTR [r13+656]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 157  : 	colorOut[0] = _findColorPtr(handle, x, y)[0];

	mov	ecx, DWORD PTR [rdi+4]
	mov	rax, QWORD PTR [rdi+8]
	sub	ecx, r14d

; 63   : 	return b->color + (x + ((b->height - y - 1) * b->width));

	dec	ecx
; File C:\Bailey\Programming\Caesium\csm.c

; 57   : 	rCol.g = g;

	mov	WORD PTR rCol$11[rsp+1], 0
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 63   : 	return b->color + (x + ((b->height - y - 1) * b->width));

	imul	ecx, DWORD PTR [rdi]
; File C:\Bailey\Programming\Caesium\csm.c

; 58   : 	rCol.b = b;

	mov	BYTE PTR rCol$11[rsp], 0

; 59   : 	rCol.a = a;

	mov	BYTE PTR rCol$11[rsp+3], 0
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 63   : 	return b->color + (x + ((b->height - y - 1) * b->width));

	add	ecx, esi

; 157  : 	colorOut[0] = _findColorPtr(handle, x, y)[0];

	mov	ebx, DWORD PTR [rax+rcx*4]
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 29   : 	CColor fragColor = CMakeColor4(0, 0, 0, 0);

	mov	eax, DWORD PTR rCol$11[rsp]
	mov	DWORD PTR fragColor$17[rbp-256], eax

; 30   : 	if (triContext->material != NULL) {

	test	r10, r10
	je	SHORT $LN52@drawFlatTo

; 31   : 		// apply fragment shader
; 32   : 		BOOL keepFrag = triContext->material->fragmentShader(

	mov	eax, DWORD PTR [r13+632]
	lea	r9, QWORD PTR $T7[rbp-256]
	vmovsd	xmm0, QWORD PTR [r13+624]
	mov	r8d, DWORD PTR [r13+16]
	mov	rcx, r15
	mov	edx, DWORD PTR [r13+20]
	mov	DWORD PTR $T7[rbp-248], eax
	lea	rax, QWORD PTR fragColor$17[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	vmovsd	QWORD PTR $T7[rbp-256], xmm0
	call	QWORD PTR [r10+16]

; 33   : 			&triContext->fragContext,
; 34   : 			triContext->triangleID,
; 35   : 			triContext->instanceID,
; 36   : 			triContext->fragContext.fragPos,
; 37   : 			&fragColor
; 38   : 		);
; 39   : 		if (keepFrag == FALSE) return; // cull if needed

	test	eax, eax
	je	$LN116@drawFlatTo

; 40   : 	}

	mov	eax, DWORD PTR fragColor$17[rbp-256]
	jmp	SHORT $LN53@drawFlatTo
$LN52@drawFlatTo:
; File C:\Bailey\Programming\Caesium\csm.c

; 48   : 	rCol.g = g;

	mov	WORD PTR rCol$12[rsp+1], 65280		; 0000ff00H

; 49   : 	rCol.b = b;

	mov	BYTE PTR rCol$12[rsp], 255		; 000000ffH

; 50   : 	rCol.a = 255;

	mov	BYTE PTR rCol$12[rsp+3], 255		; 000000ffH
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 44   : 		fragColor = CMakeColor3(255, 0, 255);

	mov	eax, DWORD PTR rCol$12[rsp]
	mov	DWORD PTR fragColor$17[rbp-256], eax
$LN53@drawFlatTo:

; 45   : 	}
; 46   : 
; 47   : 	// if color alpha is 0, cull
; 48   : 	if (fragColor.a == 0) return;

	mov	ecx, eax
	shr	ecx, 24
	test	cl, cl
	je	SHORT $LN116@drawFlatTo

; 49   : 
; 50   : 	// apply alpha blend (if needed)
; 51   : 	if (fragColor.a != 255)

	cmp	cl, 255					; 000000ffH
	je	SHORT $LN56@drawFlatTo

; 52   : 		fragColor = CFragmentBlendColor(belowColor, fragColor);

	mov	edx, eax
	mov	ecx, ebx
	call	CFragmentBlendColor
	mov	DWORD PTR fragColor$17[rbp-256], eax
$LN56@drawFlatTo:
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	mov	edx, DWORD PTR [rdi+4]

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	mov	rcx, QWORD PTR [rdi+16]

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	sub	edx, r14d
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 55   : 	CRenderBufferUnsafeSetFragment(

	vmovss	xmm2, DWORD PTR [r13+632]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	mov	r8d, DWORD PTR drawY$1$[rsp]

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	dec	edx
	imul	edx, DWORD PTR [rdi]
	add	edx, esi

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	vmovss	xmm0, DWORD PTR [rcx+rdx*4]

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	vsubss	xmm1, xmm0, xmm2
	vcomiss	xmm1, xmm13
	jae	SHORT $LN5@drawFlatTo

; 167  : 	_findColorPtr(handle, x, y)[0] = color;

	mov	rcx, QWORD PTR [rdi+8]
	mov	DWORD PTR [rcx+rdx*4], eax

; 168  : 	_findDepthPtr(handle, x, y)[0] = depth;

	mov	ecx, DWORD PTR [rdi+4]
	mov	rax, QWORD PTR [rdi+16]
	sub	ecx, r14d

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	dec	ecx
	imul	ecx, DWORD PTR [rdi]
	add	ecx, esi

; 168  : 	_findDepthPtr(handle, x, y)[0] = depth;

	vmovss	DWORD PTR [rax+rcx*4], xmm2

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	jmp	SHORT $LN5@drawFlatTo
$LN116@drawFlatTo:
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 305  : 		for (INT drawX = DRAW_X_START; drawX <= DRAW_X_END; drawX++) {

	mov	r8d, DWORD PTR drawY$1$[rsp]
$LN5@drawFlatTo:
	inc	r12d
	cmp	r12d, DWORD PTR DRAW_X_END$1$[rsp]
	jle	$LL7@drawFlatTo
	vmovsd	xmm14, QWORD PTR tv2279[rbp-256]
	vmovsd	xmm15, QWORD PTR tv2269[rbp-256]
	vmovss	xmm7, DWORD PTR LBase$2$[rsp]
	vmovss	xmm8, DWORD PTR invSlopeR$1$[rsp]
	vmovss	xmm9, DWORD PTR invSlopeL$1$[rsp]
	mov	rcx, QWORD PTR renderBuff$1$[rsp]
	vxorps	xmm4, xmm4, xmm4
$LN2@drawFlatTo:

; 291  : 
; 292  : 	// note: Y walks downwards
; 293  : 	for (INT drawY = DRAW_Y_START; drawY >= DRAW_Y_END; drawY--) {

	dec	r8d
	mov	DWORD PTR drawY$1$[rsp], r8d
	cmp	r8d, DWORD PTR DRAW_Y_END$1$[rsp]
	jge	$LL4@drawFlatTo
	vmovaps	xmm13, XMMWORD PTR [rsp+224]
	vmovaps	xmm12, XMMWORD PTR [rsp+240]
	vmovaps	xmm11, XMMWORD PTR [rsp+256]
	vmovaps	xmm10, XMMWORD PTR [rsp+272]
	mov	r15, QWORD PTR [rsp+352]
	mov	r14, QWORD PTR [rsp+360]
	mov	r12, QWORD PTR [rsp+368]
	mov	rdi, QWORD PTR [rsp+376]
	mov	rsi, QWORD PTR [rsp+384]
	mov	rbx, QWORD PTR [rsp+432]
$LN10@drawFlatTo:

; 306  : 			// prepare and draw fragment
; 307  : 			_prepareAndDrawFragment(triContext, drawX, drawY);
; 308  : 		}
; 309  : 	}
; 310  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+392]
	vmovaps	xmm6, XMMWORD PTR [r11-56]
	vmovaps	xmm7, XMMWORD PTR [r11-72]
	vmovaps	xmm8, XMMWORD PTR [r11-88]
	vmovaps	xmm9, XMMWORD PTR [r11-104]
	vmovaps	xmm14, XMMWORD PTR [r11-184]
	vmovaps	xmm15, XMMWORD PTR [r11-200]
	mov	rsp, r11
	pop	r13
	pop	rbp
	ret	0
_drawFlatTopTri ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c
;	COMDAT CInternalPipelineRasterizeTri
_TEXT	SEGMENT
drawY$1$ = 48
drawY$1$ = 48
rCol$26 = 52
rCol$27 = 52
LBase$2$ = 56
LBase$2$ = 56
RBase$1$ = 60
LBase$1$ = 60
LBase$1$ = 64
RBase$1$ = 64
flatTopTri$5$ = 80
renderBuff$1$ = 80
LBase$28 = 80
p1$29 = 80
$T5 = 80
p3$30 = 96
$T12 = 96
RBase$31 = 96
$T3 = 96
horzPoint$ = 96
DRAW_Y_END$1$ = 112
invSlopeR$1$ = 112
invSlopeL$1$ = 116
invSlopeL$1$ = 116
invSlopeR$1$ = 120
DRAW_Y_END$1$ = 120
flatTopTri$6$ = 124
DRAW_X_END$1$ = 124
__real@00000000$1$ = 128
renderBuff$1$ = 136
LBase$32 = 136
p2$33 = 136
$T20 = 160
p3$34 = 160
RBase$35 = 160
p3$36 = 176
$T4 = 176
DRAW_X_END$1$ = 192
p2$37 = 200
p1$38 = 200
p1$39 = 216
p2$40 = 216
fragColor$41 = 232
rCol$42 = 232
rCol$43 = 236
fragColor$44 = 236
temp$45 = 240
temp$46 = 240
temp$47 = 240
flatTopTri$ = 240
flatBottomTri$ = 2016
__$ArrayPad$ = 3792
triContext$ = 4032
triangle$ = 4040
CInternalPipelineRasterizeTri PROC			; COMDAT

; 312  : void   CInternalPipelineRasterizeTri(PCIPTriContext triContext, PCIPTriData triangle) {

$LN292:
	push	rbp
	push	rsi
	push	rdi
	push	r13
	lea	rbp, QWORD PTR [rsp-3736]
	sub	rsp, 3992				; 00000f98H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax

; 313  : 	
; 314  : 	// set triContext's triangle to current screen triangle
; 315  : 	triContext->screenTriAndData = triangle;

	mov	QWORD PTR [rcx+32], rdx
	mov	r13, rcx

; 85   : 	if (toEdit->verts[0].y < toEdit->verts[1].y) {

	vmovss	xmm0, DWORD PTR [rdx+1744]
	vcomiss	xmm0, DWORD PTR [rdx+1732]
	jbe	$LN13@CInternalP

; 66   : 	*v1 = *v2;

	vmovsd	xmm0, QWORD PTR [rdx+1740]
	mov	ecx, DWORD PTR [rdx+1736]

; 77   : 	CIPVertOutputList temp = *vil1;

	lea	rdi, QWORD PTR temp$47[rbp-256]

; 65   : 	CVect3F temp = *v1;

	vmovsd	xmm1, QWORD PTR [rdx+1728]

; 66   : 	*v1 = *v2;

	vmovsd	QWORD PTR [rdx+1728], xmm0
	mov	eax, DWORD PTR [rdx+1748]

; 77   : 	CIPVertOutputList temp = *vil1;

	mov	esi, 4

; 66   : 	*v1 = *v2;

	mov	DWORD PTR [rdx+1736], eax

; 67   : 	*v2 = temp;

	vmovsd	QWORD PTR [rdx+1740], xmm1
	mov	DWORD PTR [rdx+1748], ecx

; 77   : 	CIPVertOutputList temp = *vil1;

	mov	rcx, rdx

; 72   : 	*d1 = *d2;

	mov	eax, DWORD PTR [rdx+1768]
	vmovss	xmm0, DWORD PTR [rdx+1764]
	mov	DWORD PTR [rdx+1764], eax

; 88   : 		_swapInputLists(toEdit->vertOutputs + 0, toEdit->vertOutputs + 1);

	lea	rax, QWORD PTR [rdx+576]

; 73   : 	*d2 = temp;

	vmovss	DWORD PTR [rdx+1768], xmm0
	npad	6
$LL267@CInternalP:

; 77   : 	CIPVertOutputList temp = *vil1;

	lea	rdi, QWORD PTR [rdi+128]
	vmovups	ymm0, YMMWORD PTR [rcx]
	vmovups	xmm1, XMMWORD PTR [rcx+112]
	lea	rcx, QWORD PTR [rcx+128]
	vmovups	YMMWORD PTR [rdi-128], ymm0
	vmovups	ymm0, YMMWORD PTR [rcx-96]
	vmovups	YMMWORD PTR [rdi-96], ymm0
	vmovups	ymm0, YMMWORD PTR [rcx-64]
	vmovups	YMMWORD PTR [rdi-64], ymm0
	vmovups	xmm0, XMMWORD PTR [rcx-32]
	vmovups	XMMWORD PTR [rdi-32], xmm0
	vmovups	XMMWORD PTR [rdi-16], xmm1
	sub	rsi, 1
	jne	SHORT $LL267@CInternalP
	vmovups	ymm0, YMMWORD PTR [rcx]
	vmovups	YMMWORD PTR [rdi], ymm0
	vmovups	ymm0, YMMWORD PTR [rcx+32]
	vmovups	YMMWORD PTR [rdi+32], ymm0

; 78   : 	*vil1 = *vil2;

	mov	rdi, rax
	mov	rcx, rdx
	mov	esi, 4
$LL266@CInternalP:
	lea	rcx, QWORD PTR [rcx+128]
	vmovups	xmm0, XMMWORD PTR [rdi]
	lea	rdi, QWORD PTR [rdi+128]
	vmovups	XMMWORD PTR [rcx-128], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi-112]
	vmovups	XMMWORD PTR [rcx-112], xmm1
	vmovups	xmm0, XMMWORD PTR [rdi-96]
	vmovups	XMMWORD PTR [rcx-96], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi-80]
	vmovups	XMMWORD PTR [rcx-80], xmm1
	vmovups	xmm0, XMMWORD PTR [rdi-64]
	vmovups	XMMWORD PTR [rcx-64], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi-48]
	vmovups	XMMWORD PTR [rcx-48], xmm1
	vmovups	xmm0, XMMWORD PTR [rdi-32]
	vmovups	XMMWORD PTR [rcx-32], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi-16]
	vmovups	XMMWORD PTR [rcx-16], xmm1
	sub	rsi, 1
	jne	SHORT $LL266@CInternalP
	vmovups	xmm0, XMMWORD PTR [rdi]
	vmovups	XMMWORD PTR [rcx], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi+16]
	vmovups	XMMWORD PTR [rcx+16], xmm1
	vmovups	xmm0, XMMWORD PTR [rdi+32]
	vmovups	XMMWORD PTR [rcx+32], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi+48]
	vmovups	XMMWORD PTR [rcx+48], xmm1

; 79   : 	*vil2 = temp;

	lea	rcx, QWORD PTR temp$47[rbp-256]
	lea	edi, QWORD PTR [rsi+4]
	npad	14
$LL265@CInternalP:
	lea	rax, QWORD PTR [rax+128]
	vmovups	ymm0, YMMWORD PTR [rcx]
	vmovups	xmm1, XMMWORD PTR [rcx+112]
	lea	rcx, QWORD PTR [rcx+128]
	vmovups	YMMWORD PTR [rax-128], ymm0
	vmovups	ymm0, YMMWORD PTR [rcx-96]
	vmovups	YMMWORD PTR [rax-96], ymm0
	vmovups	ymm0, YMMWORD PTR [rcx-64]
	vmovups	YMMWORD PTR [rax-64], ymm0
	vmovups	xmm0, XMMWORD PTR [rcx-32]
	vmovups	XMMWORD PTR [rax-32], xmm0
	vmovups	XMMWORD PTR [rax-16], xmm1
	sub	rdi, 1
	jne	SHORT $LL265@CInternalP
	vmovups	ymm0, YMMWORD PTR [rcx]
	vmovups	YMMWORD PTR [rax], ymm0
	vmovups	ymm0, YMMWORD PTR [rcx+32]
	vmovups	YMMWORD PTR [rax+32], ymm0
$LN13@CInternalP:

; 91   : 	if (toEdit->verts[0].y < toEdit->verts[2].y) {

	vmovss	xmm0, DWORD PTR [rdx+1756]
	vcomiss	xmm0, DWORD PTR [rdx+1732]
	jbe	$LN19@CInternalP

; 66   : 	*v1 = *v2;

	vmovsd	xmm0, QWORD PTR [rdx+1752]
	mov	ecx, DWORD PTR [rdx+1736]

; 77   : 	CIPVertOutputList temp = *vil1;

	lea	rdi, QWORD PTR temp$46[rbp-256]

; 65   : 	CVect3F temp = *v1;

	vmovsd	xmm1, QWORD PTR [rdx+1728]

; 66   : 	*v1 = *v2;

	vmovsd	QWORD PTR [rdx+1728], xmm0
	mov	eax, DWORD PTR [rdx+1760]

; 77   : 	CIPVertOutputList temp = *vil1;

	mov	esi, 4

; 66   : 	*v1 = *v2;

	mov	DWORD PTR [rdx+1736], eax

; 67   : 	*v2 = temp;

	vmovsd	QWORD PTR [rdx+1752], xmm1
	mov	DWORD PTR [rdx+1760], ecx

; 77   : 	CIPVertOutputList temp = *vil1;

	mov	rcx, rdx

; 72   : 	*d1 = *d2;

	mov	eax, DWORD PTR [rdx+1772]
	vmovss	xmm0, DWORD PTR [rdx+1764]
	mov	DWORD PTR [rdx+1764], eax

; 94   : 		_swapInputLists(toEdit->vertOutputs + 0, toEdit->vertOutputs + 2);

	lea	rax, QWORD PTR [rdx+1152]

; 73   : 	*d2 = temp;

	vmovss	DWORD PTR [rdx+1772], xmm0
	npad	12
$LL264@CInternalP:

; 77   : 	CIPVertOutputList temp = *vil1;

	lea	rdi, QWORD PTR [rdi+128]
	vmovups	ymm0, YMMWORD PTR [rcx]
	vmovups	xmm1, XMMWORD PTR [rcx+112]
	lea	rcx, QWORD PTR [rcx+128]
	vmovups	YMMWORD PTR [rdi-128], ymm0
	vmovups	ymm0, YMMWORD PTR [rcx-96]
	vmovups	YMMWORD PTR [rdi-96], ymm0
	vmovups	ymm0, YMMWORD PTR [rcx-64]
	vmovups	YMMWORD PTR [rdi-64], ymm0
	vmovups	xmm0, XMMWORD PTR [rcx-32]
	vmovups	XMMWORD PTR [rdi-32], xmm0
	vmovups	XMMWORD PTR [rdi-16], xmm1
	sub	rsi, 1
	jne	SHORT $LL264@CInternalP
	vmovups	ymm0, YMMWORD PTR [rcx]
	vmovups	YMMWORD PTR [rdi], ymm0
	vmovups	ymm0, YMMWORD PTR [rcx+32]
	vmovups	YMMWORD PTR [rdi+32], ymm0

; 78   : 	*vil1 = *vil2;

	mov	rdi, rax
	mov	rcx, rdx
	mov	esi, 4
$LL263@CInternalP:
	lea	rcx, QWORD PTR [rcx+128]
	vmovups	xmm0, XMMWORD PTR [rdi]
	lea	rdi, QWORD PTR [rdi+128]
	vmovups	XMMWORD PTR [rcx-128], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi-112]
	vmovups	XMMWORD PTR [rcx-112], xmm1
	vmovups	xmm0, XMMWORD PTR [rdi-96]
	vmovups	XMMWORD PTR [rcx-96], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi-80]
	vmovups	XMMWORD PTR [rcx-80], xmm1
	vmovups	xmm0, XMMWORD PTR [rdi-64]
	vmovups	XMMWORD PTR [rcx-64], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi-48]
	vmovups	XMMWORD PTR [rcx-48], xmm1
	vmovups	xmm0, XMMWORD PTR [rdi-32]
	vmovups	XMMWORD PTR [rcx-32], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi-16]
	vmovups	XMMWORD PTR [rcx-16], xmm1
	sub	rsi, 1
	jne	SHORT $LL263@CInternalP
	vmovups	xmm0, XMMWORD PTR [rdi]
	vmovups	XMMWORD PTR [rcx], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi+16]
	vmovups	XMMWORD PTR [rcx+16], xmm1
	vmovups	xmm0, XMMWORD PTR [rdi+32]
	vmovups	XMMWORD PTR [rcx+32], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi+48]
	vmovups	XMMWORD PTR [rcx+48], xmm1

; 79   : 	*vil2 = temp;

	lea	rcx, QWORD PTR temp$46[rbp-256]
	lea	edi, QWORD PTR [rsi+4]
	npad	14
$LL262@CInternalP:
	lea	rax, QWORD PTR [rax+128]
	vmovups	ymm0, YMMWORD PTR [rcx]
	vmovups	xmm1, XMMWORD PTR [rcx+112]
	lea	rcx, QWORD PTR [rcx+128]
	vmovups	YMMWORD PTR [rax-128], ymm0
	vmovups	ymm0, YMMWORD PTR [rcx-96]
	vmovups	YMMWORD PTR [rax-96], ymm0
	vmovups	ymm0, YMMWORD PTR [rcx-64]
	vmovups	YMMWORD PTR [rax-64], ymm0
	vmovups	xmm0, XMMWORD PTR [rcx-32]
	vmovups	XMMWORD PTR [rax-32], xmm0
	vmovups	XMMWORD PTR [rax-16], xmm1
	sub	rdi, 1
	jne	SHORT $LL262@CInternalP
	vmovups	ymm0, YMMWORD PTR [rcx]
	vmovups	YMMWORD PTR [rax], ymm0
	vmovups	ymm0, YMMWORD PTR [rcx+32]
	vmovups	YMMWORD PTR [rax+32], ymm0
$LN19@CInternalP:

; 97   : 	if (toEdit->verts[1].y < toEdit->verts[2].y) {

	vmovss	xmm0, DWORD PTR [rdx+1756]
	vcomiss	xmm0, DWORD PTR [rdx+1744]
	jbe	$LN25@CInternalP

; 66   : 	*v1 = *v2;

	vmovsd	xmm0, QWORD PTR [rdx+1752]
	mov	ecx, DWORD PTR [rdx+1748]

; 77   : 	CIPVertOutputList temp = *vil1;

	lea	rsi, QWORD PTR temp$45[rbp-256]

; 65   : 	CVect3F temp = *v1;

	vmovsd	xmm1, QWORD PTR [rdx+1740]

; 66   : 	*v1 = *v2;

	vmovsd	QWORD PTR [rdx+1740], xmm0
	mov	eax, DWORD PTR [rdx+1760]

; 77   : 	CIPVertOutputList temp = *vil1;

	mov	r8d, 4

; 66   : 	*v1 = *v2;

	mov	DWORD PTR [rdx+1748], eax

; 67   : 	*v2 = temp;

	vmovsd	QWORD PTR [rdx+1752], xmm1
	mov	DWORD PTR [rdx+1760], ecx

; 100  : 		_swapInputLists(toEdit->vertOutputs + 1, toEdit->vertOutputs + 2);

	lea	rcx, QWORD PTR [rdx+576]

; 72   : 	*d1 = *d2;

	mov	eax, DWORD PTR [rdx+1772]

; 77   : 	CIPVertOutputList temp = *vil1;

	mov	rdi, rcx

; 71   : 	FLOAT temp = *d1;

	vmovss	xmm0, DWORD PTR [rdx+1768]

; 72   : 	*d1 = *d2;

	mov	DWORD PTR [rdx+1768], eax

; 100  : 		_swapInputLists(toEdit->vertOutputs + 1, toEdit->vertOutputs + 2);

	lea	rax, QWORD PTR [rdx+1152]

; 73   : 	*d2 = temp;

	vmovss	DWORD PTR [rdx+1772], xmm0
	npad	4
$LL261@CInternalP:

; 77   : 	CIPVertOutputList temp = *vil1;

	lea	rsi, QWORD PTR [rsi+128]
	vmovups	ymm0, YMMWORD PTR [rdi]
	vmovups	xmm1, XMMWORD PTR [rdi+112]
	lea	rdi, QWORD PTR [rdi+128]
	vmovups	YMMWORD PTR [rsi-128], ymm0
	vmovups	ymm0, YMMWORD PTR [rdi-96]
	vmovups	YMMWORD PTR [rsi-96], ymm0
	vmovups	ymm0, YMMWORD PTR [rdi-64]
	vmovups	YMMWORD PTR [rsi-64], ymm0
	vmovups	xmm0, XMMWORD PTR [rdi-32]
	vmovups	XMMWORD PTR [rsi-32], xmm0
	vmovups	XMMWORD PTR [rsi-16], xmm1
	sub	r8, 1
	jne	SHORT $LL261@CInternalP
	vmovups	ymm0, YMMWORD PTR [rdi]
	vmovups	YMMWORD PTR [rsi], ymm0
	vmovups	ymm0, YMMWORD PTR [rdi+32]
	vmovups	YMMWORD PTR [rsi+32], ymm0

; 78   : 	*vil1 = *vil2;

	lea	esi, QWORD PTR [r8+4]
	mov	rdi, rax
	npad	2
$LL260@CInternalP:
	lea	rcx, QWORD PTR [rcx+128]
	vmovups	xmm0, XMMWORD PTR [rdi]
	lea	rdi, QWORD PTR [rdi+128]
	vmovups	XMMWORD PTR [rcx-128], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi-112]
	vmovups	XMMWORD PTR [rcx-112], xmm1
	vmovups	xmm0, XMMWORD PTR [rdi-96]
	vmovups	XMMWORD PTR [rcx-96], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi-80]
	vmovups	XMMWORD PTR [rcx-80], xmm1
	vmovups	xmm0, XMMWORD PTR [rdi-64]
	vmovups	XMMWORD PTR [rcx-64], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi-48]
	vmovups	XMMWORD PTR [rcx-48], xmm1
	vmovups	xmm0, XMMWORD PTR [rdi-32]
	vmovups	XMMWORD PTR [rcx-32], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi-16]
	vmovups	XMMWORD PTR [rcx-16], xmm1
	sub	rsi, 1
	jne	SHORT $LL260@CInternalP
	vmovups	xmm0, XMMWORD PTR [rdi]
	vmovups	XMMWORD PTR [rcx], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi+16]
	vmovups	XMMWORD PTR [rcx+16], xmm1
	vmovups	xmm0, XMMWORD PTR [rdi+32]
	vmovups	XMMWORD PTR [rcx+32], xmm0
	vmovups	xmm1, XMMWORD PTR [rdi+48]
	vmovups	XMMWORD PTR [rcx+48], xmm1

; 79   : 	*vil2 = temp;

	lea	rcx, QWORD PTR temp$45[rbp-256]
	lea	edi, QWORD PTR [rsi+4]
$LL259@CInternalP:
	lea	rax, QWORD PTR [rax+128]
	vmovups	ymm0, YMMWORD PTR [rcx]
	vmovups	xmm1, XMMWORD PTR [rcx+112]
	lea	rcx, QWORD PTR [rcx+128]
	vmovups	YMMWORD PTR [rax-128], ymm0
	vmovups	ymm0, YMMWORD PTR [rcx-96]
	vmovups	YMMWORD PTR [rax-96], ymm0
	vmovups	ymm0, YMMWORD PTR [rcx-64]
	vmovups	YMMWORD PTR [rax-64], ymm0
	vmovups	xmm0, XMMWORD PTR [rcx-32]
	vmovups	XMMWORD PTR [rax-32], xmm0
	vmovups	XMMWORD PTR [rax-16], xmm1
	sub	rdi, 1
	jne	SHORT $LL259@CInternalP
	vmovups	ymm0, YMMWORD PTR [rcx]
	vmovups	YMMWORD PTR [rax], ymm0
	vmovups	ymm0, YMMWORD PTR [rcx+32]
	vmovups	YMMWORD PTR [rax+32], ymm0
$LN25@CInternalP:

; 316  : 
; 317  : 	// sort triangle vertically
; 318  : 	_sortTriByVerticality(triangle);
; 319  : 
; 320  : 	// now triangle is:
; 321  : 	// p0 -> top
; 322  : 	// p1 -> middle
; 323  : 	// p2 -> bottom
; 324  : 
; 325  : 	// cull if triangle is squashed
; 326  : 	if ((INT)triangle->verts[0].x == (INT)triangle->verts[1].x &&

	vcvttss2si ecx, DWORD PTR [rdx+1728]
	vcvttss2si eax, DWORD PTR [rdx+1740]
	cmp	ecx, eax
	jne	SHORT $LN2@CInternalP
	vcvttss2si eax, DWORD PTR [rdx+1752]
	cmp	ecx, eax
	je	$LN123@CInternalP
$LN2@CInternalP:

; 327  : 		(INT)triangle->verts[0].x == (INT)triangle->verts[2].x) return;
; 328  : 
; 329  : 	// generate point given a horizontal cut of the triangle
; 330  : 	FLOAT invslope =

	vmovss	xmm0, DWORD PTR [rdx+1728]
	vsubss	xmm3, xmm0, DWORD PTR [rdx+1752]

; 331  : 		(triangle->verts[0].x - triangle->verts[2].x) /
; 332  : 		(triangle->verts[0].y - triangle->verts[2].y);
; 333  : 	FLOAT horzPointx =

	vmovss	xmm0, DWORD PTR [rdx+1744]
	vmovss	xmm1, DWORD PTR [rdx+1732]
	vsubss	xmm2, xmm1, DWORD PTR [rdx+1756]
	vsubss	xmm1, xmm0, DWORD PTR [rdx+1756]

; 122  : 	CVect3F p1 = triangle->verts[0];

	mov	eax, DWORD PTR [rdx+1736]

; 336  : 		CMakeVect3F(horzPointx, triangle->verts[1].y, 0);
; 337  : 
; 338  : 	// assign depth
; 339  : 	CVect3F baryWeightings = 
; 340  : 		_generateBarycentricWeights(triangle, horzPoint);
; 341  : 	horzPoint.z = 

	lea	r8, QWORD PTR $T4[rbp-256]
	vmovaps	XMMWORD PTR [rsp+3952], xmm6
	lea	rcx, QWORD PTR $T5[rsp]
	vdivss	xmm4, xmm3, xmm2
	vmulss	xmm2, xmm1, xmm4
	vmovaps	XMMWORD PTR [rsp+3936], xmm7
	vmovaps	XMMWORD PTR [rsp+3920], xmm8
	vmovaps	XMMWORD PTR [rsp+3904], xmm9
	vmovaps	XMMWORD PTR [rsp+3888], xmm10
	vmovaps	XMMWORD PTR [rsp+3872], xmm11

; 123  : 	CVect3F p2 = triangle->verts[1];

	vmovsd	xmm11, QWORD PTR [rdx+1740]
	vmovaps	XMMWORD PTR [rsp+3856], xmm12

; 124  : 	CVect3F p3 = triangle->verts[2];

	vmovsd	xmm12, QWORD PTR [rdx+1752]
	vmovsd	QWORD PTR p3$36[rbp-256], xmm12

; 128  : 	FLOAT invDenom = _fltInv((p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y));

	vmovss	xmm9, DWORD PTR p3$36[rbp-252]
	vsubss	xmm1, xmm12, xmm11
	mov	DWORD PTR p1$29[rsp+8], eax
	mov	eax, DWORD PTR [rdx+1760]
	vmovaps	XMMWORD PTR [rsp+3824], xmm14

; 334  : 		triangle->verts[2].x + (invslope * (triangle->verts[1].y - triangle->verts[2].y));
; 335  : 	CVect3F horzPoint =

	vmovaps	xmm14, xmm0

; 122  : 	CVect3F p1 = triangle->verts[0];

	vmovsd	xmm0, QWORD PTR [rdx+1728]

; 128  : 	FLOAT invDenom = _fltInv((p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y));

	vshufps	xmm10, xmm0, xmm0, 85			; 00000055H
	vmovsd	QWORD PTR p1$29[rsp], xmm0
	vmovss	xmm8, DWORD PTR p1$29[rsp]
	vsubss	xmm0, xmm10, xmm9

; 130  : 	FLOAT dv3y = vert.y - p3.y;

	vsubss	xmm5, xmm14, xmm9
	mov	DWORD PTR p3$36[rbp-248], eax
	vmovaps	XMMWORD PTR [rsp+3808], xmm15

; 331  : 		(triangle->verts[0].x - triangle->verts[2].x) /
; 332  : 		(triangle->verts[0].y - triangle->verts[2].y);
; 333  : 	FLOAT horzPointx =

	vaddss	xmm15, xmm2, DWORD PTR [rdx+1752]

; 128  : 	FLOAT invDenom = _fltInv((p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y));

	vmulss	xmm2, xmm1, xmm0

; 129  : 	FLOAT dv3x = vert.x - p3.x;

	vsubss	xmm4, xmm15, xmm12
	vsubss	xmm1, xmm8, xmm12
	vmovsd	QWORD PTR p2$33[rbp-256], xmm11
	vmovss	xmm6, DWORD PTR p2$33[rbp-252]
	vsubss	xmm0, xmm6, xmm9
	vmulss	xmm1, xmm1, xmm0
	vaddss	xmm3, xmm2, xmm1
	vxorps	xmm2, xmm2, xmm2

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vmovss3	xmm7, xmm2, xmm3

; 131  : 	weights.x = ((p2.y - p3.y) * (dv3x) + (p3.x - p2.x) * (dv3y)) * invDenom;

	vsubss	xmm1, xmm6, xmm9
	vmulss	xmm2, xmm1, xmm4

; 132  : 	weights.y = ((p3.y - p1.y) * (dv3x) + (p1.x - p3.x) * (dv3y)) * invDenom;

	vsubss	xmm1, xmm9, xmm10
	vsubss	xmm0, xmm12, xmm11
	vmulss	xmm3, xmm0, xmm5
	vaddss	xmm0, xmm3, xmm2
	vmulss	xmm3, xmm1, xmm4

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vrcpss	xmm7, xmm7, xmm7

; 131  : 	weights.x = ((p2.y - p3.y) * (dv3x) + (p3.x - p2.x) * (dv3y)) * invDenom;

	vmulss	xmm6, xmm0, xmm7

; 132  : 	weights.y = ((p3.y - p1.y) * (dv3x) + (p1.x - p3.x) * (dv3y)) * invDenom;

	vsubss	xmm0, xmm8, xmm12
	vmulss	xmm2, xmm0, xmm5

; 133  : 	weights.z = 1 - weights.x - weights.y;

	vmovss	xmm0, DWORD PTR __real@3f800000
	vaddss	xmm1, xmm3, xmm2
	vmulss	xmm4, xmm1, xmm7
	vsubss	xmm0, xmm0, xmm6
	vsubss	xmm1, xmm0, xmm4
	vxorps	xmm10, xmm10, xmm10

; 336  : 		CMakeVect3F(horzPointx, triangle->verts[1].y, 0);
; 337  : 
; 338  : 	// assign depth
; 339  : 	CVect3F baryWeightings = 
; 340  : 		_generateBarycentricWeights(triangle, horzPoint);
; 341  : 	horzPoint.z = 

	vunpcklps xmm0, xmm6, xmm4

; 133  : 	weights.z = 1 - weights.x - weights.y;

	vmovss	DWORD PTR $T3[rsp+8], xmm1

; 336  : 		CMakeVect3F(horzPointx, triangle->verts[1].y, 0);
; 337  : 
; 338  : 	// assign depth
; 339  : 	CVect3F baryWeightings = 
; 340  : 		_generateBarycentricWeights(triangle, horzPoint);
; 341  : 	horzPoint.z = 

	mov	eax, DWORD PTR $T3[rsp+8]
	mov	DWORD PTR $T5[rsp+8], eax
	vmovss	DWORD PTR LBase$1$[rsp], xmm15
	vmovss	DWORD PTR LBase$2$[rsp], xmm14
	vmovss	DWORD PTR $T4[rbp-256], xmm15
	vmovss	DWORD PTR $T4[rbp-252], xmm14
	vmovss	DWORD PTR __real@00000000$1$[rbp-256], xmm10
	vmovss	DWORD PTR $T4[rbp-248], xmm10
	vmovsd	QWORD PTR $T5[rsp], xmm0
	vzeroupper
	call	_interpolateDepth

; 342  : 		_interpolateDepth(baryWeightings, triangle, horzPoint);
; 343  : 
; 344  : 	// make both triangles and draw
; 345  : 	CIPTriData flatBottomTri;
; 346  : 	COPY_BYTES(triangle, &flatBottomTri, sizeof(CIPTriData));

	lea	rdi, QWORD PTR flatBottomTri$[rbp-256]
	mov	rsi, rdx
	mov	ecx, 1776				; 000006f0H
	rep movsb
	vmovss	DWORD PTR horzPoint$[rsp+8], xmm0

; 225  : 	if (LBase.x > RBase.x) {

	vmovss	xmm7, DWORD PTR flatBottomTri$[rbp+1484]
	vcomiss	xmm7, xmm15
	vmovsd	xmm0, QWORD PTR flatBottomTri$[rbp+1484]

; 347  : 	flatBottomTri.verts[2] = horzPoint; // bottom is now flat
; 348  : 
; 349  : 	CIPTriData flatTopTri;
; 350  : 	COPY_BYTES(triangle, &flatTopTri, sizeof(CIPTriData));
; 351  : 	flatTopTri.verts[0] = horzPoint; // top is now flat

	vunpcklps xmm1, xmm15, xmm14
	lea	rdi, QWORD PTR flatTopTri$[rbp-256]
	mov	rsi, rdx
	mov	ecx, 1776				; 000006f0H
	rep movsb
	mov	ecx, DWORD PTR horzPoint$[rsp+8]
	mov	DWORD PTR flatTopTri$6$[rsp], ecx

; 222  : 	CVect3F RBase = subTri->verts[2];

	mov	DWORD PTR RBase$35[rbp-248], ecx

; 223  : 
; 224  : 	// swap to maintain left if necessary
; 225  : 	if (LBase.x > RBase.x) {

	vmovss	DWORD PTR RBase$1$[rsp], xmm7

; 347  : 	flatBottomTri.verts[2] = horzPoint; // bottom is now flat
; 348  : 
; 349  : 	CIPTriData flatTopTri;
; 350  : 	COPY_BYTES(triangle, &flatTopTri, sizeof(CIPTriData));
; 351  : 	flatTopTri.verts[0] = horzPoint; // top is now flat

	vmovsd	QWORD PTR flatTopTri$5$[rsp], xmm1
	vmovsd	QWORD PTR flatTopTri$[rbp+1472], xmm1

; 221  : 	CVect3F LBase = subTri->verts[1];

	vmovsd	QWORD PTR LBase$32[rbp-256], xmm0

; 222  : 	CVect3F RBase = subTri->verts[2];

	vmovsd	QWORD PTR RBase$35[rbp-256], xmm1

; 223  : 
; 224  : 	// swap to maintain left if necessary
; 225  : 	if (LBase.x > RBase.x) {

	ja	SHORT $LN54@CInternalP
	vmovss	xmm14, DWORD PTR LBase$32[rbp-252]
	vmovss	xmm15, DWORD PTR LBase$32[rbp-256]
	vmovss	xmm7, DWORD PTR RBase$35[rbp-256]
	vmovss	DWORD PTR LBase$2$[rsp], xmm14
	vmovss	DWORD PTR LBase$1$[rsp], xmm15
	vmovss	DWORD PTR RBase$1$[rsp], xmm7
$LN54@CInternalP:

; 232  : 	FLOAT invSlopeL = (top.x - LBase.x) * invDY;

	vmovss	xmm1, DWORD PTR flatBottomTri$[rbp+1472]
	vmovss	xmm6, DWORD PTR flatBottomTri$[rbp+1476]
	vsubss	xmm0, xmm1, xmm15
	mov	QWORD PTR [rsp+4048], rbx
	mov	QWORD PTR [rsp+3984], r12

; 226  : 		_swapVerts(&LBase, &RBase);
; 227  : 		_swapDepths(subTri->invDepths + 0, subTri->invDepths + 1);
; 228  : 	}
; 229  : 
; 230  : 	// generate inverse slopes
; 231  : 	FLOAT invDY = _fltInv(top.y - LBase.y);

	vsubss	xmm2, xmm6, xmm14

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vrcpss	xmm3, xmm2, xmm2

; 232  : 	FLOAT invSlopeL = (top.x - LBase.x) * invDY;

	vmulss	xmm9, xmm0, xmm3

; 233  : 	FLOAT invSlopeR = (top.x - RBase.x) * invDY;

	vsubss	xmm1, xmm1, xmm7
	mov	QWORD PTR [rsp+3976], r14
	vmulss	xmm8, xmm1, xmm3

; 234  : 
; 235  : 	// on bad values, don't draw
; 236  : 	if (isinf(invSlopeL) || isinf(invSlopeR)) return;

	vmovaps	xmm0, xmm9
	mov	QWORD PTR [rsp+3968], r15

; 232  : 	FLOAT invSlopeL = (top.x - LBase.x) * invDY;

	vmovss	DWORD PTR invSlopeL$1$[rsp], xmm9

; 233  : 	FLOAT invSlopeR = (top.x - RBase.x) * invDY;

	vmovss	DWORD PTR invSlopeR$1$[rsp], xmm8
	vmovaps	XMMWORD PTR [rsp+3840], xmm13

; 234  : 
; 235  : 	// on bad values, don't draw
; 236  : 	if (isinf(invSlopeL) || isinf(invSlopeR)) return;

	call	_fdclass
	cmp	ax, 1
	je	$LN42@CInternalP
	vmovaps	xmm0, xmm8
	call	_fdclass
	cmp	ax, 1
	je	$LN42@CInternalP

; 237  : 
; 238  : 	// walk up from bottom to top
; 239  : 	PCRenderBuffer renderBuff = triContext->renderBuffer;

	mov	rcx, QWORD PTR [r13+648]
	vmaxss	xmm0, xmm10, xmm14

; 240  : 
; 241  : 	const INT DRAW_Y_START = max(0, LBase.y);

	vcvttss2si edi, xmm0
	vxorps	xmm0, xmm0, xmm0

; 242  : 	const INT DRAW_Y_END   = min(renderBuff->height - 1, top.y);

	mov	eax, DWORD PTR [rcx+4]
	dec	eax
	mov	QWORD PTR renderBuff$1$[rbp-256], rcx
	vcvtsi2ss xmm0, xmm0, rax
	vminss	xmm1, xmm0, xmm6
	vcvttss2si eax, xmm1
	mov	DWORD PTR drawY$1$[rsp], edi
	mov	DWORD PTR DRAW_Y_END$1$[rsp], eax

; 243  : 
; 244  : 	for (INT drawY = DRAW_Y_START; drawY <= DRAW_Y_END; drawY++) {

	cmp	edi, eax
	jg	$LN42@CInternalP
	npad	12
$LL36@CInternalP:

; 252  : 			max(0, LBase.x + (invSlopeL * yDist));
; 253  : 		const INT DRAW_X_END =

	mov	eax, DWORD PTR [rcx]
	vxorps	xmm0, xmm0, xmm0

; 245  : 
; 246  : 		// get distance travelled from start Y
; 247  : 		// yDist has the potential to be < 0 due to floating point math, so we clamp it
; 248  : 		FLOAT yDist = max(0.0f, drawY - LBase.y);

	vcvtsi2ss xmm0, xmm0, edi
	vsubss	xmm1, xmm0, xmm14
	vmaxss	xmm3, xmm10, xmm1

; 252  : 			max(0, LBase.x + (invSlopeL * yDist));
; 253  : 		const INT DRAW_X_END =

	dec	eax
	vmulss	xmm0, xmm3, xmm9
	vaddss	xmm2, xmm0, xmm15
	vmaxss	xmm1, xmm10, xmm2
	vxorps	xmm2, xmm2, xmm2

; 249  : 
; 250  : 		// generate start and end X positions
; 251  : 		const INT DRAW_X_START =

	vcvttss2si r12d, xmm1

; 252  : 			max(0, LBase.x + (invSlopeL * yDist));
; 253  : 		const INT DRAW_X_END =

	vcvtsi2ss xmm2, xmm2, rax
	vmulss	xmm0, xmm3, xmm8
	vaddss	xmm1, xmm0, xmm7
	vminss	xmm2, xmm2, xmm1
	vcvttss2si eax, xmm2
	mov	DWORD PTR DRAW_X_END$1$[rbp-256], eax

; 257  : 		for (INT drawX = DRAW_X_START; drawX <= DRAW_X_END; drawX++) {

	cmp	r12d, eax
	jg	$LN34@CInternalP
	vmovss	xmm14, DWORD PTR __real@ba83126f
	vmovss	xmm15, DWORD PTR __real@3f800000
	vxorps	xmm13, xmm13, xmm13
	vcvtsi2ss xmm13, xmm13, edi
	npad	10
$LL39@CInternalP:

; 197  : 	CVect3F bWeights =

	mov	rcx, QWORD PTR [r13+32]

; 198  : 		_generateBarycentricWeights(triContext->screenTriAndData, drawVect);
; 199  : 	drawVect.z = _interpolateDepth(bWeights, triContext->screenTriAndData);
; 200  : 
; 201  : 	// early depth test
; 202  : 	if (CRenderBufferUnsafeDepthTest(triContext->renderBuffer, drawX, drawY, drawVect.z) == FALSE) return;

	mov	rdx, QWORD PTR [r13+648]
	vxorps	xmm4, xmm4, xmm4

; 189  : 		}
; 190  : 	}
; 191  : }
; 192  : 
; 193  : static __forceinline void _prepareAndDrawFragment(PCIPTriContext triContext, INT drawX, INT drawY) {
; 194  : 	// create fragment with interpolated depth
; 195  : 	CVect3F drawVect =

	vcvtsi2ss xmm4, xmm4, r12d

; 124  : 	CVect3F p3 = triangle->verts[2];

	vmovsd	xmm12, QWORD PTR [rcx+1752]
	vmovsd	xmm11, QWORD PTR [rcx+1740]
	vmovsd	xmm0, QWORD PTR [rcx+1728]
	mov	eax, DWORD PTR [rcx+1760]

; 128  : 	FLOAT invDenom = _fltInv((p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y));

	vshufps	xmm10, xmm0, xmm0, 85			; 00000055H
	vmovsd	QWORD PTR p1$38[rbp-256], xmm0
	vmovss	xmm8, DWORD PTR p1$38[rbp-256]
	vsubss	xmm1, xmm12, xmm11

; 129  : 	FLOAT dv3x = vert.x - p3.x;

	vsubss	xmm4, xmm4, xmm12
	vmovsd	QWORD PTR p2$40[rbp-256], xmm11
	vmovss	xmm6, DWORD PTR p2$40[rbp-252]
	vmovsd	QWORD PTR p3$34[rbp-256], xmm12
	vmovss	xmm9, DWORD PTR p3$34[rbp-252]
	vsubss	xmm0, xmm10, xmm9
	vmulss	xmm2, xmm1, xmm0
	vsubss	xmm1, xmm8, xmm12
	vsubss	xmm0, xmm6, xmm9
	vmulss	xmm1, xmm1, xmm0
	vaddss	xmm3, xmm2, xmm1
	vxorps	xmm2, xmm2, xmm2

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vmovss3	xmm7, xmm2, xmm3

; 131  : 	weights.x = ((p2.y - p3.y) * (dv3x) + (p3.x - p2.x) * (dv3y)) * invDenom;

	vsubss	xmm0, xmm12, xmm11
	vsubss	xmm5, xmm13, xmm9
	vmulss	xmm3, xmm0, xmm5
	vsubss	xmm1, xmm6, xmm9
	vmulss	xmm2, xmm1, xmm4
	vaddss	xmm0, xmm3, xmm2

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vrcpss	xmm7, xmm7, xmm7

; 131  : 	weights.x = ((p2.y - p3.y) * (dv3x) + (p3.x - p2.x) * (dv3y)) * invDenom;

	vmulss	xmm11, xmm0, xmm7

; 132  : 	weights.y = ((p3.y - p1.y) * (dv3x) + (p1.x - p3.x) * (dv3y)) * invDenom;

	vsubss	xmm0, xmm8, xmm12
	vmulss	xmm2, xmm0, xmm5
	vsubss	xmm1, xmm9, xmm10
	vmulss	xmm3, xmm1, xmm4
	vaddss	xmm1, xmm3, xmm2

; 144  : 	weights.x *= (triangle->invDepths[0]);

	vmulss	xmm2, xmm11, DWORD PTR [rcx+1764]

; 132  : 	weights.y = ((p3.y - p1.y) * (dv3x) + (p1.x - p3.x) * (dv3y)) * invDenom;

	vmulss	xmm7, xmm1, xmm7

; 133  : 	weights.z = 1 - weights.x - weights.y;

	vsubss	xmm0, xmm15, xmm11
	vsubss	xmm8, xmm0, xmm7

; 146  : 	weights.z *= (triangle->invDepths[2]);

	vmulss	xmm1, xmm8, DWORD PTR [rcx+1772]
	vmulss	xmm0, xmm7, DWORD PTR [rcx+1768]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	mov	ecx, DWORD PTR [rdx+4]
	sub	ecx, edi
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 124  : 	CVect3F p3 = triangle->verts[2];

	mov	DWORD PTR p3$34[rbp-248], eax
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	mov	rax, QWORD PTR [rdx+16]

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	dec	ecx
	imul	ecx, DWORD PTR [rdx]
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 148  : 	return _fltInv(weights.x + weights.y + weights.z);

	vaddss	xmm0, xmm0, xmm2
	vaddss	xmm3, xmm0, xmm1

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vrcpss	xmm4, xmm3, xmm3
	vxorps	xmm2, xmm2, xmm2
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	add	ecx, r12d

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	vmovss	xmm0, DWORD PTR [rax+rcx*4]

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	vsubss	xmm1, xmm0, xmm4
	vcomiss	xmm1, xmm14
	jae	$LN37@CInternalP
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 205  : 	PCIPFragContext fContext = &triContext->fragContext;

	lea	r15, QWORD PTR [r13+40]
	mov	r14d, 4

; 206  : 	fContext->barycentricWeightings = bWeights;

	vmovss	DWORD PTR [r15+596], xmm11
	vmovss	DWORD PTR [r15+600], xmm7
	vmovss	DWORD PTR [r15+604], xmm8

; 207  : 	fContext->fragPos.x = drawX;
; 208  : 	fContext->fragPos.y = drawY;

	mov	DWORD PTR [r15+588], edi
	lea	rdi, QWORD PTR [r15+80]

; 209  : 	fContext->fragPos.depth = drawVect.z;

	vmovss	DWORD PTR [r15+592], xmm4
	mov	DWORD PTR [r15+584], r12d

; 210  : 
; 211  : 	_prepareFragmentInputValues(&fContext->fragInputs, triContext->screenTriAndData, bWeights);

	mov	rsi, QWORD PTR [r13+32]
	mov	rbx, rsi
	sub	rbx, r15

; 154  : 	PCIPVertOutputList fragInputList2 = &triData->vertOutputs[1];

	lea	r10, QWORD PTR [rsi+576]

; 205  : 	PCIPFragContext fContext = &triContext->fragContext;

	sub	r10, r15

; 155  : 	PCIPVertOutputList fragInputList3 = &triData->vertOutputs[2];

	lea	r11, QWORD PTR [rsi+1152]

; 205  : 	PCIPFragContext fContext = &triContext->fragContext;

	sub	r11, r15
	npad	10
$LL79@CInternalP:

; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rbx+rdi-80]
	lea	r9, QWORD PTR [rbx+rdi]
	test	eax, eax
	je	SHORT $LN77@CInternalP

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r8d, r8d
	test	eax, eax
	je	SHORT $LN77@CInternalP
	npad	13
$LL82@CInternalP:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm11, DWORD PTR [rsi+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [r9+r8*4-76]
	vmulss	xmm5, xmm7, DWORD PTR [rsi+1768]
	vmulss	xmm4, xmm8, DWORD PTR [rsi+1772]
	lea	rax, QWORD PTR [rdi+r10]
	vmulss	xmm1, xmm5, DWORD PTR [rax+r8*4-76]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [rdi+r8*4]
	vmulss	xmm1, xmm4, DWORD PTR [rcx+r11-76]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm5, xmm6
	vaddss	xmm2, xmm0, xmm4
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [rdi+r8*4-68], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [r9-80]
	inc	r8d
	mov	DWORD PTR [rdi-72], eax
	cmp	r8d, DWORD PTR [r9-80]
	jb	SHORT $LL82@CInternalP
$LN77@CInternalP:

; 159  : 		// get frag inputs
; 160  : 		PCIPVertOutput vertOutput1 = fragInputList1->outputs + inputID;
; 161  : 		PCIPVertOutput vertOutput2 = fragInputList2->outputs + inputID;
; 162  : 		PCIPVertOutput vertOutput3 = fragInputList3->outputs + inputID;
; 163  : 		PCIPVertOutput outVertOutput = inOutVertList->outputs + inputID;
; 164  : 
; 165  : 		// if componentcount is 0, skip
; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rbx+rdi-44]
	lea	r9, QWORD PTR [rbx+rdi]
	test	eax, eax
	je	SHORT $LN211@CInternalP

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r8d, r8d
	test	eax, eax
	je	SHORT $LN211@CInternalP
	npad	13
$LL210@CInternalP:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm11, DWORD PTR [rsi+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [r9+r8*4-40]
	vmulss	xmm5, xmm7, DWORD PTR [rsi+1768]
	vmulss	xmm4, xmm8, DWORD PTR [rsi+1772]
	lea	rax, QWORD PTR [rdi+r10]
	vmulss	xmm1, xmm5, DWORD PTR [rax+r8*4-40]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [rdi+r8*4]
	vmulss	xmm1, xmm4, DWORD PTR [rcx+r11-40]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm5, xmm6
	vaddss	xmm2, xmm0, xmm4
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [rdi+r8*4-32], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [r9-44]
	inc	r8d
	mov	DWORD PTR [rdi-36], eax
	cmp	r8d, DWORD PTR [r9-44]
	jb	SHORT $LL210@CInternalP
$LN211@CInternalP:

; 159  : 		// get frag inputs
; 160  : 		PCIPVertOutput vertOutput1 = fragInputList1->outputs + inputID;
; 161  : 		PCIPVertOutput vertOutput2 = fragInputList2->outputs + inputID;
; 162  : 		PCIPVertOutput vertOutput3 = fragInputList3->outputs + inputID;
; 163  : 		PCIPVertOutput outVertOutput = inOutVertList->outputs + inputID;
; 164  : 
; 165  : 		// if componentcount is 0, skip
; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rbx+rdi-8]
	lea	r9, QWORD PTR [rbx+rdi]
	test	eax, eax
	je	SHORT $LN214@CInternalP

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r8d, r8d
	test	eax, eax
	je	SHORT $LN214@CInternalP
	npad	13
$LL213@CInternalP:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm11, DWORD PTR [rsi+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [r9+r8*4-4]
	vmulss	xmm5, xmm7, DWORD PTR [rsi+1768]
	vmulss	xmm4, xmm8, DWORD PTR [rsi+1772]
	lea	rax, QWORD PTR [rdi+r10]
	vmulss	xmm1, xmm5, DWORD PTR [rax+r8*4-4]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [rdi+r8*4]
	vmulss	xmm1, xmm4, DWORD PTR [rcx+r11-4]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm5, xmm6
	vaddss	xmm2, xmm0, xmm4
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [rdi+r8*4+4], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [r9-8]
	inc	r8d
	mov	DWORD PTR [rdi], eax
	cmp	r8d, DWORD PTR [r9-8]
	jb	SHORT $LL213@CInternalP
$LN214@CInternalP:

; 159  : 		// get frag inputs
; 160  : 		PCIPVertOutput vertOutput1 = fragInputList1->outputs + inputID;
; 161  : 		PCIPVertOutput vertOutput2 = fragInputList2->outputs + inputID;
; 162  : 		PCIPVertOutput vertOutput3 = fragInputList3->outputs + inputID;
; 163  : 		PCIPVertOutput outVertOutput = inOutVertList->outputs + inputID;
; 164  : 
; 165  : 		// if componentcount is 0, skip
; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rbx+rdi+28]
	lea	r9, QWORD PTR [rbx+rdi]
	test	eax, eax
	je	SHORT $LN217@CInternalP

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r8d, r8d
	test	eax, eax
	je	SHORT $LN217@CInternalP
	npad	14
$LL216@CInternalP:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm11, DWORD PTR [rsi+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [r9+r8*4+32]
	vmulss	xmm5, xmm7, DWORD PTR [rsi+1768]
	vmulss	xmm4, xmm8, DWORD PTR [rsi+1772]
	lea	rax, QWORD PTR [rdi+r10]
	vmulss	xmm1, xmm5, DWORD PTR [rax+r8*4+32]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [rdi+r8*4]
	vmulss	xmm1, xmm4, DWORD PTR [rcx+r11+32]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm5, xmm6
	vaddss	xmm2, xmm0, xmm4
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [rdi+r8*4+40], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [r9+28]
	inc	r8d
	mov	DWORD PTR [rdi+36], eax
	cmp	r8d, DWORD PTR [r9+28]
	jb	SHORT $LL216@CInternalP
$LN217@CInternalP:

; 156  : 
; 157  : 	// interpolate all input values based on fragment
; 158  : 	for (UINT32 inputID = 0; inputID < CSM_CLASS_MAX_VERTEX_DATA; inputID++) {

	add	rdi, 144				; 00000090H
	sub	r14, 1
	jne	$LL79@CInternalP

; 18   : 	PCRenderBuffer renderBuffer = triContext->renderBuffer;

	mov	rsi, QWORD PTR [r13+648]

; 19   : 	// generate frag position
; 20   : 	INT fragPosX = triContext->fragContext.fragPos.x;
; 21   : 	INT fragPosY = triContext->fragContext.fragPos.y;

	mov	r14d, DWORD PTR [r13+628]
	mov	ebx, DWORD PTR [r13+624]

; 30   : 	if (triContext->material != NULL) {

	mov	r10, QWORD PTR [r13+656]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 157  : 	colorOut[0] = _findColorPtr(handle, x, y)[0];

	mov	ecx, DWORD PTR [rsi+4]
	mov	rax, QWORD PTR [rsi+8]
	sub	ecx, r14d

; 63   : 	return b->color + (x + ((b->height - y - 1) * b->width));

	dec	ecx
; File C:\Bailey\Programming\Caesium\csm.c

; 57   : 	rCol.g = g;

	mov	WORD PTR rCol$42[rbp-255], 0
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 63   : 	return b->color + (x + ((b->height - y - 1) * b->width));

	imul	ecx, DWORD PTR [rsi]
; File C:\Bailey\Programming\Caesium\csm.c

; 58   : 	rCol.b = b;

	mov	BYTE PTR rCol$42[rbp-256], 0

; 59   : 	rCol.a = a;

	mov	BYTE PTR rCol$42[rbp-253], 0
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 63   : 	return b->color + (x + ((b->height - y - 1) * b->width));

	add	ecx, ebx

; 157  : 	colorOut[0] = _findColorPtr(handle, x, y)[0];

	mov	edi, DWORD PTR [rax+rcx*4]
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 29   : 	CColor fragColor = CMakeColor4(0, 0, 0, 0);

	mov	eax, DWORD PTR rCol$42[rbp-256]
	mov	DWORD PTR fragColor$44[rbp-256], eax

; 30   : 	if (triContext->material != NULL) {

	test	r10, r10
	je	SHORT $LN86@CInternalP

; 31   : 		// apply fragment shader
; 32   : 		BOOL keepFrag = triContext->material->fragmentShader(

	mov	eax, DWORD PTR [r13+632]
	lea	r9, QWORD PTR $T12[rsp]
	vmovsd	xmm0, QWORD PTR [r13+624]
	mov	r8d, DWORD PTR [r13+16]
	mov	rcx, r15
	mov	edx, DWORD PTR [r13+20]
	mov	DWORD PTR $T12[rsp+8], eax
	lea	rax, QWORD PTR fragColor$44[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	vmovsd	QWORD PTR $T12[rsp], xmm0
	call	QWORD PTR [r10+16]

; 33   : 			&triContext->fragContext,
; 34   : 			triContext->triangleID,
; 35   : 			triContext->instanceID,
; 36   : 			triContext->fragContext.fragPos,
; 37   : 			&fragColor
; 38   : 		);
; 39   : 		if (keepFrag == FALSE) return; // cull if needed

	test	eax, eax
	je	$LN275@CInternalP

; 40   : 	}

	mov	eax, DWORD PTR fragColor$44[rbp-256]
	jmp	SHORT $LN87@CInternalP
$LN86@CInternalP:
; File C:\Bailey\Programming\Caesium\csm.c

; 48   : 	rCol.g = g;

	mov	WORD PTR rCol$27[rsp+1], 65280		; 0000ff00H

; 49   : 	rCol.b = b;

	mov	BYTE PTR rCol$27[rsp], 255		; 000000ffH

; 50   : 	rCol.a = 255;

	mov	BYTE PTR rCol$27[rsp+3], 255		; 000000ffH
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 44   : 		fragColor = CMakeColor3(255, 0, 255);

	mov	eax, DWORD PTR rCol$27[rsp]
	mov	DWORD PTR fragColor$44[rbp-256], eax
$LN87@CInternalP:

; 45   : 	}
; 46   : 
; 47   : 	// if color alpha is 0, cull
; 48   : 	if (fragColor.a == 0) return;

	mov	ecx, eax
	shr	ecx, 24
	test	cl, cl
	je	SHORT $LN275@CInternalP

; 49   : 
; 50   : 	// apply alpha blend (if needed)
; 51   : 	if (fragColor.a != 255)

	cmp	cl, 255					; 000000ffH
	je	SHORT $LN90@CInternalP

; 52   : 		fragColor = CFragmentBlendColor(belowColor, fragColor);

	mov	edx, eax
	mov	ecx, edi
	call	CFragmentBlendColor
	mov	DWORD PTR fragColor$44[rbp-256], eax
$LN90@CInternalP:
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	mov	edx, DWORD PTR [rsi+4]

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	mov	rcx, QWORD PTR [rsi+16]

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	sub	edx, r14d
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 55   : 	CRenderBufferUnsafeSetFragment(

	vmovss	xmm2, DWORD PTR [r13+632]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	mov	edi, DWORD PTR drawY$1$[rsp]

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	dec	edx
	imul	edx, DWORD PTR [rsi]
	add	edx, ebx

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	vmovss	xmm0, DWORD PTR [rcx+rdx*4]

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	vsubss	xmm1, xmm0, xmm2
	vcomiss	xmm1, xmm14
	jae	SHORT $LN37@CInternalP

; 167  : 	_findColorPtr(handle, x, y)[0] = color;

	mov	rcx, QWORD PTR [rsi+8]
	mov	DWORD PTR [rcx+rdx*4], eax

; 168  : 	_findDepthPtr(handle, x, y)[0] = depth;

	mov	ecx, DWORD PTR [rsi+4]
	mov	rax, QWORD PTR [rsi+16]
	sub	ecx, r14d

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	dec	ecx
	imul	ecx, DWORD PTR [rsi]
	add	ecx, ebx

; 168  : 	_findDepthPtr(handle, x, y)[0] = depth;

	vmovss	DWORD PTR [rax+rcx*4], xmm2

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	jmp	SHORT $LN37@CInternalP
$LN275@CInternalP:
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 257  : 		for (INT drawX = DRAW_X_START; drawX <= DRAW_X_END; drawX++) {

	mov	edi, DWORD PTR drawY$1$[rsp]
$LN37@CInternalP:
	inc	r12d
	cmp	r12d, DWORD PTR DRAW_X_END$1$[rbp-256]
	jle	$LL39@CInternalP
	vmovss	xmm14, DWORD PTR LBase$2$[rsp]
	vmovss	xmm15, DWORD PTR LBase$1$[rsp]
	vmovss	xmm7, DWORD PTR RBase$1$[rsp]
	vmovss	xmm8, DWORD PTR invSlopeR$1$[rsp]
	vmovss	xmm9, DWORD PTR invSlopeL$1$[rsp]
	vmovss	xmm10, DWORD PTR __real@00000000$1$[rbp-256]
	mov	rcx, QWORD PTR renderBuff$1$[rbp-256]
$LN34@CInternalP:

; 243  : 
; 244  : 	for (INT drawY = DRAW_Y_START; drawY <= DRAW_Y_END; drawY++) {

	inc	edi
	mov	DWORD PTR drawY$1$[rsp], edi
	cmp	edi, DWORD PTR DRAW_Y_END$1$[rsp]
	jle	$LL36@CInternalP
$LN42@CInternalP:

; 267  : 	CVect3F LBase  = subTri->verts[0];

	vmovsd	xmm0, QWORD PTR flatTopTri$5$[rsp]

; 268  : 	CVect3F RBase  = subTri->verts[1];
; 269  : 	CVect3F bottom = subTri->verts[2];
; 270  : 
; 271  : 	// swap to maintain left if necessary
; 272  : 	if (LBase.x > RBase.x) {

	vmovss	xmm15, DWORD PTR flatTopTri$[rbp+1472]
	vmovss	xmm14, DWORD PTR flatTopTri$[rbp+1484]
	vcomiss	xmm15, xmm14
	vmovsd	QWORD PTR LBase$28[rsp], xmm0
	vmovsd	xmm0, QWORD PTR flatTopTri$[rbp+1484]
	vmovsd	QWORD PTR RBase$31[rsp], xmm0
	vmovss	DWORD PTR RBase$1$[rsp], xmm15
	vmovss	DWORD PTR LBase$1$[rsp], xmm14
	jbe	SHORT $LN269@CInternalP

; 66   : 	*v1 = *v2;

	vmovss	xmm7, DWORD PTR flatTopTri$[rbp+1488]

; 272  : 	if (LBase.x > RBase.x) {

	jmp	SHORT $LN290@CInternalP
$LN269@CInternalP:
	vmovss	xmm14, DWORD PTR LBase$28[rsp]
	vmovss	xmm15, DWORD PTR RBase$31[rsp]
	vmovss	xmm7, DWORD PTR LBase$28[rsp+4]
	vmovss	DWORD PTR LBase$1$[rsp], xmm14
	vmovss	DWORD PTR RBase$1$[rsp], xmm15
$LN290@CInternalP:

; 273  : 		_swapVerts(&LBase, &RBase);
; 274  : 		_swapDepths(subTri->invDepths + 0, subTri->invDepths + 1);
; 275  : 	}
; 276  : 
; 277  : 	// generate inverse slopes
; 278  : 	FLOAT invDY = _fltInv(bottom.y - LBase.y);
; 279  : 	FLOAT invSlopeL = (bottom.x - LBase.x) * invDY;

	vmovss	xmm1, DWORD PTR flatTopTri$[rbp+1496]
	vmovss	xmm6, DWORD PTR flatTopTri$[rbp+1500]
	vsubss	xmm0, xmm1, xmm14
	vsubss	xmm2, xmm6, xmm7

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vrcpss	xmm3, xmm2, xmm2

; 279  : 	FLOAT invSlopeL = (bottom.x - LBase.x) * invDY;

	vmulss	xmm9, xmm0, xmm3

; 280  : 	FLOAT invSlopeR = (bottom.x - RBase.x) * invDY;

	vsubss	xmm1, xmm1, xmm15
	vmulss	xmm8, xmm1, xmm3

; 281  : 
; 282  : 	// on bad values, don't draw
; 283  : 	if (isinf(invSlopeL) || isinf(invSlopeR)) return;

	vmovaps	xmm0, xmm9
	vmovss	DWORD PTR LBase$2$[rsp], xmm7
	vmovss	DWORD PTR invSlopeL$1$[rsp], xmm9
	vmovss	DWORD PTR invSlopeR$1$[rsp], xmm8
	call	_fdclass
	cmp	ax, 1
	je	$LN289@CInternalP
	vmovaps	xmm0, xmm8
	call	_fdclass
	cmp	ax, 1
	je	$LN289@CInternalP

; 284  : 
; 285  : 	// walk down from top to bottom
; 286  : 	PCRenderBuffer renderBuff = triContext->renderBuffer;

	mov	rcx, QWORD PTR [r13+648]
	vxorps	xmm0, xmm0, xmm0
	mov	QWORD PTR renderBuff$1$[rsp], rcx

; 287  : 
; 288  : 	// calculate top and bottom
; 289  : 	const INT DRAW_Y_START = min(renderBuff->height - 1, LBase.y);

	mov	eax, DWORD PTR [rcx+4]
	dec	eax
	vcvtsi2ss xmm0, xmm0, rax
	vminss	xmm1, xmm0, xmm7
	vcvttss2si edi, xmm1
	vmaxss	xmm0, xmm10, xmm6

; 290  : 	const INT DRAW_Y_END = max(0, bottom.y);

	vcvttss2si eax, xmm0
	mov	DWORD PTR drawY$1$[rsp], edi
	mov	DWORD PTR DRAW_Y_END$1$[rsp], eax

; 291  : 
; 292  : 	// note: Y walks downwards
; 293  : 	for (INT drawY = DRAW_Y_START; drawY >= DRAW_Y_END; drawY--) {

	cmp	edi, eax
	jl	$LN289@CInternalP
	npad	8
$LL117@CInternalP:

; 297  : 
; 298  : 		// generate start and end X positions
; 299  : 		const INT DRAW_X_START =
; 300  : 			max(0, LBase.x - (invSlopeL * yDist));
; 301  : 		const INT DRAW_X_END =

	mov	eax, DWORD PTR [rcx]
	vxorps	xmm0, xmm0, xmm0

; 294  : 
; 295  : 		// get distance travelled from start Y
; 296  : 		FLOAT yDist = LBase.y - drawY;

	vcvtsi2ss xmm0, xmm0, edi
	vsubss	xmm3, xmm7, xmm0

; 297  : 
; 298  : 		// generate start and end X positions
; 299  : 		const INT DRAW_X_START =
; 300  : 			max(0, LBase.x - (invSlopeL * yDist));
; 301  : 		const INT DRAW_X_END =

	dec	eax
	vmulss	xmm1, xmm3, xmm9
	vsubss	xmm2, xmm14, xmm1
	vmaxss	xmm0, xmm10, xmm2
	vcvttss2si r12d, xmm0
	vxorps	xmm2, xmm2, xmm2
	vcvtsi2ss xmm2, xmm2, rax
	vmulss	xmm0, xmm3, xmm8
	vsubss	xmm1, xmm15, xmm0
	vminss	xmm2, xmm2, xmm1
	vcvttss2si eax, xmm2
	mov	DWORD PTR DRAW_X_END$1$[rsp], eax

; 305  : 		for (INT drawX = DRAW_X_START; drawX <= DRAW_X_END; drawX++) {

	cmp	r12d, eax
	jg	$LN115@CInternalP
	vmovss	xmm14, DWORD PTR __real@ba83126f
	vmovss	xmm15, DWORD PTR __real@3f800000
	vxorps	xmm13, xmm13, xmm13
	vcvtsi2ss xmm13, xmm13, edi
$LL120@CInternalP:

; 197  : 	CVect3F bWeights =

	mov	rcx, QWORD PTR [r13+32]

; 198  : 		_generateBarycentricWeights(triContext->screenTriAndData, drawVect);
; 199  : 	drawVect.z = _interpolateDepth(bWeights, triContext->screenTriAndData);
; 200  : 
; 201  : 	// early depth test
; 202  : 	if (CRenderBufferUnsafeDepthTest(triContext->renderBuffer, drawX, drawY, drawVect.z) == FALSE) return;

	mov	rdx, QWORD PTR [r13+648]
	vxorps	xmm4, xmm4, xmm4

; 189  : 		}
; 190  : 	}
; 191  : }
; 192  : 
; 193  : static __forceinline void _prepareAndDrawFragment(PCIPTriContext triContext, INT drawX, INT drawY) {
; 194  : 	// create fragment with interpolated depth
; 195  : 	CVect3F drawVect =

	vcvtsi2ss xmm4, xmm4, r12d

; 124  : 	CVect3F p3 = triangle->verts[2];

	vmovsd	xmm12, QWORD PTR [rcx+1752]
	vmovsd	xmm11, QWORD PTR [rcx+1740]
	vmovsd	xmm0, QWORD PTR [rcx+1728]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	mov	rax, QWORD PTR [rdx+16]
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 128  : 	FLOAT invDenom = _fltInv((p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y));

	vshufps	xmm10, xmm0, xmm0, 85			; 00000055H
	vmovsd	QWORD PTR p1$39[rbp-256], xmm0
	vmovss	xmm8, DWORD PTR p1$39[rbp-256]
	vsubss	xmm1, xmm12, xmm11

; 129  : 	FLOAT dv3x = vert.x - p3.x;

	vsubss	xmm4, xmm4, xmm12
	vmovsd	QWORD PTR p2$37[rbp-256], xmm11
	vmovss	xmm6, DWORD PTR p2$37[rbp-252]
	vmovsd	QWORD PTR p3$30[rsp], xmm12
	vmovss	xmm9, DWORD PTR p3$30[rsp+4]
	vsubss	xmm0, xmm10, xmm9
	vmulss	xmm2, xmm1, xmm0
	vsubss	xmm1, xmm8, xmm12
	vsubss	xmm0, xmm6, xmm9
	vmulss	xmm1, xmm1, xmm0
	vaddss	xmm3, xmm2, xmm1
	vxorps	xmm2, xmm2, xmm2

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vmovss3	xmm7, xmm2, xmm3

; 131  : 	weights.x = ((p2.y - p3.y) * (dv3x) + (p3.x - p2.x) * (dv3y)) * invDenom;

	vsubss	xmm0, xmm12, xmm11
	vsubss	xmm5, xmm13, xmm9
	vmulss	xmm3, xmm0, xmm5
	vsubss	xmm1, xmm6, xmm9
	vmulss	xmm2, xmm1, xmm4
	vaddss	xmm0, xmm3, xmm2

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vrcpss	xmm7, xmm7, xmm7

; 131  : 	weights.x = ((p2.y - p3.y) * (dv3x) + (p3.x - p2.x) * (dv3y)) * invDenom;

	vmulss	xmm11, xmm0, xmm7

; 132  : 	weights.y = ((p3.y - p1.y) * (dv3x) + (p1.x - p3.x) * (dv3y)) * invDenom;

	vsubss	xmm0, xmm8, xmm12
	vmulss	xmm2, xmm0, xmm5
	vsubss	xmm1, xmm9, xmm10
	vmulss	xmm3, xmm1, xmm4
	vaddss	xmm1, xmm3, xmm2

; 144  : 	weights.x *= (triangle->invDepths[0]);

	vmulss	xmm2, xmm11, DWORD PTR [rcx+1764]

; 132  : 	weights.y = ((p3.y - p1.y) * (dv3x) + (p1.x - p3.x) * (dv3y)) * invDenom;

	vmulss	xmm7, xmm1, xmm7

; 133  : 	weights.z = 1 - weights.x - weights.y;

	vsubss	xmm0, xmm15, xmm11
	vsubss	xmm8, xmm0, xmm7

; 146  : 	weights.z *= (triangle->invDepths[2]);

	vmulss	xmm1, xmm8, DWORD PTR [rcx+1772]
	vmulss	xmm0, xmm7, DWORD PTR [rcx+1768]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	mov	ecx, DWORD PTR [rdx+4]
	sub	ecx, edi
	dec	ecx
	imul	ecx, DWORD PTR [rdx]
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 148  : 	return _fltInv(weights.x + weights.y + weights.z);

	vaddss	xmm0, xmm0, xmm2
	vaddss	xmm3, xmm0, xmm1

; 13   : 	_mm_store_ss(&rf, _mm_rcp_ss(_mm_set_ss(flt)));

	vrcpss	xmm4, xmm3, xmm3
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	add	ecx, r12d

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	vmovss	xmm0, DWORD PTR [rax+rcx*4]

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	vsubss	xmm1, xmm0, xmm4
	vcomiss	xmm1, xmm14
	jae	$LN118@CInternalP
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 205  : 	PCIPFragContext fContext = &triContext->fragContext;

	lea	r15, QWORD PTR [r13+40]
	mov	r14d, 4

; 206  : 	fContext->barycentricWeightings = bWeights;

	vmovss	DWORD PTR [r15+596], xmm11
	vmovss	DWORD PTR [r15+600], xmm7
	vmovss	DWORD PTR [r15+604], xmm8

; 207  : 	fContext->fragPos.x = drawX;
; 208  : 	fContext->fragPos.y = drawY;

	mov	DWORD PTR [r15+588], edi
	lea	rdi, QWORD PTR [r15+80]

; 209  : 	fContext->fragPos.depth = drawVect.z;

	vmovss	DWORD PTR [r15+592], xmm4
	mov	DWORD PTR [r15+584], r12d

; 210  : 
; 211  : 	_prepareFragmentInputValues(&fContext->fragInputs, triContext->screenTriAndData, bWeights);

	mov	rsi, QWORD PTR [r13+32]
	mov	rbx, rsi
	sub	rbx, r15

; 154  : 	PCIPVertOutputList fragInputList2 = &triData->vertOutputs[1];

	lea	r10, QWORD PTR [rsi+576]

; 205  : 	PCIPFragContext fContext = &triContext->fragContext;

	sub	r10, r15

; 155  : 	PCIPVertOutputList fragInputList3 = &triData->vertOutputs[2];

	lea	r11, QWORD PTR [rsi+1152]

; 205  : 	PCIPFragContext fContext = &triContext->fragContext;

	sub	r11, r15
	npad	4
$LL158@CInternalP:

; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rbx+rdi-80]
	lea	r9, QWORD PTR [rbx+rdi]
	test	eax, eax
	je	SHORT $LN156@CInternalP

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r8d, r8d
	test	eax, eax
	je	SHORT $LN156@CInternalP
	npad	13
$LL161@CInternalP:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm11, DWORD PTR [rsi+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [r9+r8*4-76]
	vmulss	xmm5, xmm7, DWORD PTR [rsi+1768]
	vmulss	xmm4, xmm8, DWORD PTR [rsi+1772]
	lea	rax, QWORD PTR [rdi+r10]
	vmulss	xmm1, xmm5, DWORD PTR [rax+r8*4-76]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [rdi+r8*4]
	vmulss	xmm1, xmm4, DWORD PTR [rcx+r11-76]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm5, xmm6
	vaddss	xmm2, xmm0, xmm4
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [rdi+r8*4-68], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [r9-80]
	inc	r8d
	mov	DWORD PTR [rdi-72], eax
	cmp	r8d, DWORD PTR [r9-80]
	jb	SHORT $LL161@CInternalP
$LN156@CInternalP:

; 159  : 		// get frag inputs
; 160  : 		PCIPVertOutput vertOutput1 = fragInputList1->outputs + inputID;
; 161  : 		PCIPVertOutput vertOutput2 = fragInputList2->outputs + inputID;
; 162  : 		PCIPVertOutput vertOutput3 = fragInputList3->outputs + inputID;
; 163  : 		PCIPVertOutput outVertOutput = inOutVertList->outputs + inputID;
; 164  : 
; 165  : 		// if componentcount is 0, skip
; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rbx+rdi-44]
	lea	r9, QWORD PTR [rbx+rdi]
	test	eax, eax
	je	SHORT $LN220@CInternalP

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r8d, r8d
	test	eax, eax
	je	SHORT $LN220@CInternalP
	npad	13
$LL219@CInternalP:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm11, DWORD PTR [rsi+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [r9+r8*4-40]
	vmulss	xmm5, xmm7, DWORD PTR [rsi+1768]
	vmulss	xmm4, xmm8, DWORD PTR [rsi+1772]
	lea	rax, QWORD PTR [rdi+r10]
	vmulss	xmm1, xmm5, DWORD PTR [rax+r8*4-40]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [rdi+r11]
	vmulss	xmm1, xmm4, DWORD PTR [rcx+r8*4-40]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm5, xmm6
	vaddss	xmm2, xmm0, xmm4
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [rdi+r8*4-32], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [r9-44]
	inc	r8d
	mov	DWORD PTR [rdi-36], eax
	cmp	r8d, DWORD PTR [r9-44]
	jb	SHORT $LL219@CInternalP
$LN220@CInternalP:

; 159  : 		// get frag inputs
; 160  : 		PCIPVertOutput vertOutput1 = fragInputList1->outputs + inputID;
; 161  : 		PCIPVertOutput vertOutput2 = fragInputList2->outputs + inputID;
; 162  : 		PCIPVertOutput vertOutput3 = fragInputList3->outputs + inputID;
; 163  : 		PCIPVertOutput outVertOutput = inOutVertList->outputs + inputID;
; 164  : 
; 165  : 		// if componentcount is 0, skip
; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rbx+rdi-8]
	lea	r9, QWORD PTR [rbx+rdi]
	test	eax, eax
	je	SHORT $LN223@CInternalP

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r8d, r8d
	test	eax, eax
	je	SHORT $LN223@CInternalP
	npad	13
$LL222@CInternalP:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm11, DWORD PTR [rsi+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [r9+r8*4-4]
	vmulss	xmm5, xmm7, DWORD PTR [rsi+1768]
	vmulss	xmm4, xmm8, DWORD PTR [rsi+1772]
	lea	rax, QWORD PTR [rdi+r8*4]
	vmulss	xmm1, xmm5, DWORD PTR [rax+r10-4]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [rdi+r8*4]
	vmulss	xmm1, xmm4, DWORD PTR [rcx+r11-4]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm5, xmm6
	vaddss	xmm2, xmm0, xmm4
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [rdi+r8*4+4], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [r9-8]
	inc	r8d
	mov	DWORD PTR [rdi], eax
	cmp	r8d, DWORD PTR [r9-8]
	jb	SHORT $LL222@CInternalP
$LN223@CInternalP:

; 159  : 		// get frag inputs
; 160  : 		PCIPVertOutput vertOutput1 = fragInputList1->outputs + inputID;
; 161  : 		PCIPVertOutput vertOutput2 = fragInputList2->outputs + inputID;
; 162  : 		PCIPVertOutput vertOutput3 = fragInputList3->outputs + inputID;
; 163  : 		PCIPVertOutput outVertOutput = inOutVertList->outputs + inputID;
; 164  : 
; 165  : 		// if componentcount is 0, skip
; 166  : 		if (vertOutput1->componentCount == 0) continue;

	mov	eax, DWORD PTR [rbx+rdi+28]
	lea	r9, QWORD PTR [rbx+rdi]
	test	eax, eax
	je	SHORT $LN226@CInternalP

; 167  : 
; 168  : 		// loop each component and interpolate
; 169  : 		for (UINT32 comp = 0; comp < vertOutput1->componentCount; comp++) {

	xor	r8d, r8d
	test	eax, eax
	je	SHORT $LN226@CInternalP
	npad	14
$LL225@CInternalP:

; 170  : 			// get each value for verts
; 171  : 			FLOAT val1 = vertOutput1->valueBuffer[comp];
; 172  : 			FLOAT val2 = vertOutput2->valueBuffer[comp];
; 173  : 			FLOAT val3 = vertOutput3->valueBuffer[comp];
; 174  : 
; 175  : 			// get W of each vert multiplied by barycentric weights
; 176  : 			FLOAT w1 = (triData->invDepths[0]) * bWeights.x;

	vmulss	xmm6, xmm11, DWORD PTR [rsi+1764]

; 177  : 			FLOAT w2 = (triData->invDepths[1]) * bWeights.y;
; 178  : 			FLOAT w3 = (triData->invDepths[2]) * bWeights.z;
; 179  : 
; 180  : 			// generate perspective correct values
; 181  : 			// implementation is taken from:
; 182  : 			// https://stackoverflow.com/questions/24441631/how-exactly-does-opengl-do-perspectively-correct-linear-interpolation
; 183  : 			FLOAT finalVal =

	vmulss	xmm0, xmm6, DWORD PTR [r9+r8*4+32]
	vmulss	xmm5, xmm7, DWORD PTR [rsi+1768]
	vmulss	xmm4, xmm8, DWORD PTR [rsi+1772]
	lea	rax, QWORD PTR [rdi+r8*4]
	vmulss	xmm1, xmm5, DWORD PTR [rax+r10+32]
	vaddss	xmm2, xmm1, xmm0
	lea	rcx, QWORD PTR [rdi+r8*4]
	vmulss	xmm1, xmm4, DWORD PTR [rcx+r11+32]
	vaddss	xmm3, xmm2, xmm1
	vaddss	xmm0, xmm5, xmm6
	vaddss	xmm2, xmm0, xmm4
	vdivss	xmm1, xmm3, xmm2

; 184  : 				(val1 * w1 + val2 * w2 + val3 * w3) / (w1 + w2 + w3);
; 185  : 
; 186  : 			// assign
; 187  : 			outVertOutput->valueBuffer[comp] = finalVal;

	vmovss	DWORD PTR [rdi+r8*4+40], xmm1

; 188  : 			outVertOutput->componentCount = vertOutput1->componentCount;

	mov	eax, DWORD PTR [r9+28]
	inc	r8d
	mov	DWORD PTR [rdi+36], eax
	cmp	r8d, DWORD PTR [r9+28]
	jb	SHORT $LL225@CInternalP
$LN226@CInternalP:

; 156  : 
; 157  : 	// interpolate all input values based on fragment
; 158  : 	for (UINT32 inputID = 0; inputID < CSM_CLASS_MAX_VERTEX_DATA; inputID++) {

	add	rdi, 144				; 00000090H
	sub	r14, 1
	jne	$LL158@CInternalP

; 18   : 	PCRenderBuffer renderBuffer = triContext->renderBuffer;

	mov	rsi, QWORD PTR [r13+648]

; 19   : 	// generate frag position
; 20   : 	INT fragPosX = triContext->fragContext.fragPos.x;
; 21   : 	INT fragPosY = triContext->fragContext.fragPos.y;

	mov	r14d, DWORD PTR [r13+628]
	mov	ebx, DWORD PTR [r13+624]

; 30   : 	if (triContext->material != NULL) {

	mov	r10, QWORD PTR [r13+656]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 157  : 	colorOut[0] = _findColorPtr(handle, x, y)[0];

	mov	ecx, DWORD PTR [rsi+4]
	mov	rax, QWORD PTR [rsi+8]
	sub	ecx, r14d

; 63   : 	return b->color + (x + ((b->height - y - 1) * b->width));

	dec	ecx
; File C:\Bailey\Programming\Caesium\csm.c

; 57   : 	rCol.g = g;

	mov	WORD PTR rCol$43[rbp-255], 0
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 63   : 	return b->color + (x + ((b->height - y - 1) * b->width));

	imul	ecx, DWORD PTR [rsi]
; File C:\Bailey\Programming\Caesium\csm.c

; 58   : 	rCol.b = b;

	mov	BYTE PTR rCol$43[rbp-256], 0

; 59   : 	rCol.a = a;

	mov	BYTE PTR rCol$43[rbp-253], 0
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 63   : 	return b->color + (x + ((b->height - y - 1) * b->width));

	add	ecx, ebx

; 157  : 	colorOut[0] = _findColorPtr(handle, x, y)[0];

	mov	edi, DWORD PTR [rax+rcx*4]
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 29   : 	CColor fragColor = CMakeColor4(0, 0, 0, 0);

	mov	eax, DWORD PTR rCol$43[rbp-256]
	mov	DWORD PTR fragColor$41[rbp-256], eax

; 30   : 	if (triContext->material != NULL) {

	test	r10, r10
	je	SHORT $LN165@CInternalP

; 31   : 		// apply fragment shader
; 32   : 		BOOL keepFrag = triContext->material->fragmentShader(

	mov	eax, DWORD PTR [r13+632]
	lea	r9, QWORD PTR $T20[rbp-256]
	vmovsd	xmm0, QWORD PTR [r13+624]
	mov	r8d, DWORD PTR [r13+16]
	mov	rcx, r15
	mov	edx, DWORD PTR [r13+20]
	mov	DWORD PTR $T20[rbp-248], eax
	lea	rax, QWORD PTR fragColor$41[rbp-256]
	mov	QWORD PTR [rsp+32], rax
	vmovsd	QWORD PTR $T20[rbp-256], xmm0
	call	QWORD PTR [r10+16]

; 33   : 			&triContext->fragContext,
; 34   : 			triContext->triangleID,
; 35   : 			triContext->instanceID,
; 36   : 			triContext->fragContext.fragPos,
; 37   : 			&fragColor
; 38   : 		);
; 39   : 		if (keepFrag == FALSE) return; // cull if needed

	test	eax, eax
	je	$LN272@CInternalP

; 40   : 	}

	mov	eax, DWORD PTR fragColor$41[rbp-256]
	jmp	SHORT $LN166@CInternalP
$LN165@CInternalP:
; File C:\Bailey\Programming\Caesium\csm.c

; 48   : 	rCol.g = g;

	mov	WORD PTR rCol$26[rsp+1], 65280		; 0000ff00H

; 49   : 	rCol.b = b;

	mov	BYTE PTR rCol$26[rsp], 255		; 000000ffH

; 50   : 	rCol.a = 255;

	mov	BYTE PTR rCol$26[rsp+3], 255		; 000000ffH
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 44   : 		fragColor = CMakeColor3(255, 0, 255);

	mov	eax, DWORD PTR rCol$26[rsp]
	mov	DWORD PTR fragColor$41[rbp-256], eax
$LN166@CInternalP:

; 45   : 	}
; 46   : 
; 47   : 	// if color alpha is 0, cull
; 48   : 	if (fragColor.a == 0) return;

	mov	ecx, eax
	shr	ecx, 24
	test	cl, cl
	je	SHORT $LN272@CInternalP

; 49   : 
; 50   : 	// apply alpha blend (if needed)
; 51   : 	if (fragColor.a != 255)

	cmp	cl, 255					; 000000ffH
	je	SHORT $LN169@CInternalP

; 52   : 		fragColor = CFragmentBlendColor(belowColor, fragColor);

	mov	edx, eax
	mov	ecx, edi
	call	CFragmentBlendColor
	mov	DWORD PTR fragColor$41[rbp-256], eax
$LN169@CInternalP:
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	mov	edx, DWORD PTR [rsi+4]

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	mov	rcx, QWORD PTR [rsi+16]

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	sub	edx, r14d
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 55   : 	CRenderBufferUnsafeSetFragment(

	vmovss	xmm2, DWORD PTR [r13+632]
; File C:\Bailey\Programming\Caesium\csm_renderbuffer.c

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	mov	edi, DWORD PTR drawY$1$[rsp]

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	dec	edx
	imul	edx, DWORD PTR [rsi]
	add	edx, ebx

; 176  : 	oldDepth = _findDepthPtr(handle, x, y)[0];

	vmovss	xmm0, DWORD PTR [rcx+rdx*4]

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	vsubss	xmm1, xmm0, xmm2
	vcomiss	xmm1, xmm14
	jae	SHORT $LN118@CInternalP

; 167  : 	_findColorPtr(handle, x, y)[0] = color;

	mov	rcx, QWORD PTR [rsi+8]
	mov	DWORD PTR [rcx+rdx*4], eax

; 168  : 	_findDepthPtr(handle, x, y)[0] = depth;

	mov	ecx, DWORD PTR [rsi+4]
	mov	rax, QWORD PTR [rsi+16]
	sub	ecx, r14d

; 67   : 	return b->depth + (x + ((b->height - y - 1) * b->width));

	dec	ecx
	imul	ecx, DWORD PTR [rsi]
	add	ecx, ebx

; 168  : 	_findDepthPtr(handle, x, y)[0] = depth;

	vmovss	DWORD PTR [rax+rcx*4], xmm2

; 177  : 	if (oldDepth - newDepth >= CSM_RENDERBUFFER_DEPTH_TEST_EPSILON) {

	jmp	SHORT $LN118@CInternalP
$LN272@CInternalP:
; File C:\Bailey\Programming\Caesium\csmint_pl_rasterizetri.c

; 305  : 		for (INT drawX = DRAW_X_START; drawX <= DRAW_X_END; drawX++) {

	mov	edi, DWORD PTR drawY$1$[rsp]
$LN118@CInternalP:
	inc	r12d
	cmp	r12d, DWORD PTR DRAW_X_END$1$[rsp]
	jle	$LL120@CInternalP
	vmovss	xmm14, DWORD PTR LBase$1$[rsp]
	vmovss	xmm15, DWORD PTR RBase$1$[rsp]
	vmovss	xmm7, DWORD PTR LBase$2$[rsp]
	vmovss	xmm8, DWORD PTR invSlopeR$1$[rsp]
	vmovss	xmm9, DWORD PTR invSlopeL$1$[rsp]
	vmovss	xmm10, DWORD PTR __real@00000000$1$[rbp-256]
	mov	rcx, QWORD PTR renderBuff$1$[rsp]
$LN115@CInternalP:

; 291  : 
; 292  : 	// note: Y walks downwards
; 293  : 	for (INT drawY = DRAW_Y_START; drawY >= DRAW_Y_END; drawY--) {

	dec	edi
	mov	DWORD PTR drawY$1$[rsp], edi
	cmp	edi, DWORD PTR DRAW_Y_END$1$[rsp]
	jge	$LL117@CInternalP
$LN289@CInternalP:
	mov	r12, QWORD PTR [rsp+3984]
	vmovaps	xmm13, XMMWORD PTR [rsp+3840]
	mov	r14, QWORD PTR [rsp+3976]
	mov	r15, QWORD PTR [rsp+3968]
	mov	rbx, QWORD PTR [rsp+4048]
	vmovaps	xmm9, XMMWORD PTR [rsp+3904]
	vmovaps	xmm8, XMMWORD PTR [rsp+3920]
	vmovaps	xmm7, XMMWORD PTR [rsp+3936]
	vmovaps	xmm6, XMMWORD PTR [rsp+3952]
	vmovaps	xmm10, XMMWORD PTR [rsp+3888]
	vmovaps	xmm11, XMMWORD PTR [rsp+3872]
	vmovaps	xmm12, XMMWORD PTR [rsp+3856]
	vmovaps	xmm14, XMMWORD PTR [rsp+3824]
	vmovaps	xmm15, XMMWORD PTR [rsp+3808]
$LN123@CInternalP:

; 352  : 
; 353  : 	_drawFlatBottomTri(triContext, &flatBottomTri);
; 354  : 	_drawFlatTopTri(triContext, &flatTopTri);
; 355  : }

	vzeroupper
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 3992				; 00000f98H
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
CInternalPipelineRasterizeTri ENDP
_TEXT	ENDS
END
