; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30148.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_09NMOEEFMG@CMakeMesh@			; `string'
PUBLIC	??_C@_0CO@JBHLAGNI@CMakeMesh?5failed?5because?5vertex@ ; `string'
PUBLIC	??_C@_0CN@DPMCPADO@CMakeMesh?5failed?5because?5indexC@ ; `string'
PUBLIC	??_C@_0DM@EDJKMFAH@CMakeMesh?5failed?5because?5indexC@ ; `string'
PUBLIC	??_C@_0DG@PLOFFAIF@CMakeMesh?5failed?5because?5vertPo@ ; `string'
PUBLIC	??_C@_0CK@MMNDFJHN@CMakeMesh?5failed?5because?5indexe@ ; `string'
PUBLIC	??_C@_0HH@PMFNOFOA@CMakeMesh?5failed?5because?5index?5@ ; `string'
PUBLIC	??_C@_0N@LKLFAECI@CDestroyMesh@			; `string'
PUBLIC	??_C@_0CM@MCABMJGF@CDestroyMesh?5failed?5because?5han@ ; `string'
PUBLIC	??_C@_0CP@NBCDBGLG@CDestroyMesh?5failed?5because?5han@ ; `string'
PUBLIC	??_C@_0BB@CONFLMDK@CMeshGetTriCount@		; `string'
PUBLIC	??_C@_0DD@JMLDBFEE@CMeshGetTriCount?5failed?5because@ ; `string'
PUBLIC	??_C@_0BC@MBKHEFIO@CMeshGetVertCount@		; `string'
PUBLIC	??_C@_0DE@PHNOCPBA@CMeshGetVertCount?5failed?5becaus@ ; `string'
EXTRN	__imp___stdio_common_vsprintf_s:PROC
;	COMDAT ??_C@_0DE@PHNOCPBA@CMeshGetVertCount?5failed?5becaus@
CONST	SEGMENT
??_C@_0DE@PHNOCPBA@CMeshGetVertCount?5failed?5becaus@ DB 'CMeshGetVertCou'
	DB	'nt failed because handle was invalid', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MBKHEFIO@CMeshGetVertCount@
CONST	SEGMENT
??_C@_0BC@MBKHEFIO@CMeshGetVertCount@ DB 'CMeshGetVertCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JMLDBFEE@CMeshGetTriCount?5failed?5because@
CONST	SEGMENT
??_C@_0DD@JMLDBFEE@CMeshGetTriCount?5failed?5because@ DB 'CMeshGetTriCoun'
	DB	't failed because handle was invalid', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CONFLMDK@CMeshGetTriCount@
CONST	SEGMENT
??_C@_0BB@CONFLMDK@CMeshGetTriCount@ DB 'CMeshGetTriCount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@NBCDBGLG@CDestroyMesh?5failed?5because?5han@
CONST	SEGMENT
??_C@_0CP@NBCDBGLG@CDestroyMesh?5failed?5because?5han@ DB 'CDestroyMesh f'
	DB	'ailed because handle was invalid', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MCABMJGF@CDestroyMesh?5failed?5because?5han@
CONST	SEGMENT
??_C@_0CM@MCABMJGF@CDestroyMesh?5failed?5because?5han@ DB 'CDestroyMesh f'
	DB	'ailed because handle was NULL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LKLFAECI@CDestroyMesh@
CONST	SEGMENT
??_C@_0N@LKLFAECI@CDestroyMesh@ DB 'CDestroyMesh', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0HH@PMFNOFOA@CMakeMesh?5failed?5because?5index?5@
CONST	SEGMENT
??_C@_0HH@PMFNOFOA@CMakeMesh?5failed?5because?5index?5@ DB 'CMakeMesh fai'
	DB	'led because index at %d references vertex value (%d) that doe'
	DB	's not exist.', 0aH, 'Valid vertex values are [0-%d].', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@MMNDFJHN@CMakeMesh?5failed?5because?5indexe@
CONST	SEGMENT
??_C@_0CK@MMNDFJHN@CMakeMesh?5failed?5because?5indexe@ DB 'CMakeMesh fail'
	DB	'ed because indexes was NULL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@PLOFFAIF@CMakeMesh?5failed?5because?5vertPo@
CONST	SEGMENT
??_C@_0DG@PLOFFAIF@CMakeMesh?5failed?5because?5vertPo@ DB 'CMakeMesh fail'
	DB	'ed because vertPositionalArray was NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@EDJKMFAH@CMakeMesh?5failed?5because?5indexC@
CONST	SEGMENT
??_C@_0DM@EDJKMFAH@CMakeMesh?5failed?5because?5indexC@ DB 'CMakeMesh fail'
	DB	'ed because indexCount was not a multiple of 3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@DPMCPADO@CMakeMesh?5failed?5because?5indexC@
CONST	SEGMENT
??_C@_0CN@DPMCPADO@CMakeMesh?5failed?5because?5indexC@ DB 'CMakeMesh fail'
	DB	'ed because indexCount was <= 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JBHLAGNI@CMakeMesh?5failed?5because?5vertex@
CONST	SEGMENT
??_C@_0CO@JBHLAGNI@CMakeMesh?5failed?5because?5vertex@ DB 'CMakeMesh fail'
	DB	'ed because vertexCount was <= 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NMOEEFMG@CMakeMesh@
CONST	SEGMENT
??_C@_09NMOEEFMG@CMakeMesh@ DB 'CMakeMesh', 00H		; `string'
PUBLIC	CMeshGetVertCount
PUBLIC	CMeshGetTriCount
PUBLIC	CDestroyMesh
PUBLIC	CMakeMesh
PUBLIC	sprintf_s
PUBLIC	_vsprintf_s_l
;	COMDAT pdata
pdata	SEGMENT
$pdata$CMeshGetVertCount DD imagerel $LN20
	DD	imagerel $LN20+291
	DD	imagerel $unwind$CMeshGetVertCount
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CMeshGetTriCount DD imagerel $LN20
	DD	imagerel $LN20+292
	DD	imagerel $unwind$CMeshGetTriCount
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CDestroyMesh DD imagerel $LN26
	DD	imagerel $LN26+445
	DD	imagerel $unwind$CDestroyMesh
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CMakeMesh DD imagerel $LN63
	DD	imagerel $LN63+333
	DD	imagerel $unwind$CMakeMesh
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$CMakeMesh DD imagerel $LN63+333
	DD	imagerel $LN63+452
	DD	imagerel $chain$0$CMakeMesh
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$CMakeMesh DD imagerel $LN63+452
	DD	imagerel $LN63+635
	DD	imagerel $chain$1$CMakeMesh
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$CMakeMesh DD imagerel $LN63+635
	DD	imagerel $LN63+761
	DD	imagerel $chain$2$CMakeMesh
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$CMakeMesh DD imagerel $LN63+761
	DD	imagerel $LN63+792
	DD	imagerel $chain$3$CMakeMesh
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf_s DD imagerel $LN6@sprintf_s
	DD	imagerel $LN6@sprintf_s+88
	DD	imagerel $unwind$sprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_s_l DD imagerel $LN4@vsprintf_s
	DD	imagerel $LN4@vsprintf_s+92
	DD	imagerel $unwind$_vsprintf_s_l
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_s_l DQ 00009640f00060f01r	; 1.30596e-308
	DQ	0700b520f0008340fr		; 5.30195e+231
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf_s DQ 0700e621200051201r		; 5.89629e+231
	DQ	00000300b500c600dr		; 2.60991e-310
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$CMakeMesh DD 021H
	DD	imagerel $LN63
	DD	imagerel $LN63+333
	DD	imagerel $unwind$CMakeMesh
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$CMakeMesh DD 021H
	DD	imagerel $LN63+333
	DD	imagerel $LN63+452
	DD	imagerel $chain$0$CMakeMesh
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$CMakeMesh DD 020821H
	DD	02ad408H
	DD	imagerel $LN63+333
	DD	imagerel $LN63+452
	DD	imagerel $chain$0$CMakeMesh
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$CMakeMesh DD 020821H
	DD	02bc408H
	DD	imagerel $LN63
	DD	imagerel $LN63+333
	DD	imagerel $unwind$CMakeMesh
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CMakeMesh DD 072119H
	DD	02c010fH
	DD	0e006f008H
	DD	060037004H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	0140H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CDestroyMesh DD 064501H
	DD	063445H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CMeshGetTriCount DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CMeshGetVertCount DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
;	COMDAT CMakeMesh
_TEXT	SEGMENT
indexes$GSCopy$1$ = 48
errBuff$1 = 64
__$ArrayPad$ = 320
vertexCount$ = 400
vertPositionalArray$ = 408
indexCount$ = 416
indexes$ = 424
CMakeMesh PROC						; COMDAT

; 10   : 	PFLOAT vertPositionalArray, UINT32 indexCount, PINT indexes) {

$LN63:
	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 352				; 00000160H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 10   : 	PFLOAT vertPositionalArray, UINT32 indexCount, PINT indexes) {

	mov	rdi, r9
	mov	QWORD PTR indexes$GSCopy$1$[rsp], r9
	mov	rsi, rdx
	mov	r14d, r8d
	mov	r15d, ecx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN16@CMakeMesh
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN16@CMakeMesh:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_09NMOEEFMG@CMakeMesh@
	lea	rbx, OFFSET FLAT:_csmint
	mov	QWORD PTR [rbx+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 11   : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 11   : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 12   : 
; 13   : 	if (vertexCount <= 0) {

	test	r15d, r15d
	jne	SHORT $LN5@CMakeMesh

; 14   : 		_CSyncLeaveErr(NULL, "CMakeMesh failed because vertexCount was <= 0");

	lea	rcx, OFFSET FLAT:??_C@_0CO@JBHLAGNI@CMakeMesh?5failed?5because?5vertex@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN21@CMakeMesh
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN21@CMakeMesh:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rbx+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 14   : 		_CSyncLeaveErr(NULL, "CMakeMesh failed because vertexCount was <= 0");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 14   : 		_CSyncLeaveErr(NULL, "CMakeMesh failed because vertexCount was <= 0");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	jmp	$LN1@CMakeMesh
$LN5@CMakeMesh:

; 15   : 	}
; 16   : 	if (indexCount <= 0) {

	test	r14d, r14d
	jne	SHORT $LN6@CMakeMesh

; 17   : 		_CSyncLeaveErr(NULL, "CMakeMesh failed because indexCount was <= 0");

	lea	rcx, OFFSET FLAT:??_C@_0CN@DPMCPADO@CMakeMesh?5failed?5because?5indexC@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN26@CMakeMesh
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN26@CMakeMesh:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rbx+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 17   : 		_CSyncLeaveErr(NULL, "CMakeMesh failed because indexCount was <= 0");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 17   : 		_CSyncLeaveErr(NULL, "CMakeMesh failed because indexCount was <= 0");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	jmp	$LN1@CMakeMesh
$LN6@CMakeMesh:
	mov	QWORD PTR [rsp+344], r12

; 18   : 	}
; 19   : 	if ((indexCount % 3) != 0) {

	mov	eax, -1431655765			; aaaaaaabH
	mul	r14d
	mov	r12d, edx
	shr	r12d, 1
	lea	ecx, DWORD PTR [r12+r12*2]
	cmp	r14d, ecx
	je	SHORT $LN7@CMakeMesh

; 20   : 		_CSyncLeaveErr(NULL, "CMakeMesh failed because indexCount was not a multiple of 3");

	lea	rcx, OFFSET FLAT:??_C@_0DM@EDJKMFAH@CMakeMesh?5failed?5because?5indexC@
	jmp	$LN61@CMakeMesh
$LN7@CMakeMesh:

; 21   : 	}
; 22   : 	if (vertPositionalArray == NULL) {

	test	rsi, rsi
	jne	SHORT $LN8@CMakeMesh

; 23   : 		_CSyncLeaveErr(NULL, "CMakeMesh failed because vertPositionalArray was NULL");

	lea	rcx, OFFSET FLAT:??_C@_0DG@PLOFFAIF@CMakeMesh?5failed?5because?5vertPo@
	jmp	$LN61@CMakeMesh
$LN8@CMakeMesh:

; 24   : 	}
; 25   : 	if (indexes == NULL) {

	test	rdi, rdi
	jne	SHORT $LN9@CMakeMesh

; 26   : 		_CSyncLeaveErr(NULL, "CMakeMesh failed because indexes was NULL");

	lea	rcx, OFFSET FLAT:??_C@_0CK@MMNDFJHN@CMakeMesh?5failed?5because?5indexe@
	jmp	$LN61@CMakeMesh
$LN9@CMakeMesh:

; 27   : 	}
; 28   : 
; 29   : 	// loop all indexes to ensure that ONLY VALID verts are referenced
; 30   : 	for (int i = 0; i < indexCount; i++) {

	xor	r9d, r9d
	mov	rax, rdi
$LL4@CMakeMesh:

; 31   : 		INT vertIndex = indexes[i];

	mov	ecx, DWORD PTR [rax]

; 32   : 		if (vertIndex < 0 || vertIndex >= vertexCount) {

	test	ecx, ecx
	js	$LN54@CMakeMesh
	cmp	ecx, r15d
	jae	$LN54@CMakeMesh

; 27   : 	}
; 28   : 
; 29   : 	// loop all indexes to ensure that ONLY VALID verts are referenced
; 30   : 	for (int i = 0; i < indexCount; i++) {

	inc	r9d
	add	rax, 4
	cmp	r9d, r14d
	jb	SHORT $LL4@CMakeMesh

; 45   : 		}
; 46   : 	}
; 47   : 
; 48   : 	// allocate mesh
; 49   : 	PCMesh mPtr = CInternalAlloc(sizeof(CMesh));

	mov	ecx, 40					; 00000028H
	mov	QWORD PTR [rsp+336], r13
	call	CInternalAlloc

; 50   : 
; 51   : 	// calculate vertex data size and copy
; 52   : 	const SIZE_T vertexDataSize = sizeof(CVect3F) * vertexCount;

	lea	rbx, QWORD PTR [r15+r15*2]
	mov	r13, rax
	shl	rbx, 2

; 53   : 	mPtr->vertArray = CInternalAlloc(vertexDataSize);

	mov	rcx, rbx
	call	CInternalAlloc

; 54   : 	COPY_BYTES(vertPositionalArray, mPtr->vertArray, vertexDataSize);

	mov	rcx, rbx
	mov	QWORD PTR [r13+8], rax
	mov	rdi, rax

; 55   : 
; 56   : 	// calculate indicies size and copy
; 57   : 	const SIZE_T indexDataSize = sizeof(INT) * indexCount;

	mov	rbx, r14
	rep movsb
	shl	rbx, 2

; 58   : 	mPtr->indexArray = CInternalAlloc(indexDataSize);

	mov	rcx, rbx
	call	CInternalAlloc

; 59   : 	COPY_BYTES(indexes, mPtr->indexArray, indexDataSize);

	mov	rsi, QWORD PTR indexes$GSCopy$1$[rsp]
	mov	rdi, rax
	mov	QWORD PTR [r13+24], rax
	mov	rcx, rbx
	rep movsb

; 60   : 
; 61   : 	// set other data values
; 62   : 	mPtr->indexCount = indexCount;

	mov	DWORD PTR [r13+16], r14d

; 63   : 	mPtr->vertCount	 = vertexCount;

	mov	DWORD PTR [r13], r15d

; 64   : 	mPtr->triCount   = indexCount / 3;

	mov	DWORD PTR [r13+32], r12d
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN51@CMakeMesh
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN51@CMakeMesh:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	lea	rcx, OFFSET FLAT:_csmint
	mov	QWORD PTR [rcx+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 66   : 	_CSyncLeave(mPtr);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 66   : 	_CSyncLeave(mPtr);

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rax, r13
	mov	r13, QWORD PTR [rsp+336]
	jmp	SHORT $LN58@CMakeMesh
$LN54@CMakeMesh:

; 33   : 			// generate specific error message
; 34   : 			CHAR errBuff[0xFF];
; 35   : 			sprintf_s(

	mov	DWORD PTR [rsp+40], r15d
	lea	r8, OFFSET FLAT:??_C@_0HH@PMFNOFOA@CMakeMesh?5failed?5because?5index?5@
	mov	DWORD PTR [rsp+32], ecx
	mov	edx, 255				; 000000ffH
	lea	rcx, QWORD PTR errBuff$1[rsp]
	call	sprintf_s

; 44   : 			_CSyncLeaveErr(NULL, errBuff);

	lea	rcx, QWORD PTR errBuff$1[rsp]
$LN61@CMakeMesh:
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	call	CInternalSetLastError
	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN46@CMakeMesh
	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN46@CMakeMesh:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rbx+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 44   : 			_CSyncLeaveErr(NULL, errBuff);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 44   : 			_CSyncLeaveErr(NULL, errBuff);

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
$LN58@CMakeMesh:
	mov	r12, QWORD PTR [rsp+344]
$LN1@CMakeMesh:

; 67   : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 352				; 00000160H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
CMakeMesh ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
;	COMDAT CDestroyMesh
_TEXT	SEGMENT
handle$ = 48
CDestroyMesh PROC					; COMDAT

; 69   : CSMCALL BOOL CDestroyMesh(PCHandle handle) {

$LN26:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 69   : CSMCALL BOOL CDestroyMesh(PCHandle handle) {

	mov	rdi, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN8@CDestroyMe
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN8@CDestroyMe:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0N@LKLFAECI@CDestroyMesh@
	mov	QWORD PTR [rsp+48], rbx
	lea	rsi, OFFSET FLAT:_csmint
	mov	QWORD PTR [rsi+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 70   : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 70   : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 71   : 
; 72   : 	if (handle == NULL) {

	test	rdi, rdi
	jne	SHORT $LN2@CDestroyMe

; 73   : 		_CSyncLeaveErr(FALSE, "CDestroyMesh failed because handle was NULL");

	lea	rcx, OFFSET FLAT:??_C@_0CM@MCABMJGF@CDestroyMesh?5failed?5because?5han@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN13@CDestroyMe
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN13@CDestroyMe:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	xor	ebx, ebx
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 73   : 		_CSyncLeaveErr(FALSE, "CDestroyMesh failed because handle was NULL");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rsi+rax*8+200], rbx

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 73   : 		_CSyncLeaveErr(FALSE, "CDestroyMesh failed because handle was NULL");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+48]

; 88   : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@CDestroyMe:

; 74   : 	}
; 75   : 	
; 76   : 	PCMesh mPtr = *handle;

	mov	rbx, QWORD PTR [rdi]

; 77   : 	if (mPtr == NULL) {

	test	rbx, rbx
	jne	SHORT $LN3@CDestroyMe

; 78   : 		_CSyncLeaveErr(FALSE, "CDestroyMesh failed because handle was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0CP@NBCDBGLG@CDestroyMesh?5failed?5because?5han@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN18@CDestroyMe
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN18@CDestroyMe:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	xor	ebx, ebx
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 78   : 		_CSyncLeaveErr(FALSE, "CDestroyMesh failed because handle was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rsi+rax*8+200], rbx

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 78   : 		_CSyncLeaveErr(FALSE, "CDestroyMesh failed because handle was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+48]

; 88   : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@CDestroyMe:

; 79   : 	}
; 80   : 
; 81   : 	// free and set hndl to NULL
; 82   : 	CInternalFree(mPtr->indexArray);

	mov	rcx, QWORD PTR [rbx+24]
	call	CInternalFree

; 83   : 	CInternalFree(mPtr->vertArray);

	mov	rcx, QWORD PTR [rbx+8]
	call	CInternalFree

; 84   : 	CInternalFree(mPtr);

	mov	rcx, rbx
	call	CInternalFree

; 85   : 	*handle = NULL;

	xor	ebx, ebx
	mov	QWORD PTR [rdi], rbx
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN23@CDestroyMe
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN23@CDestroyMe:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rsi+rax*8+200], rbx
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 87   : 	_CSyncLeave(TRUE);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 87   : 	_CSyncLeave(TRUE);

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rbx, QWORD PTR [rsp+48]
	mov	eax, 1

; 88   : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CDestroyMesh ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
;	COMDAT CMeshGetTriCount
_TEXT	SEGMENT
handle$ = 48
CMeshGetTriCount PROC					; COMDAT

; 90   : CSMCALL UINT32 CMeshGetTriCount(CHandle handle) {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 90   : CSMCALL UINT32 CMeshGetTriCount(CHandle handle) {

	mov	rbx, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN7@CMeshGetTr
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN7@CMeshGetTr:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0BB@CONFLMDK@CMeshGetTriCount@
	lea	rdi, OFFSET FLAT:_csmint
	mov	QWORD PTR [rdi+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 91   : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 91   : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 92   : 
; 93   : 	if (handle == NULL) {

	test	rbx, rbx
	jne	SHORT $LN2@CMeshGetTr

; 94   : 		_CSyncLeaveErr(FALSE, "CMeshGetTriCount failed because handle was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0DD@JMLDBFEE@CMeshGetTriCount?5failed?5because@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN12@CMeshGetTr
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN12@CMeshGetTr:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rdi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 94   : 		_CSyncLeaveErr(FALSE, "CMeshGetTriCount failed because handle was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 94   : 		_CSyncLeaveErr(FALSE, "CMeshGetTriCount failed because handle was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 100  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@CMeshGetTr:
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN17@CMeshGetTr
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN17@CMeshGetTr:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rdi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 99   : 	_CSyncLeave(pMesh->triCount);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 99   : 	_CSyncLeave(pMesh->triCount);

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	eax, DWORD PTR [rbx+32]

; 100  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CMeshGetTriCount ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_mesh.c
;	COMDAT CMeshGetVertCount
_TEXT	SEGMENT
handle$ = 48
CMeshGetVertCount PROC					; COMDAT

; 102  : CSMCALL UINT32 CMeshGetVertCount(CHandle handle) {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 102  : CSMCALL UINT32 CMeshGetVertCount(CHandle handle) {

	mov	rbx, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN7@CMeshGetVe
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN7@CMeshGetVe:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0BC@MBKHEFIO@CMeshGetVertCount@
	lea	rdi, OFFSET FLAT:_csmint
	mov	QWORD PTR [rdi+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 103  : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 103  : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 104  : 
; 105  : 	if (handle == NULL) {

	test	rbx, rbx
	jne	SHORT $LN2@CMeshGetVe

; 106  : 		_CSyncLeaveErr(FALSE, "CMeshGetVertCount failed because handle was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0DE@PHNOCPBA@CMeshGetVertCount?5failed?5becaus@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN12@CMeshGetVe
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN12@CMeshGetVe:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rdi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 106  : 		_CSyncLeaveErr(FALSE, "CMeshGetVertCount failed because handle was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 106  : 		_CSyncLeaveErr(FALSE, "CMeshGetVertCount failed because handle was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 112  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@CMeshGetVe:
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN17@CMeshGetVe
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN17@CMeshGetVe:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rdi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 111  : 	_CSyncLeave(pMesh->vertCount);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_mesh.c

; 111  : 	_CSyncLeave(pMesh->vertCount);

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	eax, DWORD PTR [rbx]

; 112  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CMeshGetVertCount ENDP
_TEXT	ENDS
END
