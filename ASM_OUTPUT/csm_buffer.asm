; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30148.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BG@IIKKEFIC@CMakeVertexDataBuffer@	; `string'
PUBLIC	??_C@_0DD@NOLEMLOD@CMakeVertexDataBuffer?5failed?5be@ ; `string'
PUBLIC	??_C@_0DI@BMBPHDAB@CMakeVertexDataBuffer?5failed?5be@ ; `string'
PUBLIC	??_C@_0DN@OKMKOHCB@CMakeVertexDataBuffer?5failed?5be@ ; `string'
PUBLIC	??_C@_0ED@PPFOMGJP@CMakeVertexDataBuffer?5failed?5be@ ; `string'
PUBLIC	??_C@_0BJ@EHGHEGAD@CDestroyVertexDataBuffer@	; `string'
PUBLIC	??_C@_0ED@FMEONNNG@CDestroyVertexDataBuffer?5failed@ ; `string'
PUBLIC	??_C@_0EG@NOPGNNDF@CDestroyVertexDataBuffer?5failed@ ; `string'
PUBLIC	??_C@_0BM@LHMBODLJ@CVertexDataBufferGetElement@	; `string'
PUBLIC	??_C@_0EA@EHFCDKDO@CVertexDataBufferGetElement?5fai@ ; `string'
PUBLIC	??_C@_0DO@GMCHNLBM@CVertexDataBufferGetElement?5fai@ ; `string'
PUBLIC	??_C@_0EA@BIOCLIPO@CVertexDataBufferSetElement?5fai@ ; `string'
PUBLIC	??_C@_0DN@FDCMAMDA@CVertexDataBufferSetElement?5fai@ ; `string'
PUBLIC	??_C@_0DN@NCNEEOCP@CVertexDataBufferSetElement?5fai@ ; `string'
PUBLIC	??_C@_0CB@CFKBNCJD@CVertexDataBufferGetElementCoun@ ; `string'
PUBLIC	??_C@_0EF@NBHGEINM@CVertexDataBufferGetElementCoun@ ; `string'
PUBLIC	??_C@_0CD@KEMFMAGO@CVertexDataBufferGetComponentCo@ ; `string'
PUBLIC	??_C@_0EH@KKHJLFON@CVertexDataBufferGetComponentCo@ ; `string'
PUBLIC	??_C@_0BG@IGGEADDO@CMakeStaticDataBuffer@	; `string'
PUBLIC	??_C@_0DD@NKDGEJEA@CMakeStaticDataBuffer?5failed?5be@ ; `string'
PUBLIC	??_C@_0DF@GIPGPGNM@CMakeStaticDataBuffer?5failed?5be@ ; `string'
PUBLIC	??_C@_0BJ@EJKJAALP@CDestroyStaticDataBuffer@	; `string'
PUBLIC	??_C@_0ED@LPIAHPOE@CDestroyStaticDataBuffer?5failed@ ; `string'
PUBLIC	??_C@_0EG@BJPENNPE@CDestroyStaticDataBuffer?5failed@ ; `string'
PUBLIC	??_C@_0ED@LMOEJCNL@CDestroyStaticDataBuffer?5failed@ ; `string'
PUBLIC	??_C@_0BF@EFOJFIGE@CStaticDataBufferMap@	; `string'
PUBLIC	??_C@_0DJ@LBBNFDCP@CStaticDataBufferMap?5failed?5bec@ ; `string'
PUBLIC	??_C@_0BH@MNKNHCAI@CStaticDataBufferUnmap@	; `string'
PUBLIC	??_C@_0DL@NCNMFMIH@CStaticDataBufferUnmap?5failed?5b@ ; `string'
PUBLIC	??_C@_0BO@JJJNLHFJ@CStaticDataBufferGetSizeBytes@ ; `string'
PUBLIC	??_C@_0EC@JJMCHMPB@CStaticDataBufferGetSizeBytes?5f@ ; `string'
EXTRN	__imp_TryEnterCriticalSection:PROC
;	COMDAT ??_C@_0EC@JJMCHMPB@CStaticDataBufferGetSizeBytes?5f@
CONST	SEGMENT
??_C@_0EC@JJMCHMPB@CStaticDataBufferGetSizeBytes?5f@ DB 'CStaticDataBuffe'
	DB	'rGetSizeBytes failed because sdBuffer was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@JJJNLHFJ@CStaticDataBufferGetSizeBytes@
CONST	SEGMENT
??_C@_0BO@JJJNLHFJ@CStaticDataBufferGetSizeBytes@ DB 'CStaticDataBufferGe'
	DB	'tSizeBytes', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@NCNMFMIH@CStaticDataBufferUnmap?5failed?5b@
CONST	SEGMENT
??_C@_0DL@NCNMFMIH@CStaticDataBufferUnmap?5failed?5b@ DB 'CStaticDataBuff'
	DB	'erUnmap failed because sdBuffer was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MNKNHCAI@CStaticDataBufferUnmap@
CONST	SEGMENT
??_C@_0BH@MNKNHCAI@CStaticDataBufferUnmap@ DB 'CStaticDataBufferUnmap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@LBBNFDCP@CStaticDataBufferMap?5failed?5bec@
CONST	SEGMENT
??_C@_0DJ@LBBNFDCP@CStaticDataBufferMap?5failed?5bec@ DB 'CStaticDataBuff'
	DB	'erMap failed because sdBuffer was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EFOJFIGE@CStaticDataBufferMap@
CONST	SEGMENT
??_C@_0BF@EFOJFIGE@CStaticDataBufferMap@ DB 'CStaticDataBufferMap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@LMOEJCNL@CDestroyStaticDataBuffer?5failed@
CONST	SEGMENT
??_C@_0ED@LMOEJCNL@CDestroyStaticDataBuffer?5failed@ DB 'CDestroyStaticDa'
	DB	'taBuffer failed because buffer is currently mapped', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@BJPENNPE@CDestroyStaticDataBuffer?5failed@
CONST	SEGMENT
??_C@_0EG@BJPENNPE@CDestroyStaticDataBuffer?5failed@ DB 'CDestroyStaticDa'
	DB	'taBuffer failed because pStaticDataBuffer was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@LPIAHPOE@CDestroyStaticDataBuffer?5failed@
CONST	SEGMENT
??_C@_0ED@LPIAHPOE@CDestroyStaticDataBuffer?5failed@ DB 'CDestroyStaticDa'
	DB	'taBuffer failed because pStaticDataBuffer was NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EJKJAALP@CDestroyStaticDataBuffer@
CONST	SEGMENT
??_C@_0BJ@EJKJAALP@CDestroyStaticDataBuffer@ DB 'CDestroyStaticDataBuffer'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GIPGPGNM@CMakeStaticDataBuffer?5failed?5be@
CONST	SEGMENT
??_C@_0DF@GIPGPGNM@CMakeStaticDataBuffer?5failed?5be@ DB 'CMakeStaticData'
	DB	'Buffer failed because sizeBytes was 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@NKDGEJEA@CMakeStaticDataBuffer?5failed?5be@
CONST	SEGMENT
??_C@_0DD@NKDGEJEA@CMakeStaticDataBuffer?5failed?5be@ DB 'CMakeStaticData'
	DB	'Buffer failed because name was NULL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IGGEADDO@CMakeStaticDataBuffer@
CONST	SEGMENT
??_C@_0BG@IGGEADDO@CMakeStaticDataBuffer@ DB 'CMakeStaticDataBuffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@KKHJLFON@CVertexDataBufferGetComponentCo@
CONST	SEGMENT
??_C@_0EH@KKHJLFON@CVertexDataBufferGetComponentCo@ DB 'CVertexDataBuffer'
	DB	'GetComponentCount failed bevause vdBuffer was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KEMFMAGO@CVertexDataBufferGetComponentCo@
CONST	SEGMENT
??_C@_0CD@KEMFMAGO@CVertexDataBufferGetComponentCo@ DB 'CVertexDataBuffer'
	DB	'GetComponentCount', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@NBHGEINM@CVertexDataBufferGetElementCoun@
CONST	SEGMENT
??_C@_0EF@NBHGEINM@CVertexDataBufferGetElementCoun@ DB 'CVertexDataBuffer'
	DB	'GetElementCount failed bevause vdBuffer was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CFKBNCJD@CVertexDataBufferGetElementCoun@
CONST	SEGMENT
??_C@_0CB@CFKBNCJD@CVertexDataBufferGetElementCoun@ DB 'CVertexDataBuffer'
	DB	'GetElementCount', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@NCNEEOCP@CVertexDataBufferSetElement?5fai@
CONST	SEGMENT
??_C@_0DN@NCNEEOCP@CVertexDataBufferSetElement?5fai@ DB 'CVertexDataBuffe'
	DB	'rSetElement failed bevause index was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@FDCMAMDA@CVertexDataBufferSetElement?5fai@
CONST	SEGMENT
??_C@_0DN@FDCMAMDA@CVertexDataBufferSetElement?5fai@ DB 'CVertexDataBuffe'
	DB	'rSetElement failed bevause inBuffer was NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@BIOCLIPO@CVertexDataBufferSetElement?5fai@
CONST	SEGMENT
??_C@_0EA@BIOCLIPO@CVertexDataBufferSetElement?5fai@ DB 'CVertexDataBuffe'
	DB	'rSetElement failed bevause vdBuffer was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@GMCHNLBM@CVertexDataBufferGetElement?5fai@
CONST	SEGMENT
??_C@_0DO@GMCHNLBM@CVertexDataBufferGetElement?5fai@ DB 'CVertexDataBuffe'
	DB	'rGetElement failed bevause outBuffer was NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@EHFCDKDO@CVertexDataBufferGetElement?5fai@
CONST	SEGMENT
??_C@_0EA@EHFCDKDO@CVertexDataBufferGetElement?5fai@ DB 'CVertexDataBuffe'
	DB	'rGetElement failed bevause vdBuffer was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LHMBODLJ@CVertexDataBufferGetElement@
CONST	SEGMENT
??_C@_0BM@LHMBODLJ@CVertexDataBufferGetElement@ DB 'CVertexDataBufferGetE'
	DB	'lement', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@NOPGNNDF@CDestroyVertexDataBuffer?5failed@
CONST	SEGMENT
??_C@_0EG@NOPGNNDF@CDestroyVertexDataBuffer?5failed@ DB 'CDestroyVertexDa'
	DB	'taBuffer failed because pVertexDataBuffer was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@FMEONNNG@CDestroyVertexDataBuffer?5failed@
CONST	SEGMENT
??_C@_0ED@FMEONNNG@CDestroyVertexDataBuffer?5failed@ DB 'CDestroyVertexDa'
	DB	'taBuffer failed because pVertexDataBuffer was NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EHGHEGAD@CDestroyVertexDataBuffer@
CONST	SEGMENT
??_C@_0BJ@EHGHEGAD@CDestroyVertexDataBuffer@ DB 'CDestroyVertexDataBuffer'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@PPFOMGJP@CMakeVertexDataBuffer?5failed?5be@
CONST	SEGMENT
??_C@_0ED@PPFOMGJP@CMakeVertexDataBuffer?5failed?5be@ DB 'CMakeVertexData'
	DB	'Buffer failed because elementComponents was too big', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@OKMKOHCB@CMakeVertexDataBuffer?5failed?5be@
CONST	SEGMENT
??_C@_0DN@OKMKOHCB@CMakeVertexDataBuffer?5failed?5be@ DB 'CMakeVertexData'
	DB	'Buffer failed because elementComponents was 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@BMBPHDAB@CMakeVertexDataBuffer?5failed?5be@
CONST	SEGMENT
??_C@_0DI@BMBPHDAB@CMakeVertexDataBuffer?5failed?5be@ DB 'CMakeVertexData'
	DB	'Buffer failed because elementCount was 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@NOLEMLOD@CMakeVertexDataBuffer?5failed?5be@
CONST	SEGMENT
??_C@_0DD@NOLEMLOD@CMakeVertexDataBuffer?5failed?5be@ DB 'CMakeVertexData'
	DB	'Buffer failed because name was NULL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IIKKEFIC@CMakeVertexDataBuffer@
CONST	SEGMENT
??_C@_0BG@IIKKEFIC@CMakeVertexDataBuffer@ DB 'CMakeVertexDataBuffer', 00H ; `string'
PUBLIC	CStaticDataBufferGetSizeBytes
PUBLIC	CStaticDataBufferUnmap
PUBLIC	CStaticDataBufferMap
PUBLIC	CDestroyStaticDataBuffer
PUBLIC	CMakeStaticDataBuffer
PUBLIC	CVertexDataBufferGetComponentCount
PUBLIC	CVertexDataBufferGetElementCount
PUBLIC	CVertexDataBufferSetElement
PUBLIC	CVertexDataBufferGetElement
PUBLIC	CDestroyVertexDataBuffer
PUBLIC	CMakeVertexDataBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$CStaticDataBufferGetSizeBytes DD imagerel $LN20
	DD	imagerel $LN20+293
	DD	imagerel $unwind$CStaticDataBufferGetSizeBytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CStaticDataBufferUnmap DD imagerel $LN23
	DD	imagerel $LN23+214
	DD	imagerel $unwind$CStaticDataBufferUnmap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CStaticDataBufferMap DD imagerel $LN20
	DD	imagerel $LN20+302
	DD	imagerel $unwind$CStaticDataBufferMap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CDestroyStaticDataBuffer DD imagerel $LN32
	DD	imagerel $LN32+570
	DD	imagerel $unwind$CDestroyStaticDataBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CMakeStaticDataBuffer DD imagerel $LN28
	DD	imagerel $LN28+326
	DD	imagerel $unwind$CMakeStaticDataBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$CMakeStaticDataBuffer DD imagerel $LN28+326
	DD	imagerel $LN28+426
	DD	imagerel $chain$2$CMakeStaticDataBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$CMakeStaticDataBuffer DD imagerel $LN28+426
	DD	imagerel $LN28+455
	DD	imagerel $chain$3$CMakeStaticDataBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$CMakeStaticDataBuffer DD imagerel $LN28+455
	DD	imagerel $LN28+540
	DD	imagerel $chain$4$CMakeStaticDataBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CVertexDataBufferGetComponentCount DD imagerel $LN20
	DD	imagerel $LN20+292
	DD	imagerel $unwind$CVertexDataBufferGetComponentCount
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CVertexDataBufferGetElementCount DD imagerel $LN20
	DD	imagerel $LN20+292
	DD	imagerel $unwind$CVertexDataBufferGetElementCount
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CVertexDataBufferSetElement DD imagerel $LN27
	DD	imagerel $LN27+328
	DD	imagerel $unwind$CVertexDataBufferSetElement
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$CVertexDataBufferSetElement DD imagerel $LN27+328
	DD	imagerel $LN27+380
	DD	imagerel $chain$1$CVertexDataBufferSetElement
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$CVertexDataBufferSetElement DD imagerel $LN27+380
	DD	imagerel $LN27+459
	DD	imagerel $chain$2$CVertexDataBufferSetElement
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CVertexDataBufferGetElement DD imagerel $LN26
	DD	imagerel $LN26+438
	DD	imagerel $unwind$CVertexDataBufferGetElement
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CDestroyVertexDataBuffer DD imagerel $LN26
	DD	imagerel $LN26+444
	DD	imagerel $unwind$CDestroyVertexDataBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CMakeVertexDataBuffer DD imagerel $LN40
	DD	imagerel $LN40+537
	DD	imagerel $unwind$CMakeVertexDataBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$CMakeVertexDataBuffer DD imagerel $LN40+537
	DD	imagerel $LN40+675
	DD	imagerel $chain$2$CMakeVertexDataBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$CMakeVertexDataBuffer DD imagerel $LN40+675
	DD	imagerel $LN40+758
	DD	imagerel $chain$3$CMakeVertexDataBuffer
;	COMDAT xdata
xdata	SEGMENT
$chain$3$CMakeVertexDataBuffer DD 020021H
	DD	0cf400H
	DD	imagerel $LN40
	DD	imagerel $LN40+537
	DD	imagerel $unwind$CMakeVertexDataBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$CMakeVertexDataBuffer DD 061421H
	DD	0cf414H
	DD	0b740fH
	DD	0a3405H
	DD	imagerel $LN40
	DD	imagerel $LN40+537
	DD	imagerel $unwind$CMakeVertexDataBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CMakeVertexDataBuffer DD 060d01H
	DD	0e009320dH
	DD	0c005d007H
	DD	050026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CDestroyVertexDataBuffer DD 064501H
	DD	063445H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CVertexDataBufferGetElement DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$CVertexDataBufferSetElement DD 021H
	DD	imagerel $LN27
	DD	imagerel $LN27+328
	DD	imagerel $unwind$CVertexDataBufferSetElement
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$CVertexDataBufferSetElement DD 040d21H
	DD	04740dH
	DD	066405H
	DD	imagerel $LN27
	DD	imagerel $LN27+328
	DD	imagerel $unwind$CVertexDataBufferSetElement
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CVertexDataBufferSetElement DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CVertexDataBufferGetElementCount DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CVertexDataBufferGetComponentCount DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$CMakeStaticDataBuffer DD 020021H
	DD	0ae400H
	DD	imagerel $LN28
	DD	imagerel $LN28+326
	DD	imagerel $unwind$CMakeStaticDataBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$CMakeStaticDataBuffer DD 040021H
	DD	0ae400H
	DD	097400H
	DD	imagerel $LN28
	DD	imagerel $LN28+326
	DD	imagerel $unwind$CMakeStaticDataBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$CMakeStaticDataBuffer DD 061421H
	DD	0ae414H
	DD	09740fH
	DD	083405H
	DD	imagerel $LN28
	DD	imagerel $LN28+326
	DD	imagerel $unwind$CMakeStaticDataBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CMakeStaticDataBuffer DD 060e01H
	DD	0b540eH
	DD	0f00a320eH
	DD	06006c008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CDestroyStaticDataBuffer DD 064501H
	DD	063445H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CStaticDataBufferMap DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CStaticDataBufferUnmap DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CStaticDataBufferGetSizeBytes DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
;	COMDAT CMakeVertexDataBuffer
_TEXT	SEGMENT
name$ = 80
elementCount$ = 88
elementComponents$ = 96
dataIn$ = 104
CMakeVertexDataBuffer PROC				; COMDAT

; 9    : 	UINT32 elementComponents, PFLOAT dataIn) {

$LN40:
	push	rbp
	push	rsi
	push	r12
	push	r13
	push	r14
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 9    : 	UINT32 elementComponents, PFLOAT dataIn) {

	mov	r12, r9
	mov	ebp, r8d
	mov	r14d, edx
	mov	rsi, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN11@CMakeVerte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN11@CMakeVerte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0BG@IIKKEFIC@CMakeVertexDataBuffer@
	lea	r13, OFFSET FLAT:_csmint
	mov	QWORD PTR [r13+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 10   : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 10   : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 11   : 
; 12   : 	if (name == NULL) {

	test	rsi, rsi
	jne	SHORT $LN2@CMakeVerte

; 13   : 		_CSyncLeaveErr(NULL, "CMakeVertexDataBuffer failed because name was NULL");

	lea	rcx, OFFSET FLAT:??_C@_0DD@NOLEMLOD@CMakeVertexDataBuffer?5failed?5be@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN16@CMakeVerte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN16@CMakeVerte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [r13+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 13   : 		_CSyncLeaveErr(NULL, "CMakeVertexDataBuffer failed because name was NULL");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 13   : 		_CSyncLeaveErr(NULL, "CMakeVertexDataBuffer failed because name was NULL");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 45   : }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	r13
	pop	r12
	pop	rsi
	pop	rbp
	ret	0
$LN2@CMakeVerte:

; 14   : 	}
; 15   : 	if (elementCount == 0) {

	test	r14d, r14d
	jne	SHORT $LN3@CMakeVerte

; 16   : 		_CSyncLeaveErr(NULL, "CMakeVertexDataBuffer failed because elementCount was 0");

	lea	rcx, OFFSET FLAT:??_C@_0DI@BMBPHDAB@CMakeVertexDataBuffer?5failed?5be@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN21@CMakeVerte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN21@CMakeVerte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [r13+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 16   : 		_CSyncLeaveErr(NULL, "CMakeVertexDataBuffer failed because elementCount was 0");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 16   : 		_CSyncLeaveErr(NULL, "CMakeVertexDataBuffer failed because elementCount was 0");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 45   : }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	r13
	pop	r12
	pop	rsi
	pop	rbp
	ret	0
$LN3@CMakeVerte:

; 17   : 	}
; 18   : 	if (elementComponents == 0) {

	test	ebp, ebp
	jne	SHORT $LN4@CMakeVerte

; 19   : 		_CSyncLeaveErr(NULL, "CMakeVertexDataBuffer failed because elementComponents was 0");

	lea	rcx, OFFSET FLAT:??_C@_0DN@OKMKOHCB@CMakeVertexDataBuffer?5failed?5be@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN26@CMakeVerte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN26@CMakeVerte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [r13+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 19   : 		_CSyncLeaveErr(NULL, "CMakeVertexDataBuffer failed because elementComponents was 0");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 19   : 		_CSyncLeaveErr(NULL, "CMakeVertexDataBuffer failed because elementComponents was 0");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 45   : }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	r13
	pop	r12
	pop	rsi
	pop	rbp
	ret	0
$LN4@CMakeVerte:

; 20   : 	}
; 21   : 	if (elementComponents > CSM_VERTEX_DATA_BUFFER_MAX_COMPONENTS) {

	cmp	ebp, 8
	jbe	SHORT $LN5@CMakeVerte

; 22   : 		_CSyncLeaveErr(NULL, "CMakeVertexDataBuffer failed because elementComponents was too big");

	lea	rcx, OFFSET FLAT:??_C@_0ED@PPFOMGJP@CMakeVertexDataBuffer?5failed?5be@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN31@CMakeVerte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN31@CMakeVerte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [r13+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 22   : 		_CSyncLeaveErr(NULL, "CMakeVertexDataBuffer failed because elementComponents was too big");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 22   : 		_CSyncLeaveErr(NULL, "CMakeVertexDataBuffer failed because elementComponents was too big");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 45   : }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	r13
	pop	r12
	pop	rsi
	pop	rbp
	ret	0
$LN5@CMakeVerte:
	mov	QWORD PTR [rsp+80], rbx

; 23   : 	}
; 24   : 	
; 25   : 	// allocate
; 26   : 	PCVertexDataBuffer vdBuffer = CInternalAlloc(sizeof(CVertexDataBuffer));

	mov	ecx, 24
	mov	QWORD PTR [rsp+88], rdi
	mov	QWORD PTR [rsp+96], r15
	call	CInternalAlloc
	mov	r15, rax

; 27   : 	
; 28   : 	// copy name
; 29   : 	const SIZE_T nameSize = strlen(name);

	mov	rbx, -1
	npad	4
$LL38@CMakeVerte:
	inc	rbx
	cmp	BYTE PTR [rsi+rbx], 0
	jne	SHORT $LL38@CMakeVerte

; 30   : 	vdBuffer->name = CInternalAlloc(nameSize + 1); // +1 for NULL

	lea	rcx, QWORD PTR [rbx+1]
	call	CInternalAlloc

; 31   : 	COPY_BYTES(name, vdBuffer->name, nameSize);

	mov	rcx, rbx
	mov	QWORD PTR [r15], rax
	mov	rdi, rax
	rep movsb

; 32   : 
; 33   : 	// init metadata
; 34   : 	vdBuffer->elementCount = elementCount;

	mov	DWORD PTR [r15+8], r14d

; 35   : 	vdBuffer->elementComponents = elementComponents;
; 36   : 
; 37   : 	// copy buffer
; 38   : 	const SIZE_T dataSizeBytes = elementCount * elementComponents * sizeof(FLOAT);

	imul	r14d, ebp
	mov	DWORD PTR [r15+12], ebp
	mov	ebx, r14d
	shl	rbx, 2

; 39   : 	vdBuffer->data = CInternalAlloc(dataSizeBytes);

	mov	rcx, rbx
	call	CInternalAlloc
	mov	QWORD PTR [r15+16], rax

; 40   : 	if (dataIn != NULL) {

	test	r12, r12
	je	SHORT $LN6@CMakeVerte

; 41   : 		COPY_BYTES(dataIn, vdBuffer->data, dataSizeBytes);

	mov	rdi, rax
	mov	rsi, r12
	mov	rcx, rbx
	rep movsb
$LN6@CMakeVerte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	mov	rdi, QWORD PTR [rsp+88]
	mov	rbx, QWORD PTR [rsp+80]
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN36@CMakeVerte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN36@CMakeVerte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [r13+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 44   : 	_CSyncLeave(vdBuffer);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 44   : 	_CSyncLeave(vdBuffer);

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rax, r15
	mov	r15, QWORD PTR [rsp+96]

; 45   : }

	add	rsp, 32					; 00000020H
	pop	r14
	pop	r13
	pop	r12
	pop	rsi
	pop	rbp
	ret	0
CMakeVertexDataBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
;	COMDAT CDestroyVertexDataBuffer
_TEXT	SEGMENT
pVertexDataBuffer$ = 48
CDestroyVertexDataBuffer PROC				; COMDAT

; 47   : CSMCALL BOOL	CDestroyVertexDataBuffer(PCHandle pVertexDataBuffer) {

$LN26:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 47   : CSMCALL BOOL	CDestroyVertexDataBuffer(PCHandle pVertexDataBuffer) {

	mov	rdi, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN8@CDestroyVe
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN8@CDestroyVe:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0BJ@EHGHEGAD@CDestroyVertexDataBuffer@
	mov	QWORD PTR [rsp+48], rbx
	lea	rsi, OFFSET FLAT:_csmint
	mov	QWORD PTR [rsi+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 48   : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 48   : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 49   : 
; 50   : 	if (pVertexDataBuffer == NULL) {

	test	rdi, rdi
	jne	SHORT $LN2@CDestroyVe

; 51   : 		_CSyncLeaveErr(FALSE, "CDestroyVertexDataBuffer failed because pVertexDataBuffer was NULL");

	lea	rcx, OFFSET FLAT:??_C@_0ED@FMEONNNG@CDestroyVertexDataBuffer?5failed@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN13@CDestroyVe
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN13@CDestroyVe:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	xor	ebx, ebx
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 51   : 		_CSyncLeaveErr(FALSE, "CDestroyVertexDataBuffer failed because pVertexDataBuffer was NULL");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rsi+rax*8+200], rbx

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 51   : 		_CSyncLeaveErr(FALSE, "CDestroyVertexDataBuffer failed because pVertexDataBuffer was NULL");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+48]

; 68   : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@CDestroyVe:

; 52   : 	}
; 53   : 
; 54   : 	PCVertexDataBuffer vdBuff = *pVertexDataBuffer;

	mov	rbx, QWORD PTR [rdi]

; 55   : 	if (vdBuff == NULL) {

	test	rbx, rbx
	jne	SHORT $LN3@CDestroyVe

; 56   : 		_CSyncLeaveErr(FALSE, "CDestroyVertexDataBuffer failed because pVertexDataBuffer was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0EG@NOPGNNDF@CDestroyVertexDataBuffer?5failed@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN18@CDestroyVe
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN18@CDestroyVe:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	xor	ebx, ebx
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 56   : 		_CSyncLeaveErr(FALSE, "CDestroyVertexDataBuffer failed because pVertexDataBuffer was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rsi+rax*8+200], rbx

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 56   : 		_CSyncLeaveErr(FALSE, "CDestroyVertexDataBuffer failed because pVertexDataBuffer was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+48]

; 68   : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@CDestroyVe:

; 57   : 	}
; 58   : 
; 59   : 	// free data
; 60   : 	CInternalFree(vdBuff->name);

	mov	rcx, QWORD PTR [rbx]
	call	CInternalFree

; 61   : 	CInternalFree(vdBuff->data);

	mov	rcx, QWORD PTR [rbx+16]
	call	CInternalFree

; 62   : 	CInternalFree(vdBuff);

	mov	rcx, rbx
	call	CInternalFree

; 63   : 
; 64   : 	// set handle to NULL
; 65   : 	*pVertexDataBuffer = NULL;

	xor	ebx, ebx
	mov	QWORD PTR [rdi], rbx
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN23@CDestroyVe
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN23@CDestroyVe:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rsi+rax*8+200], rbx
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 67   : 	_CSyncLeave(TRUE);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 67   : 	_CSyncLeave(TRUE);

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rbx, QWORD PTR [rsp+48]
	mov	eax, 1

; 68   : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CDestroyVertexDataBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
;	COMDAT CVertexDataBufferGetElement
_TEXT	SEGMENT
vdBuffer$ = 48
index$ = 56
outBuffer$ = 64
CVertexDataBufferGetElement PROC			; COMDAT

; 71   : 	PFLOAT outBuffer) {

$LN26:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 71   : 	PFLOAT outBuffer) {

	mov	rbx, r8
	mov	esi, edx
	mov	rdi, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN8@CVertexDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN8@CVertexDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0BM@LHMBODLJ@CVertexDataBufferGetElement@
	lea	rbp, OFFSET FLAT:_csmint
	mov	QWORD PTR [rbp+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 72   : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 72   : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 73   : 
; 74   : 	if (vdBuffer == NULL) {

	test	rdi, rdi
	jne	SHORT $LN2@CVertexDat

; 75   : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferGetElement failed bevause vdBuffer was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0EA@EHFCDKDO@CVertexDataBufferGetElement?5fai@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN13@CVertexDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN13@CVertexDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rbp+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 75   : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferGetElement failed bevause vdBuffer was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 75   : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferGetElement failed bevause vdBuffer was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	jmp	$LN1@CVertexDat
$LN2@CVertexDat:

; 76   : 	}
; 77   : 	if (outBuffer == NULL) {

	test	rbx, rbx
	jne	SHORT $LN3@CVertexDat

; 78   : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferGetElement failed bevause outBuffer was NULL");

	lea	rcx, OFFSET FLAT:??_C@_0DO@GMCHNLBM@CVertexDataBufferGetElement?5fai@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN18@CVertexDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN18@CVertexDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rbp+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 78   : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferGetElement failed bevause outBuffer was NULL");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 78   : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferGetElement failed bevause outBuffer was NULL");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	jmp	SHORT $LN1@CVertexDat
$LN3@CVertexDat:

; 79   : 	}
; 80   : 
; 81   : 	PCVertexDataBuffer vdBuff = vdBuffer;
; 82   : 
; 83   : 	// apply modulus to index so that it rolls over
; 84   : 	index = index % vdBuff->elementCount;
; 85   : 
; 86   : 	// get data ptr and write
; 87   : 	PBYTE dataBytes = vdBuff->data;
; 88   : 	SIZE_T elemSizeBytes = sizeof(FLOAT) * vdBuff->elementComponents;

	mov	ecx, DWORD PTR [rdi+12]
	mov	eax, esi
	xor	edx, edx
	shl	rcx, 2
	div	DWORD PTR [rdi+8]
	mov	esi, edx

; 89   : 	COPY_BYTES(

	imul	rsi, rcx
	add	rsi, QWORD PTR [rdi+16]
	mov	rdi, rbx
	rep movsb
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN23@CVertexDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN23@CVertexDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rbp+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 94   : 	_CSyncLeave(TRUE);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 94   : 	_CSyncLeave(TRUE);

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	eax, 1
$LN1@CVertexDat:

; 95   : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CVertexDataBufferGetElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
;	COMDAT CVertexDataBufferSetElement
_TEXT	SEGMENT
vdBuffer$ = 48
index$ = 56
inBuffer$ = 64
CVertexDataBufferSetElement PROC			; COMDAT

; 98   : 	PFLOAT inBuffer) {

$LN27:
	sub	rsp, 40					; 00000028H
	mov	rax, rcx

; 99   : 	if (vdBuffer == NULL) {

	test	rcx, rcx
	jne	SHORT $LN2@CVertexDat

; 100  : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferSetElement failed bevause vdBuffer was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0EA@BIOCLIPO@CVertexDataBufferSetElement?5fai@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN9@CVertexDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN9@CVertexDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	lea	rcx, OFFSET FLAT:_csmint
	mov	QWORD PTR [rcx+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 100  : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferSetElement failed bevause vdBuffer was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 100  : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferSetElement failed bevause vdBuffer was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 120  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN2@CVertexDat:

; 101  : 	}
; 102  : 	if (inBuffer == NULL) {

	test	r8, r8
	jne	SHORT $LN3@CVertexDat

; 103  : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferSetElement failed bevause inBuffer was NULL");

	lea	rcx, OFFSET FLAT:??_C@_0DN@FDCMAMDA@CVertexDataBufferSetElement?5fai@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN14@CVertexDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN14@CVertexDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	lea	rcx, OFFSET FLAT:_csmint
	mov	QWORD PTR [rcx+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 103  : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferSetElement failed bevause inBuffer was NULL");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 103  : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferSetElement failed bevause inBuffer was NULL");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 120  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN3@CVertexDat:

; 104  : 	}
; 105  : 
; 106  : 	PCVertexDataBuffer vdBuff = vdBuffer;
; 107  : 	if (index >= vdBuff->elementCount) {

	cmp	edx, DWORD PTR [rcx+8]
	jb	SHORT $LN4@CVertexDat

; 108  : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferSetElement failed bevause index was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0DN@NCNEEOCP@CVertexDataBufferSetElement?5fai@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN19@CVertexDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN19@CVertexDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	lea	rcx, OFFSET FLAT:_csmint
	mov	QWORD PTR [rcx+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 108  : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferSetElement failed bevause index was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 108  : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferSetElement failed bevause index was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 120  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@CVertexDat:

; 109  : 	}
; 110  : 
; 111  : 	// get data ptr and write
; 112  : 	PBYTE dataBytes = vdBuff->data;
; 113  : 	SIZE_T elemSizeBytes = sizeof(FLOAT) * vdBuff->elementComponents;

	mov	ecx, DWORD PTR [rcx+12]
	mov	QWORD PTR [rsp+48], rsi

; 114  : 	COPY_BYTES(

	mov	rsi, r8
	mov	QWORD PTR [rsp+32], rdi
	shl	rcx, 2
	mov	edi, edx
	imul	rdi, rcx
	add	rdi, QWORD PTR [rax+16]
	rep movsb
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	mov	rdi, QWORD PTR [rsp+32]
	mov	rsi, QWORD PTR [rsp+48]
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN24@CVertexDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN24@CVertexDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	lea	rcx, OFFSET FLAT:_csmint
	mov	QWORD PTR [rcx+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 119  : 	_CSyncLeave(TRUE);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 119  : 	_CSyncLeave(TRUE);

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	eax, 1

; 120  : }

	add	rsp, 40					; 00000028H
	ret	0
CVertexDataBufferSetElement ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
;	COMDAT CVertexDataBufferGetElementCount
_TEXT	SEGMENT
vdBuffer$ = 48
CVertexDataBufferGetElementCount PROC			; COMDAT

; 122  : CSMCALL UINT32	CVertexDataBufferGetElementCount(CHandle vdBuffer) {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 122  : CSMCALL UINT32	CVertexDataBufferGetElementCount(CHandle vdBuffer) {

	mov	rbx, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN7@CVertexDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN7@CVertexDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0CB@CFKBNCJD@CVertexDataBufferGetElementCoun@
	lea	rdi, OFFSET FLAT:_csmint
	mov	QWORD PTR [rdi+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 123  : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 123  : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 124  : 
; 125  : 	if (vdBuffer == NULL) {

	test	rbx, rbx
	jne	SHORT $LN2@CVertexDat

; 126  : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferGetElementCount failed bevause vdBuffer was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0EF@NBHGEINM@CVertexDataBufferGetElementCoun@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN12@CVertexDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN12@CVertexDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rdi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 126  : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferGetElementCount failed bevause vdBuffer was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 126  : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferGetElementCount failed bevause vdBuffer was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 132  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@CVertexDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN17@CVertexDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN17@CVertexDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rdi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 131  : 	_CSyncLeave(vdb->elementCount);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 131  : 	_CSyncLeave(vdb->elementCount);

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	eax, DWORD PTR [rbx+8]

; 132  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CVertexDataBufferGetElementCount ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
;	COMDAT CVertexDataBufferGetComponentCount
_TEXT	SEGMENT
vdBuffer$ = 48
CVertexDataBufferGetComponentCount PROC			; COMDAT

; 134  : CSMCALL UINT32	CVertexDataBufferGetComponentCount(CHandle vdBuffer) {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 134  : CSMCALL UINT32	CVertexDataBufferGetComponentCount(CHandle vdBuffer) {

	mov	rbx, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN7@CVertexDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN7@CVertexDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0CD@KEMFMAGO@CVertexDataBufferGetComponentCo@
	lea	rdi, OFFSET FLAT:_csmint
	mov	QWORD PTR [rdi+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 135  : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 135  : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 136  : 
; 137  : 	if (vdBuffer == NULL) {

	test	rbx, rbx
	jne	SHORT $LN2@CVertexDat

; 138  : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferGetComponentCount failed bevause vdBuffer was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0EH@KKHJLFON@CVertexDataBufferGetComponentCo@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN12@CVertexDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN12@CVertexDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rdi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 138  : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferGetComponentCount failed bevause vdBuffer was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 138  : 		_CSyncLeaveErr(FALSE, "CVertexDataBufferGetComponentCount failed bevause vdBuffer was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 144  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@CVertexDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN17@CVertexDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN17@CVertexDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rdi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 143  : 	_CSyncLeave(vdb->elementComponents);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 143  : 	_CSyncLeave(vdb->elementComponents);

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	eax, DWORD PTR [rbx+12]

; 144  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CVertexDataBufferGetComponentCount ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
;	COMDAT CMakeStaticDataBuffer
_TEXT	SEGMENT
name$ = 64
sizeBytes$ = 72
dataIn$ = 80
CMakeStaticDataBuffer PROC				; COMDAT

; 147  : 	PVOID dataIn) {

$LN28:
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r12
	push	r15
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 147  : 	PVOID dataIn) {

	mov	r15, r8
	mov	rbp, rdx
	mov	rsi, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN9@CMakeStati
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN9@CMakeStati:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0BG@IGGEADDO@CMakeStaticDataBuffer@
	lea	r12, OFFSET FLAT:_csmint
	mov	QWORD PTR [r12+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 148  : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 148  : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 149  : 
; 150  : 	if (name == NULL) {

	test	rsi, rsi
	jne	SHORT $LN2@CMakeStati

; 151  : 		_CSyncLeaveErr(NULL, "CMakeStaticDataBuffer failed because name was NULL");

	lea	rcx, OFFSET FLAT:??_C@_0DD@NKDGEJEA@CMakeStaticDataBuffer?5failed?5be@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN14@CMakeStati
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN14@CMakeStati:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [r12+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 151  : 		_CSyncLeaveErr(NULL, "CMakeStaticDataBuffer failed because name was NULL");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 151  : 		_CSyncLeaveErr(NULL, "CMakeStaticDataBuffer failed because name was NULL");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 174  : }

	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r12
	pop	rsi
	ret	0
$LN2@CMakeStati:

; 152  : 	}
; 153  : 	if (sizeBytes == 0) {

	test	rbp, rbp
	jne	SHORT $LN3@CMakeStati

; 154  : 		_CSyncLeaveErr(NULL, "CMakeStaticDataBuffer failed because sizeBytes was 0");

	lea	rcx, OFFSET FLAT:??_C@_0DF@GIPGPGNM@CMakeStaticDataBuffer?5failed?5be@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN19@CMakeStati
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN19@CMakeStati:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [r12+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 154  : 		_CSyncLeaveErr(NULL, "CMakeStaticDataBuffer failed because sizeBytes was 0");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 154  : 		_CSyncLeaveErr(NULL, "CMakeStaticDataBuffer failed because sizeBytes was 0");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 174  : }

	mov	rbp, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r12
	pop	rsi
	ret	0
$LN3@CMakeStati:
	mov	QWORD PTR [rsp+64], rbx

; 155  : 	}
; 156  : 
; 157  : 	PCStaticDataBuffer sdBuffer = CInternalAlloc(sizeof(CStaticDataBuffer));

	mov	ecx, 64					; 00000040H
	mov	QWORD PTR [rsp+72], rdi
	mov	QWORD PTR [rsp+80], r14
	call	CInternalAlloc

; 158  : 
; 159  : 	// init lock
; 160  : 	InitializeCriticalSection(&sdBuffer->mapLock);

	mov	rcx, rax
	mov	r14, rax
	call	QWORD PTR __imp_InitializeCriticalSection

; 161  : 
; 162  : 	// init name
; 163  : 	const SIZE_T nameSize = strlen(name);

	mov	rbx, -1
$LL26@CMakeStati:
	inc	rbx
	cmp	BYTE PTR [rsi+rbx], 0
	jne	SHORT $LL26@CMakeStati

; 164  : 	sdBuffer->name = CInternalAlloc(nameSize + 1); // +1 byte for NULL

	lea	rcx, QWORD PTR [rbx+1]
	call	CInternalAlloc

; 165  : 	COPY_BYTES(name, sdBuffer->name, nameSize);

	mov	rdi, rax
	mov	QWORD PTR [r14+40], rax
	mov	rcx, rbx
	rep movsb

; 166  : 
; 167  : 	// init data
; 168  : 	sdBuffer->sizeBytes = sizeBytes;
; 169  : 	sdBuffer->data = CInternalAlloc(sizeBytes);

	mov	rcx, rbp
	mov	QWORD PTR [r14+48], rbp
	call	CInternalAlloc
	mov	rbx, QWORD PTR [rsp+64]
	mov	QWORD PTR [r14+56], rax

; 170  : 	if (dataIn != NULL)

	test	r15, r15
	je	SHORT $LN4@CMakeStati

; 171  : 		COPY_BYTES(dataIn, sdBuffer->data, sizeBytes);

	mov	rdi, rax
	mov	rsi, r15
	mov	rcx, rbp
	rep movsb
$LN4@CMakeStati:
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	mov	rdi, QWORD PTR [rsp+72]
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN24@CMakeStati
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN24@CMakeStati:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [r12+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 173  : 	_CSyncLeave(sdBuffer);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 173  : 	_CSyncLeave(sdBuffer);

	call	QWORD PTR __imp_LeaveCriticalSection

; 174  : }

	mov	rbp, QWORD PTR [rsp+88]
	mov	rax, r14
	mov	r14, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r12
	pop	rsi
	ret	0
CMakeStaticDataBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
;	COMDAT CDestroyStaticDataBuffer
_TEXT	SEGMENT
pStaticDataBuffer$ = 48
CDestroyStaticDataBuffer PROC				; COMDAT

; 176  : CSMCALL BOOL	CDestroyStaticDataBuffer(PCHandle pStaticDataBuffer) {

$LN32:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 176  : CSMCALL BOOL	CDestroyStaticDataBuffer(PCHandle pStaticDataBuffer) {

	mov	rdi, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN9@CDestroySt
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN9@CDestroySt:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0BJ@EJKJAALP@CDestroyStaticDataBuffer@
	mov	QWORD PTR [rsp+48], rbx
	lea	rsi, OFFSET FLAT:_csmint
	mov	QWORD PTR [rsi+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 177  : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 177  : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 178  : 
; 179  : 	if (pStaticDataBuffer == NULL) {

	test	rdi, rdi
	jne	SHORT $LN2@CDestroySt

; 180  : 		_CSyncLeaveErr(FALSE, "CDestroyStaticDataBuffer failed because pStaticDataBuffer was NULL");

	lea	rcx, OFFSET FLAT:??_C@_0ED@LPIAHPOE@CDestroyStaticDataBuffer?5failed@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN14@CDestroySt
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN14@CDestroySt:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	xor	ebx, ebx
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 180  : 		_CSyncLeaveErr(FALSE, "CDestroyStaticDataBuffer failed because pStaticDataBuffer was NULL");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rsi+rax*8+200], rbx

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 180  : 		_CSyncLeaveErr(FALSE, "CDestroyStaticDataBuffer failed because pStaticDataBuffer was NULL");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+48]

; 202  : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@CDestroySt:

; 181  : 	}
; 182  : 
; 183  : 	PCStaticDataBuffer sdBuff = *pStaticDataBuffer;

	mov	rbx, QWORD PTR [rdi]

; 184  : 	if (sdBuff == NULL) {

	test	rbx, rbx
	jne	SHORT $LN3@CDestroySt

; 185  : 		_CSyncLeaveErr(FALSE, "CDestroyStaticDataBuffer failed because pStaticDataBuffer was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0EG@BJPENNPE@CDestroyStaticDataBuffer?5failed@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN19@CDestroySt
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN19@CDestroySt:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	xor	ebx, ebx
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 185  : 		_CSyncLeaveErr(FALSE, "CDestroyStaticDataBuffer failed because pStaticDataBuffer was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rsi+rax*8+200], rbx

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 185  : 		_CSyncLeaveErr(FALSE, "CDestroyStaticDataBuffer failed because pStaticDataBuffer was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+48]

; 202  : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@CDestroySt:

; 186  : 	}
; 187  : 
; 188  : 	if (TryEnterCriticalSection(&sdBuff->mapLock) == FALSE) {

	mov	rcx, rbx
	call	QWORD PTR __imp_TryEnterCriticalSection
	test	eax, eax
	jne	SHORT $LN4@CDestroySt

; 189  : 		_CSyncLeaveErr(FALSE, "CDestroyStaticDataBuffer failed because buffer is currently mapped");

	lea	rcx, OFFSET FLAT:??_C@_0ED@LMOEJCNL@CDestroyStaticDataBuffer?5failed@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN24@CDestroySt
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN24@CDestroySt:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	xor	ebx, ebx
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 189  : 		_CSyncLeaveErr(FALSE, "CDestroyStaticDataBuffer failed because buffer is currently mapped");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rsi+rax*8+200], rbx

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 189  : 		_CSyncLeaveErr(FALSE, "CDestroyStaticDataBuffer failed because buffer is currently mapped");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	mov	rbx, QWORD PTR [rsp+48]

; 202  : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@CDestroySt:

; 190  : 	}
; 191  : 
; 192  : 	// free data
; 193  : 	DeleteCriticalSection(&sdBuff->mapLock);

	mov	rcx, rbx
	call	QWORD PTR __imp_DeleteCriticalSection

; 194  : 	CInternalFree(sdBuff->name);

	mov	rcx, QWORD PTR [rbx+40]
	call	CInternalFree

; 195  : 	CInternalFree(sdBuff->data);

	mov	rcx, QWORD PTR [rbx+56]
	call	CInternalFree

; 196  : 	CInternalFree(sdBuff);

	mov	rcx, rbx
	call	CInternalFree

; 197  : 
; 198  : 	// set handle to NULL
; 199  : 	*pStaticDataBuffer = NULL;

	xor	ebx, ebx
	mov	QWORD PTR [rdi], rbx
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN29@CDestroySt
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN29@CDestroySt:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rsi+rax*8+200], rbx
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 201  : 	_CSyncLeave(TRUE);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 201  : 	_CSyncLeave(TRUE);

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rbx, QWORD PTR [rsp+48]
	mov	eax, 1

; 202  : }

	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CDestroyStaticDataBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
;	COMDAT CStaticDataBufferMap
_TEXT	SEGMENT
sdBuffer$ = 48
CStaticDataBufferMap PROC				; COMDAT

; 204  : CSMCALL PVOID	CStaticDataBufferMap(CHandle sdBuffer) {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 204  : CSMCALL PVOID	CStaticDataBufferMap(CHandle sdBuffer) {

	mov	rbx, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN7@CStaticDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN7@CStaticDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0BF@EFOJFIGE@CStaticDataBufferMap@
	lea	rdi, OFFSET FLAT:_csmint
	mov	QWORD PTR [rdi+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 205  : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 205  : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 206  : 
; 207  : 	if (sdBuffer == NULL) {

	test	rbx, rbx
	jne	SHORT $LN2@CStaticDat

; 208  : 		_CSyncLeaveErr(NULL, "CStaticDataBufferMap failed because sdBuffer was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0DJ@LBBNFDCP@CStaticDataBufferMap?5failed?5bec@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN12@CStaticDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN12@CStaticDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rdi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 208  : 		_CSyncLeaveErr(NULL, "CStaticDataBufferMap failed because sdBuffer was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 208  : 		_CSyncLeaveErr(NULL, "CStaticDataBufferMap failed because sdBuffer was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 215  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@CStaticDat:

; 209  : 	}
; 210  : 
; 211  : 	PCStaticDataBuffer sdBuff = sdBuffer;
; 212  : 	EnterCriticalSection(&sdBuff->mapLock); // lock data

	mov	rcx, rbx
	call	QWORD PTR __imp_EnterCriticalSection
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN17@CStaticDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN17@CStaticDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rdi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 214  : 	_CSyncLeave(sdBuff->data);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 214  : 	_CSyncLeave(sdBuff->data);

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rax, QWORD PTR [rbx+56]

; 215  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CStaticDataBufferMap ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
;	COMDAT CStaticDataBufferUnmap
_TEXT	SEGMENT
sdBuffer$ = 48
CStaticDataBufferUnmap PROC				; COMDAT

; 217  : CSMCALL void	CStaticDataBufferUnmap(CHandle sdBuffer) {

$LN23:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 217  : CSMCALL void	CStaticDataBufferUnmap(CHandle sdBuffer) {

	mov	rbx, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN7@CStaticDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN7@CStaticDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0BH@MNKNHCAI@CStaticDataBufferUnmap@
	lea	rdi, OFFSET FLAT:_csmint
	mov	QWORD PTR [rdi+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 218  : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 218  : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 219  : 
; 220  : 	if (sdBuffer == NULL) {

	test	rbx, rbx
	jne	SHORT $LN2@CStaticDat

; 221  : 		_CSyncLeaveErr(NULL, "CStaticDataBufferUnmap failed because sdBuffer was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0DL@NCNMFMIH@CStaticDataBufferUnmap?5failed?5b@
	call	CInternalSetLastError
	jmp	SHORT $LN21@CStaticDat
$LN2@CStaticDat:

; 222  : 	}
; 223  : 
; 224  : 	PCStaticDataBuffer sdBuff = sdBuffer;
; 225  : 	LeaveCriticalSection(&sdBuff->mapLock); // lock data

	mov	rcx, rbx
	call	QWORD PTR __imp_LeaveCriticalSection
$LN21@CStaticDat:

; 226  : 
; 227  : 	_CSyncLeave(NULL);
; 228  : }

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN17@CStaticDat
	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN17@CStaticDat:
	mov	QWORD PTR [rdi+rax*8+200], 0
	lea	rcx, OFFSET FLAT:_csmint+32
	dec	DWORD PTR _csmint+1224
	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CStaticDataBufferUnmap ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_buffer.c
;	COMDAT CStaticDataBufferGetSizeBytes
_TEXT	SEGMENT
sdBuffer$ = 48
CStaticDataBufferGetSizeBytes PROC			; COMDAT

; 230  : CSMCALL SIZE_T	CStaticDataBufferGetSizeBytes(CHandle sdBuffer) {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 230  : CSMCALL SIZE_T	CStaticDataBufferGetSizeBytes(CHandle sdBuffer) {

	mov	rbx, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN7@CStaticDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN7@CStaticDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0BO@JJJNLHFJ@CStaticDataBufferGetSizeBytes@
	lea	rdi, OFFSET FLAT:_csmint
	mov	QWORD PTR [rdi+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 231  : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 231  : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 232  : 
; 233  : 	if (sdBuffer == NULL) {

	test	rbx, rbx
	jne	SHORT $LN2@CStaticDat

; 234  : 		_CSyncLeaveErr(ZERO, "CStaticDataBufferGetSizeBytes failed because sdBuffer was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0EC@JJMCHMPB@CStaticDataBufferGetSizeBytes?5f@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN12@CStaticDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN12@CStaticDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rdi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 234  : 		_CSyncLeaveErr(ZERO, "CStaticDataBufferGetSizeBytes failed because sdBuffer was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 234  : 		_CSyncLeaveErr(ZERO, "CStaticDataBufferGetSizeBytes failed because sdBuffer was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 240  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@CStaticDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN17@CStaticDat
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN17@CStaticDat:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rdi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 239  : 	_CSyncLeave(sdBuff->sizeBytes);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_buffer.c

; 239  : 	_CSyncLeave(sdBuff->sizeBytes);

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rax, QWORD PTR [rbx+48]

; 240  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CStaticDataBufferGetSizeBytes ENDP
_TEXT	ENDS
END
