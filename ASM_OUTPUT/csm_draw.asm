; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30148.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BB@PCMBDCPA@CMakeDrawContext@		; `string'
PUBLIC	??_C@_0DJ@EIKFGPFD@CMakeDrawContext?5failed?5because@ ; `string'
PUBLIC	??_C@_0BE@HOGEHINH@CDestroyDrawContext@		; `string'
PUBLIC	??_C@_0DL@LFGDIGNN@CDestroyDrawContext?5failed?5beca@ ; `string'
PUBLIC	??_C@_0BJ@EAOHDOEJ@CDrawContextSetDrawInput@	; `string'
PUBLIC	??_C@_0EA@DJLGMIMC@CDrawContextSetDrawInput?5failed@ ; `string'
PUBLIC	??_C@_0DM@MDGIDHBK@CDrawContextSetDrawInput?5failed@ ; `string'
PUBLIC	??_C@_0BJ@DEFJPCAF@CDrawContextGetDrawInput@	; `string'
PUBLIC	??_C@_0EA@GPIOOBCC@CDrawContextGetDrawInput?5failed@ ; `string'
PUBLIC	??_C@_0DM@FIFDEFCI@CDrawContextGetDrawInput?5failed@ ; `string'
PUBLIC	??_C@_0DK@LPJBMIHJ@CDrawContextGetDrawInput?5failed@ ; `string'
PUBLIC	??_C@_0CC@IAIDGGOF@CDrawContextGetDrawInputSizeByt@ ; `string'
PUBLIC	??_C@_0EJ@PEJJEMJL@CDrawContextGetDrawInputSizeByt@ ; `string'
PUBLIC	??_C@_0EF@LNECBJCB@CDrawContextGetDrawInputSizeByt@ ; `string'
PUBLIC	??_C@_0BO@CBAHBNCM@CDrawContextGetLastDrawTimeMS@ ; `string'
PUBLIC	??_C@_0EF@ENLNFODN@CDrawContextGetLastDrawTimeMS?5f@ ; `string'
PUBLIC	??_C@_0P@FKLLMFGP@CDrawInstanced@		; `string'
PUBLIC	??_C@_0DG@CIBDKAFG@CDrawInstanced?5failed?5because?5d@ ; `string'
PUBLIC	??_C@_0DB@INGALEIM@CDrawInstanced?5failed?5because?5r@ ; `string'
PUBLIC	??_C@_0DC@FAHJIAKO@CDrawInstanced?5failed?5because?5i@ ; `string'
PUBLIC	??_C@_0DB@OMLAGJKB@Bad?5material?5state?4?5No?5material@ ; `string'
EXTRN	__imp_QueryPerformanceCounter:PROC
;	COMDAT ??_C@_0DB@OMLAGJKB@Bad?5material?5state?4?5No?5material@
CONST	SEGMENT
??_C@_0DB@OMLAGJKB@Bad?5material?5state?4?5No?5material@ DB 'Bad material'
	DB	' state. No materials exist in class.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@FAHJIAKO@CDrawInstanced?5failed?5because?5i@
CONST	SEGMENT
??_C@_0DC@FAHJIAKO@CDrawInstanced?5failed?5because?5i@ DB 'CDrawInstanced'
	DB	' failed because instanceCount was 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@INGALEIM@CDrawInstanced?5failed?5because?5r@
CONST	SEGMENT
??_C@_0DB@INGALEIM@CDrawInstanced?5failed?5because?5r@ DB 'CDrawInstanced'
	DB	' failed because rClass was invalid', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@CIBDKAFG@CDrawInstanced?5failed?5because?5d@
CONST	SEGMENT
??_C@_0DG@CIBDKAFG@CDrawInstanced?5failed?5because?5d@ DB 'CDrawInstanced'
	DB	' failed because drawContext was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FKLLMFGP@CDrawInstanced@
CONST	SEGMENT
??_C@_0P@FKLLMFGP@CDrawInstanced@ DB 'CDrawInstanced', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@ENLNFODN@CDrawContextGetLastDrawTimeMS?5f@
CONST	SEGMENT
??_C@_0EF@ENLNFODN@CDrawContextGetLastDrawTimeMS?5f@ DB 'CDrawContextGetL'
	DB	'astDrawTimeMS failed because drawContext was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CBAHBNCM@CDrawContextGetLastDrawTimeMS@
CONST	SEGMENT
??_C@_0BO@CBAHBNCM@CDrawContextGetLastDrawTimeMS@ DB 'CDrawContextGetLast'
	DB	'DrawTimeMS', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@LNECBJCB@CDrawContextGetDrawInputSizeByt@
CONST	SEGMENT
??_C@_0EF@LNECBJCB@CDrawContextGetDrawInputSizeByt@ DB 'CDrawContextGetDr'
	DB	'awInputSizeBytes failed because inputID was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@PEJJEMJL@CDrawContextGetDrawInputSizeByt@
CONST	SEGMENT
??_C@_0EJ@PEJJEMJL@CDrawContextGetDrawInputSizeByt@ DB 'CDrawContextGetDr'
	DB	'awInputSizeBytes failed because drawContext was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IAIDGGOF@CDrawContextGetDrawInputSizeByt@
CONST	SEGMENT
??_C@_0CC@IAIDGGOF@CDrawContextGetDrawInputSizeByt@ DB 'CDrawContextGetDr'
	DB	'awInputSizeBytes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@LPJBMIHJ@CDrawContextGetDrawInput?5failed@
CONST	SEGMENT
??_C@_0DK@LPJBMIHJ@CDrawContextGetDrawInput?5failed@ DB 'CDrawContextGetD'
	DB	'rawInput failed because outBytes was NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@FIFDEFCI@CDrawContextGetDrawInput?5failed@
CONST	SEGMENT
??_C@_0DM@FIFDEFCI@CDrawContextGetDrawInput?5failed@ DB 'CDrawContextGetD'
	DB	'rawInput failed because inputID was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@GPIOOBCC@CDrawContextGetDrawInput?5failed@
CONST	SEGMENT
??_C@_0EA@GPIOOBCC@CDrawContextGetDrawInput?5failed@ DB 'CDrawContextGetD'
	DB	'rawInput failed because drawContext was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DEFJPCAF@CDrawContextGetDrawInput@
CONST	SEGMENT
??_C@_0BJ@DEFJPCAF@CDrawContextGetDrawInput@ DB 'CDrawContextGetDrawInput'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@MDGIDHBK@CDrawContextSetDrawInput?5failed@
CONST	SEGMENT
??_C@_0DM@MDGIDHBK@CDrawContextSetDrawInput?5failed@ DB 'CDrawContextSetD'
	DB	'rawInput failed because inputID was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@DJLGMIMC@CDrawContextSetDrawInput?5failed@
CONST	SEGMENT
??_C@_0EA@DJLGMIMC@CDrawContextSetDrawInput?5failed@ DB 'CDrawContextSetD'
	DB	'rawInput failed because drawContext was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EAOHDOEJ@CDrawContextSetDrawInput@
CONST	SEGMENT
??_C@_0BJ@EAOHDOEJ@CDrawContextSetDrawInput@ DB 'CDrawContextSetDrawInput'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@LFGDIGNN@CDestroyDrawContext?5failed?5beca@
CONST	SEGMENT
??_C@_0DL@LFGDIGNN@CDestroyDrawContext?5failed?5beca@ DB 'CDestroyDrawCon'
	DB	'text failed because drawContext was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@HOGEHINH@CDestroyDrawContext@
CONST	SEGMENT
??_C@_0BE@HOGEHINH@CDestroyDrawContext@ DB 'CDestroyDrawContext', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@EIKFGPFD@CMakeDrawContext?5failed?5because@
CONST	SEGMENT
??_C@_0DJ@EIKFGPFD@CMakeDrawContext?5failed?5because@ DB 'CMakeDrawContex'
	DB	't failed because renderBuffer was invalid', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PCMBDCPA@CMakeDrawContext@
CONST	SEGMENT
??_C@_0BB@PCMBDCPA@CMakeDrawContext@ DB 'CMakeDrawContext', 00H ; `string'
PUBLIC	CDrawInstanced
PUBLIC	CDraw
PUBLIC	CDrawContextGetLastDrawTimeMS
PUBLIC	CDrawContextGetDrawInputSizeBytes
PUBLIC	CDrawContextGetDrawInput
PUBLIC	CDrawContextSetDrawInput
PUBLIC	CDestroyDrawContext
PUBLIC	CMakeDrawContext
;	COMDAT pdata
pdata	SEGMENT
$pdata$CDrawInstanced DD imagerel $LN831
	DD	imagerel $LN831+441
	DD	imagerel $unwind$CDrawInstanced
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$CDrawInstanced DD imagerel $LN831+441
	DD	imagerel $LN831+474
	DD	imagerel $chain$1$CDrawInstanced
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$CDrawInstanced DD imagerel $LN831+474
	DD	imagerel $LN831+1207
	DD	imagerel $chain$3$CDrawInstanced
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$CDrawInstanced DD imagerel $LN831+1207
	DD	imagerel $LN831+1273
	DD	imagerel $chain$4$CDrawInstanced
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$CDrawInstanced DD imagerel $LN831+1273
	DD	imagerel $LN831+1369
	DD	imagerel $chain$5$CDrawInstanced
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CDrawContextGetLastDrawTimeMS DD imagerel $LN20
	DD	imagerel $LN20+296
	DD	imagerel $unwind$CDrawContextGetLastDrawTimeMS
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CDrawContextGetDrawInputSizeBytes DD imagerel $LN26
	DD	imagerel $LN26+426
	DD	imagerel $unwind$CDrawContextGetDrawInputSizeBytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CDrawContextGetDrawInput DD imagerel $LN32
	DD	imagerel $LN32+526
	DD	imagerel $unwind$CDrawContextGetDrawInput
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CDrawContextSetDrawInput DD imagerel $LN36
	DD	imagerel $LN36+479
	DD	imagerel $unwind$CDrawContextSetDrawInput
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CDestroyDrawContext DD imagerel $LN28
	DD	imagerel $LN28+203
	DD	imagerel $unwind$CDestroyDrawContext
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$CDestroyDrawContext DD imagerel $LN28+203
	DD	imagerel $LN28+278
	DD	imagerel $chain$1$CDestroyDrawContext
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$CDestroyDrawContext DD imagerel $LN28+278
	DD	imagerel $LN28+356
	DD	imagerel $chain$2$CDestroyDrawContext
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CMakeDrawContext DD imagerel $LN20
	DD	imagerel $LN20+319
	DD	imagerel $unwind$CMakeDrawContext
;	COMDAT xdata
xdata	SEGMENT
$unwind$CMakeDrawContext DD 06d501H
	DD	0674d5H
	DD	07340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$CDestroyDrawContext DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+203
	DD	imagerel $unwind$CDestroyDrawContext
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$CDestroyDrawContext DD 040e21H
	DD	07740eH
	DD	063405H
	DD	imagerel $LN28
	DD	imagerel $LN28+203
	DD	imagerel $unwind$CDestroyDrawContext
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CDestroyDrawContext DD 040a01H
	DD	08540aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CDrawContextSetDrawInput DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CDrawContextGetDrawInput DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CDrawContextGetDrawInputSizeBytes DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CDrawContextGetLastDrawTimeMS DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$CDrawInstanced DD 021H
	DD	imagerel $LN831
	DD	imagerel $LN831+441
	DD	imagerel $unwind$CDrawInstanced
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$CDrawInstanced DD 021H
	DD	imagerel $LN831+441
	DD	imagerel $LN831+474
	DD	imagerel $chain$1$CDrawInstanced
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$CDrawInstanced DD 041021H
	DD	012f410H
	DD	01bd408H
	DD	imagerel $LN831+441
	DD	imagerel $LN831+474
	DD	imagerel $chain$1$CDrawInstanced
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$CDrawInstanced DD 041221H
	DD	01ac412H
	DD	0197408H
	DD	imagerel $LN831
	DD	imagerel $LN831+441
	DD	imagerel $unwind$CDrawInstanced
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CDrawInstanced DD 061f19H
	DD	013010dH
	DD	06004e006H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	080H
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
;	COMDAT CMakeDrawContext
_TEXT	SEGMENT
renderBuffer$ = 48
CMakeDrawContext PROC					; COMDAT

; 11   : CSMCALL CHandle CMakeDrawContext(CHandle renderBuffer) {

$LN20:
	mov	QWORD PTR [rsp+16], rbx
	push	rsi
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 11   : CSMCALL CHandle CMakeDrawContext(CHandle renderBuffer) {

	mov	rbx, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN7@CMakeDrawC
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN7@CMakeDrawC:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0BB@PCMBDCPA@CMakeDrawContext@
	lea	rsi, OFFSET FLAT:_csmint
	mov	QWORD PTR [rsi+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 12   : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 12   : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 13   : 	if (renderBuffer == NULL) {

	test	rbx, rbx
	jne	SHORT $LN2@CMakeDrawC

; 14   : 		_CSyncLeaveErr(NULL, "CMakeDrawContext failed because renderBuffer was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0DJ@EIKFGPFD@CMakeDrawContext?5failed?5because@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN12@CMakeDrawC
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN12@CMakeDrawC:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rsi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 14   : 		_CSyncLeaveErr(NULL, "CMakeDrawContext failed because renderBuffer was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 14   : 		_CSyncLeaveErr(NULL, "CMakeDrawContext failed because renderBuffer was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 21   : }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN2@CMakeDrawC:

; 15   : 	}
; 16   : 
; 17   : 	PCDrawContext dc = CInternalAlloc(sizeof(CDrawContext));

	mov	ecx, 528				; 00000210H
	mov	QWORD PTR [rsp+48], rdi
	call	CInternalAlloc
	mov	rdi, rax

; 18   : 	dc->renderBuffer = renderBuffer;

	mov	QWORD PTR [rax], rbx
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	ecx, DWORD PTR _csmint+1224
	cmp	ecx, 128				; 00000080H
	jb	SHORT $LN17@CMakeDrawC
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	ecx, DWORD PTR _csmint+1224
$LN17@CMakeDrawC:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rsi+rcx*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 20   : 	_CSyncLeave(dc);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 20   : 	_CSyncLeave(dc);

	call	QWORD PTR __imp_LeaveCriticalSection

; 21   : }

	mov	rbx, QWORD PTR [rsp+56]
	mov	rax, rdi
	mov	rdi, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
CMakeDrawContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
;	COMDAT CDestroyDrawContext
_TEXT	SEGMENT
drawContext$ = 48
CDestroyDrawContext PROC				; COMDAT

; 23   : CSMCALL BOOL	CDestroyDrawContext(CHandle drawContext) {

$LN28:
	mov	QWORD PTR [rsp+24], rbp
	push	rsi
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 23   : CSMCALL BOOL	CDestroyDrawContext(CHandle drawContext) {

	mov	rsi, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN11@CDestroyDr
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN11@CDestroyDr:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0BE@HOGEHINH@CDestroyDrawContext@
	lea	rbp, OFFSET FLAT:_csmint
	mov	QWORD PTR [rbp+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 24   : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 24   : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 25   : 	if (drawContext == NULL) {

	test	rsi, rsi
	jne	SHORT $LN5@CDestroyDr

; 26   : 		_CSyncLeaveErr(FALSE, "CDestroyDrawContext failed because drawContext was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0DL@LFGDIGNN@CDestroyDrawContext?5failed?5beca@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN16@CDestroyDr
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN16@CDestroyDr:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rbp+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 26   : 		_CSyncLeaveErr(FALSE, "CDestroyDrawContext failed because drawContext was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 26   : 		_CSyncLeaveErr(FALSE, "CDestroyDrawContext failed because drawContext was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 42   : }

	mov	rbp, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
$LN5@CDestroyDr:
	mov	QWORD PTR [rsp+48], rbx

; 27   : 	}
; 28   : 
; 29   : 	PCDrawContext context = drawContext;

	lea	rbx, QWORD PTR [rsi+16]
	mov	QWORD PTR [rsp+56], rdi
	mov	edi, 32					; 00000020H
	npad	2
$LL4@CDestroyDr:

; 33   : 		PCDrawInput input = context->inputs + inputID;
; 34   : 		if (input->pData != NULL)

	mov	rcx, QWORD PTR [rbx]
	test	rcx, rcx
	je	SHORT $LN2@CDestroyDr

; 35   : 			CInternalFree(input->pData);

	call	CInternalFree
$LN2@CDestroyDr:

; 30   : 
; 31   : 	// free all input data
; 32   : 	for (UINT32 inputID = 0; inputID < CSM_MAX_DRAW_INPUTS; inputID++) {

	add	rbx, 16
	sub	rdi, 1
	jne	SHORT $LL4@CDestroyDr

; 36   : 	}
; 37   : 
; 38   : 	// free dc
; 39   : 	CInternalFree(context);

	mov	rcx, rsi
	call	CInternalFree
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	mov	rdi, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN21@CDestroyDr
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN21@CDestroyDr:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rbp+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 41   : 	_CSyncLeave(TRUE);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 41   : 	_CSyncLeave(TRUE);

	call	QWORD PTR __imp_LeaveCriticalSection

; 42   : }

	mov	rbp, QWORD PTR [rsp+64]
	mov	eax, 1
	add	rsp, 32					; 00000020H
	pop	rsi
	ret	0
CDestroyDrawContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
;	COMDAT CDrawContextSetDrawInput
_TEXT	SEGMENT
drawContext$ = 48
inputID$ = 56
inBytes$ = 64
size$ = 72
CDrawContextSetDrawInput PROC				; COMDAT

; 44   : CSMCALL	CHandle	CDrawContextSetDrawInput(CHandle drawContext, UINT32 inputID, PVOID inBytes, SIZE_T size) {

$LN36:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 44   : CSMCALL	CHandle	CDrawContextSetDrawInput(CHandle drawContext, UINT32 inputID, PVOID inBytes, SIZE_T size) {

	mov	rbx, r9
	mov	edi, edx
	mov	rbp, r8
	mov	rsi, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN10@CDrawConte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN10@CDrawConte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0BJ@EAOHDOEJ@CDrawContextSetDrawInput@
	lea	r14, OFFSET FLAT:_csmint
	mov	QWORD PTR [r14+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 45   : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 45   : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 46   : 	if (drawContext == NULL) {

	test	rsi, rsi
	jne	SHORT $LN2@CDrawConte

; 47   : 		_CSyncLeaveErr(FALSE, "CDrawContextSetDrawInput failed because drawContext was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0EA@DJLGMIMC@CDrawContextSetDrawInput?5failed@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN15@CDrawConte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN15@CDrawConte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [r14+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 47   : 		_CSyncLeaveErr(FALSE, "CDrawContextSetDrawInput failed because drawContext was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 47   : 		_CSyncLeaveErr(FALSE, "CDrawContextSetDrawInput failed because drawContext was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	jmp	$LN1@CDrawConte
$LN2@CDrawConte:

; 48   : 	}
; 49   : 	if (inputID >= CSM_MAX_DRAW_INPUTS) {

	cmp	edi, 32					; 00000020H
	jb	SHORT $LN3@CDrawConte

; 50   : 		_CSyncLeaveErr(FALSE, "CDrawContextSetDrawInput failed because inputID was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0DM@MDGIDHBK@CDrawContextSetDrawInput?5failed@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN20@CDrawConte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN20@CDrawConte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [r14+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 50   : 		_CSyncLeaveErr(FALSE, "CDrawContextSetDrawInput failed because inputID was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 50   : 		_CSyncLeaveErr(FALSE, "CDrawContextSetDrawInput failed because inputID was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	jmp	$LN1@CDrawConte
$LN3@CDrawConte:

; 51   : 	}
; 52   : 
; 53   : 	PCDrawContext context = drawContext;
; 54   : 	PCDrawInput	  input = context->inputs + inputID;

	add	rdi, rdi

; 55   : 	
; 56   : 	// free existing data if needed
; 57   : 	if (input->pData != NULL)

	mov	rcx, QWORD PTR [rsi+rdi*8+16]
	test	rcx, rcx
	je	SHORT $LN4@CDrawConte

; 58   : 		CInternalFree(input->pData);

	call	CInternalFree
$LN4@CDrawConte:

; 59   : 
; 60   : 	// if size is 0, then skip
; 61   : 	if (size == 0) {

	test	rbx, rbx
	je	SHORT $LN34@CDrawConte

; 62   : 		_CSyncLeave(TRUE);
; 63   : 	}
; 64   : 
; 65   : 	// alloc new and copy
; 66   : 	input->pData = CInternalAlloc(size);

	mov	rcx, rbx
	call	CInternalAlloc
	mov	QWORD PTR [rsi+rdi*8+16], rax

; 67   : 	input->sizeBytes = size;
; 68   : 	COPY_BYTES(inBytes, input->pData, size);

	mov	rcx, rbx
	mov	QWORD PTR [rsi+rdi*8+8], rbx
	mov	rdi, rax
	mov	rsi, rbp
	rep movsb
$LN34@CDrawConte:

; 69   : 
; 70   : 	_CSyncLeave(TRUE);
; 71   : }

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN30@CDrawConte
	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN30@CDrawConte:
	mov	QWORD PTR [r14+rax*8+200], 0
	lea	rcx, OFFSET FLAT:_csmint+32
	dec	DWORD PTR _csmint+1224
	call	QWORD PTR __imp_LeaveCriticalSection
	mov	eax, 1
$LN1@CDrawConte:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
CDrawContextSetDrawInput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
;	COMDAT CDrawContextGetDrawInput
_TEXT	SEGMENT
drawContext$ = 48
inputID$ = 56
outBytes$ = 64
CDrawContextGetDrawInput PROC				; COMDAT

; 73   : CSMCALL BOOL	CDrawContextGetDrawInput(CHandle drawContext, UINT32 inputID, PVOID outBytes) {

$LN32:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 73   : CSMCALL BOOL	CDrawContextGetDrawInput(CHandle drawContext, UINT32 inputID, PVOID outBytes) {

	mov	rdi, r8
	mov	esi, edx
	mov	rbx, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN9@CDrawConte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN9@CDrawConte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0BJ@DEFJPCAF@CDrawContextGetDrawInput@
	lea	rbp, OFFSET FLAT:_csmint
	mov	QWORD PTR [rbp+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 74   : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 74   : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 75   : 	if (drawContext == NULL) {

	test	rbx, rbx
	jne	SHORT $LN2@CDrawConte

; 76   : 		_CSyncLeaveErr(FALSE, "CDrawContextGetDrawInput failed because drawContext was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0EA@GPIOOBCC@CDrawContextGetDrawInput?5failed@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN14@CDrawConte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN14@CDrawConte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rbp+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 76   : 		_CSyncLeaveErr(FALSE, "CDrawContextGetDrawInput failed because drawContext was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 76   : 		_CSyncLeaveErr(FALSE, "CDrawContextGetDrawInput failed because drawContext was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	jmp	$LN1@CDrawConte
$LN2@CDrawConte:

; 77   : 	}
; 78   : 	if (inputID >= CSM_MAX_DRAW_INPUTS) {

	cmp	esi, 32					; 00000020H
	jb	SHORT $LN3@CDrawConte

; 79   : 		_CSyncLeaveErr(FALSE, "CDrawContextGetDrawInput failed because inputID was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0DM@FIFDEFCI@CDrawContextGetDrawInput?5failed@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN19@CDrawConte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN19@CDrawConte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rbp+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 79   : 		_CSyncLeaveErr(FALSE, "CDrawContextGetDrawInput failed because inputID was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 79   : 		_CSyncLeaveErr(FALSE, "CDrawContextGetDrawInput failed because inputID was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	jmp	$LN1@CDrawConte
$LN3@CDrawConte:

; 80   : 	}
; 81   : 	if (outBytes == NULL) {

	test	rdi, rdi
	jne	SHORT $LN4@CDrawConte

; 82   : 		_CSyncLeaveErr(FALSE, "CDrawContextGetDrawInput failed because outBytes was NULL");

	lea	rcx, OFFSET FLAT:??_C@_0DK@LPJBMIHJ@CDrawContextGetDrawInput?5failed@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN24@CDrawConte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN24@CDrawConte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rbp+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 82   : 		_CSyncLeaveErr(FALSE, "CDrawContextGetDrawInput failed because outBytes was NULL");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 82   : 		_CSyncLeaveErr(FALSE, "CDrawContextGetDrawInput failed because outBytes was NULL");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	jmp	SHORT $LN1@CDrawConte
$LN4@CDrawConte:

; 83   : 	}
; 84   : 
; 85   : 	PCDrawContext context = drawContext;
; 86   : 	PCDrawInput input = context->inputs + inputID;

	mov	rax, rsi
	add	rax, rax

; 87   : 
; 88   : 	// copy bytes to outbuffer
; 89   : 	COPY_BYTES(input->pData, outBytes, input->sizeBytes);

	mov	rsi, QWORD PTR [rbx+rax*8+16]
	mov	rcx, QWORD PTR [rbx+rax*8+8]
	rep movsb
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN29@CDrawConte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN29@CDrawConte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rbp+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 91   : 	_CSyncLeave(TRUE);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 91   : 	_CSyncLeave(TRUE);

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	eax, 1
$LN1@CDrawConte:

; 92   : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CDrawContextGetDrawInput ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
;	COMDAT CDrawContextGetDrawInputSizeBytes
_TEXT	SEGMENT
drawContext$ = 48
inputID$ = 56
CDrawContextGetDrawInputSizeBytes PROC			; COMDAT

; 94   : CSMCALL SIZE_T	CDrawContextGetDrawInputSizeBytes(CHandle drawContext, UINT32 inputID) {

$LN26:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 94   : CSMCALL SIZE_T	CDrawContextGetDrawInputSizeBytes(CHandle drawContext, UINT32 inputID) {

	mov	rdi, rcx
	mov	ebx, edx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN8@CDrawConte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN8@CDrawConte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0CC@IAIDGGOF@CDrawContextGetDrawInputSizeByt@
	lea	rsi, OFFSET FLAT:_csmint
	mov	QWORD PTR [rsi+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 95   : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 95   : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 96   : 	if (drawContext == NULL) {

	test	rdi, rdi
	jne	SHORT $LN2@CDrawConte

; 97   : 		_CSyncLeaveErr(FALSE, "CDrawContextGetDrawInputSizeBytes failed because drawContext was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0EJ@PEJJEMJL@CDrawContextGetDrawInputSizeByt@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN13@CDrawConte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN13@CDrawConte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rsi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 97   : 		_CSyncLeaveErr(FALSE, "CDrawContextGetDrawInputSizeBytes failed because drawContext was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 97   : 		_CSyncLeaveErr(FALSE, "CDrawContextGetDrawInputSizeBytes failed because drawContext was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 107  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@CDrawConte:

; 98   : 	}
; 99   : 	if (inputID >= CSM_MAX_DRAW_INPUTS) {

	cmp	ebx, 32					; 00000020H
	jb	SHORT $LN3@CDrawConte

; 100  : 		_CSyncLeaveErr(FALSE, "CDrawContextGetDrawInputSizeBytes failed because inputID was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0EF@LNECBJCB@CDrawContextGetDrawInputSizeByt@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN18@CDrawConte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN18@CDrawConte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rsi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 100  : 		_CSyncLeaveErr(FALSE, "CDrawContextGetDrawInputSizeBytes failed because inputID was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 100  : 		_CSyncLeaveErr(FALSE, "CDrawContextGetDrawInputSizeBytes failed because inputID was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 107  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN3@CDrawConte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 104  : 	PCDrawInput input = context->inputs + inputID;

	add	rbx, rbx
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN23@CDrawConte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN23@CDrawConte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	ecx, eax
	mov	QWORD PTR [rsi+rcx*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 106  : 	_CSyncLeave(input->sizeBytes);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 106  : 	_CSyncLeave(input->sizeBytes);

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rax, QWORD PTR [rdi+rbx*8+8]

; 107  : }

	mov	rbx, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CDrawContextGetDrawInputSizeBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
;	COMDAT CDrawContextGetLastDrawTimeMS
_TEXT	SEGMENT
drawContext$ = 48
CDrawContextGetLastDrawTimeMS PROC			; COMDAT

; 109  : CSMCALL UINT64	CDrawContextGetLastDrawTimeMS(CHandle drawContext) {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 109  : CSMCALL UINT64	CDrawContextGetLastDrawTimeMS(CHandle drawContext) {

	mov	rbx, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN7@CDrawConte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN7@CDrawConte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0BO@CBAHBNCM@CDrawContextGetLastDrawTimeMS@
	lea	rdi, OFFSET FLAT:_csmint
	mov	QWORD PTR [rdi+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 110  : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 110  : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 111  : 	if (drawContext == NULL) {

	test	rbx, rbx
	jne	SHORT $LN2@CDrawConte

; 112  : 		_CSyncLeaveErr(FALSE, "CDrawContextGetLastDrawTimeMS failed because drawContext was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0EF@ENLNFODN@CDrawContextGetLastDrawTimeMS?5f@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN12@CDrawConte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN12@CDrawConte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rdi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 112  : 		_CSyncLeaveErr(FALSE, "CDrawContextGetLastDrawTimeMS failed because drawContext was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 112  : 		_CSyncLeaveErr(FALSE, "CDrawContextGetLastDrawTimeMS failed because drawContext was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 117  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@CDrawConte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN17@CDrawConte
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN17@CDrawConte:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rdi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 116  : 	_CSyncLeave(context->lastDrawTimeMS);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 116  : 	_CSyncLeave(context->lastDrawTimeMS);

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	rax, QWORD PTR [rbx+520]

; 117  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CDrawContextGetLastDrawTimeMS ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_draw.c
;	COMDAT CDraw
_TEXT	SEGMENT
drawContext$ = 8
rClass$ = 16
CDraw	PROC						; COMDAT

; 120  : 	return CDrawInstanced(drawContext, rClass, 1);

	mov	r8d, 1
	jmp	CDrawInstanced
CDraw	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint_pl_processtri.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm_draw.c
;	COMDAT CDrawInstanced
_TEXT	SEGMENT
instanceID$1$ = 48
instanceCount$1$ = 52
drawContext$GSCopy$1$ = 56
drawMesh$1$ = 64
$T1 = 80
$T2 = 96
counterEndTick$ = 112
counterStartTick$ = 120
__$ArrayPad$ = 128
drawContext$ = 192
rClass$ = 200
instanceCount$ = 208
CDrawInstanced PROC					; COMDAT

; 123  : CSMCALL BOOL CDrawInstanced(CHandle drawContext, CHandle rClass, UINT32 instanceCount) {

$LN831:
	push	rbx
	push	rbp
	push	rsi
	push	r14
	sub	rsp, 152				; 00000098H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 123  : CSMCALL BOOL CDrawInstanced(CHandle drawContext, CHandle rClass, UINT32 instanceCount) {

	mov	ebx, r8d
	mov	DWORD PTR instanceCount$1$[rsp], ebx
	mov	rsi, rdx
	mov	QWORD PTR drawContext$GSCopy$1$[rsp], rcx
	mov	r14, rcx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN27@CDrawInsta
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN27@CDrawInsta:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0P@FKLLMFGP@CDrawInstanced@
	lea	rbp, OFFSET FLAT:_csmint
	mov	QWORD PTR [rbp+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 124  : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 124  : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 125  : 
; 126  : 	// get start tick
; 127  : 	LARGE_INTEGER counterStartTick;
; 128  : 	QueryPerformanceCounter(&counterStartTick);

	lea	rcx, QWORD PTR counterStartTick$[rsp]
	call	QWORD PTR __imp_QueryPerformanceCounter

; 129  : 
; 130  : 	// check for bad params
; 131  : 	if (drawContext == NULL) {

	test	r14, r14
	jne	SHORT $LN10@CDrawInsta

; 132  : 		_CSyncLeaveErr(FALSE, "CDrawInstanced failed because drawContext was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0DG@CIBDKAFG@CDrawInstanced?5failed?5because?5d@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN32@CDrawInsta
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN32@CDrawInsta:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rbp+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 132  : 		_CSyncLeaveErr(FALSE, "CDrawInstanced failed because drawContext was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 132  : 		_CSyncLeaveErr(FALSE, "CDrawInstanced failed because drawContext was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	jmp	$LN1@CDrawInsta
$LN10@CDrawInsta:

; 133  : 	}
; 134  : 	if (rClass == NULL) {

	test	rsi, rsi
	jne	SHORT $LN11@CDrawInsta

; 135  : 		_CSyncLeaveErr(FALSE, "CDrawInstanced failed because rClass was invalid");

	lea	rcx, OFFSET FLAT:??_C@_0DB@INGALEIM@CDrawInstanced?5failed?5because?5r@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN37@CDrawInsta
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN37@CDrawInsta:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rbp+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 135  : 		_CSyncLeaveErr(FALSE, "CDrawInstanced failed because rClass was invalid");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 135  : 		_CSyncLeaveErr(FALSE, "CDrawInstanced failed because rClass was invalid");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	jmp	$LN1@CDrawInsta
$LN11@CDrawInsta:

; 136  : 	}
; 137  : 	if (instanceCount == 0) {

	test	ebx, ebx
	jne	SHORT $LN12@CDrawInsta

; 138  : 		_CSyncLeaveErr(FALSE, "CDrawInstanced failed because instanceCount was 0");

	lea	rcx, OFFSET FLAT:??_C@_0DC@FAHJIAKO@CDrawInstanced?5failed?5because?5i@
	call	CInternalSetLastError
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN42@CDrawInsta
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN42@CDrawInsta:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rbp+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 138  : 		_CSyncLeaveErr(FALSE, "CDrawInstanced failed because instanceCount was 0");

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 138  : 		_CSyncLeaveErr(FALSE, "CDrawInstanced failed because instanceCount was 0");

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax
	jmp	$LN1@CDrawInsta
$LN12@CDrawInsta:
	mov	QWORD PTR [rsp+200], rdi

; 139  : 	}
; 140  : 
; 141  : 	// copy of class
; 142  : 	PCRenderClass pClass = rClass;

	xor	edi, edi
	mov	QWORD PTR [rsp+208], r12

; 143  : 
; 144  : 	// get context and render buffer
; 145  : 	PCDrawContext context = drawContext;
; 146  : 	PCRenderBuffer renderBuffer = context->renderBuffer;

	mov	r12, QWORD PTR [r14]
	mov	DWORD PTR instanceID$1$[rsp], edi

; 147  : 
; 148  : 	// loop all instances
; 149  : 	for (UINT32 instanceID = 0; instanceID < instanceCount; instanceID++) {

	test	ebx, ebx
	je	$LN3@CDrawInsta
	mov	QWORD PTR [rsp+216], r13
	mov	QWORD PTR [rsp+144], r15
	npad	6
$LL4@CDrawInsta:

; 150  : 		// get mesh
; 151  : 		PCMesh drawMesh = CRenderClassGetMesh(rClass);

	mov	rcx, rsi
	call	CRenderClassGetMesh

; 152  : 
; 153  : 		// loop each triangle of mesh and rasterize triangle
; 154  : 		// this is done by walking indexes in groups of 3
; 155  : 		UINT32 triangleID = 0;

	xor	r15d, r15d
	mov	QWORD PTR drawMesh$1$[rsp], rax

; 156  : 		for (UINT32 meshIndex = 0; meshIndex < drawMesh->indexCount; meshIndex += 3) {

	xor	r13d, r13d
	mov	rbx, rax
	cmp	DWORD PTR [rax+16], r13d
	jbe	$LN2@CDrawInsta
$LL7@CDrawInsta:

; 157  : 			// alloc triangle to heap
; 158  : 			PCIPTriData triData = CInternalAlloc(sizeof(CIPTriData));

	mov	ecx, 1776				; 000006f0H
	call	CInternalAlloc

; 159  : 
; 160  : 			// get triangle from mesh
; 161  : 			triData->verts[0] = 

	mov	rcx, QWORD PTR [rbx+24]
	mov	r14, rax
	lea	rbp, QWORD PTR [rax+1728]
	movsxd	rdx, DWORD PTR [rcx+r13*4]
	mov	rcx, QWORD PTR [rbx+8]
	lea	r8, QWORD PTR [rdx+rdx*2]
	vmovsd	xmm0, QWORD PTR [rcx+r8*4]
	vmovsd	QWORD PTR [rbp], xmm0
	mov	ecx, DWORD PTR [rcx+r8*4+8]

; 162  : 				drawMesh->vertArray[drawMesh->indexArray[meshIndex + 0]];
; 163  : 			triData->verts[1] =

	lea	r8d, DWORD PTR [r13+2]
	mov	DWORD PTR [rbp+8], ecx
	lea	ecx, DWORD PTR [r8-1]
	mov	rax, QWORD PTR [rbx+24]
	movsxd	rcx, DWORD PTR [rax+rcx*4]
	mov	rax, QWORD PTR [rbx+8]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	vmovsd	xmm0, QWORD PTR [rax+rdx*4]
	vmovsd	QWORD PTR [r14+1740], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r14+1748], eax

; 164  : 				drawMesh->vertArray[drawMesh->indexArray[meshIndex + 1]];
; 165  : 			triData->verts[2] =

	mov	rax, QWORD PTR [rbx+24]
	movsxd	rcx, DWORD PTR [rax+r8*4]
	mov	rax, QWORD PTR [rbx+8]
	lea	rdx, QWORD PTR [rcx+rcx*2]

; 166  : 				drawMesh->vertArray[drawMesh->indexArray[meshIndex + 2]];
; 167  : 
; 168  : 			// generate tri context for rasterization
; 169  : 			// note: tContext->fragContext is untouched because it is determined per-fragment
; 170  : 			// note: with the exception of tContext->fragContext.parent which points to tContext
; 171  : 			PCIPTriContext tContext = CInternalAlloc(sizeof(CIPTriContext));

	mov	ecx, 664				; 00000298H
	vmovsd	xmm0, QWORD PTR [rax+rdx*4]
	vmovsd	QWORD PTR [r14+1752], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r14+1760], eax
	call	CInternalAlloc
	mov	rbx, rax

; 172  : 			tContext->drawContext			= drawContext;

	mov	rax, QWORD PTR drawContext$GSCopy$1$[rsp]
	mov	QWORD PTR [rbx], rax

; 173  : 			tContext->instanceID			= instanceID;

	mov	DWORD PTR [rbx+16], edi

; 174  : 			tContext->triangleID			= triangleID;

	mov	DWORD PTR [rbx+20], r15d

; 175  : 			tContext->rClass				= rClass;

	mov	QWORD PTR [rbx+24], rsi

; 176  : 			tContext->renderBuffer			= renderBuffer;

	mov	QWORD PTR [rbx+648], r12

; 177  : 			tContext->fragContext.parent	= tContext;

	mov	QWORD PTR [rbx+40], rbx

; 178  : 			tContext->screenTriAndData = triData; // temporary, will be replaced when clipped

	mov	QWORD PTR [rbx+32], r14

; 179  : 
; 180  : 			// setup material
; 181  : 			if (pClass->singleMaterial == TRUE) {

	cmp	DWORD PTR [rsi+464], 1
	jne	SHORT $LN13@CDrawInsta

; 182  : 				tContext->material = pClass->materials[0];

	mov	rax, QWORD PTR [rsi+400]
	mov	QWORD PTR [rbx+656], rax

; 183  : 			}

	jmp	SHORT $LN44@CDrawInsta
$LN13@CDrawInsta:

; 184  : 			else {
; 185  : 				tContext->material = pClass->materials[pClass->triMaterials[triangleID]];

	mov	rax, QWORD PTR [rsi+472]
	mov	ecx, DWORD PTR [rax+r15*4]
	mov	rax, QWORD PTR [rsi+rcx*8+400]
	mov	QWORD PTR [rbx+656], rax

; 186  : 					
; 187  : 				// set to default material
; 188  : 				if (tContext->material == NULL) {

	test	rax, rax
	jne	SHORT $LN44@CDrawInsta

; 189  : 					tContext->material = pClass->materials[0];

	mov	rax, QWORD PTR [rsi+400]
	mov	QWORD PTR [rbx+656], rax

; 190  : 				}
; 191  : 
; 192  : 				// check for bad state
; 193  : 				if (tContext->material == NULL) {

	test	rax, rax
	jne	SHORT $LN44@CDrawInsta
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0DB@OMLAGJKB@Bad?5material?5state?4?5No?5material@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
$LN44@CDrawInsta:
; File C:\Bailey\Programming\Caesium\csmint_pl_processtri.c

; 9    : 	for (UINT32 triVertexIndex = 0; triVertexIndex < 3; triVertexIndex++) {

	xor	edi, edi
	npad	10
$LL49@CDrawInsta:

; 10   : 		
; 11   : 		// calculate vertex ID and trivertex ID
; 12   : 		PCMesh mesh = triContext->rClass->mesh;
; 13   : 		triContext->vertexID = mesh->indexArray[(triContext->triangleID * 3) + triVertexIndex];

	mov	rax, QWORD PTR [rbx+24]
	mov	r9d, DWORD PTR [rbx+20]

; 14   : 		triContext->triVertexID = triVertexIndex;
; 15   : 
; 16   : 		// calculate new vertex position and vertex outputs
; 17   : 		CVect3F vertOut = triContext->material->vertexShader(

	mov	r10, QWORD PTR [rbx+656]
	mov	rcx, QWORD PTR [rax+8]
	lea	edx, DWORD PTR [rdi+r9*2]
	add	edx, r9d
	mov	rax, QWORD PTR [rcx+24]
	lea	rcx, QWORD PTR $T2[rsp]
	mov	r8d, DWORD PTR [rax+rdx*4]
	mov	rdx, rbx
	mov	DWORD PTR [rbx+12], r8d
	mov	DWORD PTR [rbx+8], edi
	mov	eax, DWORD PTR [rbp+8]
	vmovsd	xmm0, QWORD PTR [rbp]
	mov	DWORD PTR $T1[rsp+8], eax
	lea	rax, QWORD PTR $T1[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	eax, DWORD PTR [rbx+16]
	mov	DWORD PTR [rsp+32], eax
	vmovsd	QWORD PTR $T1[rsp], xmm0
	call	QWORD PTR [r10+8]
	inc	edi
	lea	rbp, QWORD PTR [rbp+12]
	mov	ecx, DWORD PTR [rax+8]

; 18   : 			triContext,
; 19   : 			triContext->vertexID,
; 20   : 			triContext->triangleID,
; 21   : 			triContext->instanceID,
; 22   : 			inTri->verts[triVertexIndex]
; 23   : 		);
; 24   : 
; 25   : 		// update triangle verticies
; 26   : 		inTri->verts[triVertexIndex] = vertOut;

	vmovsd	xmm0, QWORD PTR [rax]
	vmovsd	QWORD PTR [rbp-12], xmm0
	mov	DWORD PTR [rbp-4], ecx
	cmp	edi, 3
	jb	SHORT $LL49@CDrawInsta
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 203  : 			PCIPTriData clippedTris = CInternalAlloc(sizeof(CIPTriData) * 2);

	mov	ecx, 3552				; 00000de0H
	call	CInternalAlloc

; 204  : 			UINT32 triCount = CInternalPipelineClipTri(triData, clippedTris);

	mov	rdx, rax
	mov	rcx, r14
	mov	rdi, rax
	call	CInternalPipelineClipTri

; 205  : 
; 206  : 			// setup materials
; 207  : 			PCRenderClass tempRClass = rClass;
; 208  : 			tContext->material = tempRClass->materials[tempRClass->triMaterials[triangleID]];

	mov	rcx, QWORD PTR [rsi+472]
	mov	edx, DWORD PTR [rcx+r15*4]
	mov	rcx, QWORD PTR [rsi+rdx*8+400]
	mov	QWORD PTR [rbx+656], rcx

; 209  : 
; 210  : 			// if material is NULL, use default material (0)
; 211  : 			if (tContext->material == NULL)

	test	rcx, rcx
	jne	SHORT $LN17@CDrawInsta

; 212  : 				tContext->material = tempRClass->materials[0];

	mov	rcx, QWORD PTR [rsi+400]
	mov	QWORD PTR [rbx+656], rcx
$LN17@CDrawInsta:

; 213  : 
; 214  : 			// change based on clip output
; 215  : 			switch (triCount)

	test	eax, eax
	je	SHORT $LN19@CDrawInsta
	cmp	eax, 1
	je	SHORT $LN20@CDrawInsta
	cmp	eax, 2
	je	SHORT $LN21@CDrawInsta
	cmp	eax, -1					; ffffffffH
	je	SHORT $LN807@CDrawInsta
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BD@EAKJIILB@Bad?5clipping?5state@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	jmp	SHORT $LN807@CDrawInsta
$LN21@CDrawInsta:
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 240  : 				CInternalPipelineProjectTri(renderBuffer, clippedTris + 0);

	mov	rdx, rdi
	mov	rcx, r12
	call	CInternalPipelineProjectTri

; 241  : 
; 242  : 				// rasterize clipped triangle 1
; 243  : 				CInternalPipelineRasterizeTri(tContext, clippedTris + 0);

	mov	rcx, rbx
	call	CInternalPipelineRasterizeTri

; 244  : 
; 245  : 				// project triangle 2
; 246  : 				CInternalPipelineProjectTri(renderBuffer, clippedTris + 1);

	lea	rdx, QWORD PTR [rdi+1776]

; 247  : 
; 248  : 				// rasterize triangle 2
; 249  : 				CInternalPipelineRasterizeTri(tContext, clippedTris + 1);
; 250  : 
; 251  : 				break;

	jmp	SHORT $LN829@CDrawInsta
$LN20@CDrawInsta:

; 223  : 
; 224  : 				// rasterize triangle
; 225  : 				CInternalPipelineRasterizeTri(tContext, triData);
; 226  : 
; 227  : 				break;
; 228  : 
; 229  : 			case 1: // clipped original tri into 1 tri
; 230  : 				// project triangle
; 231  : 				CInternalPipelineProjectTri(renderBuffer, clippedTris + 0);

	mov	rdx, rdi

; 232  : 
; 233  : 				// rasterize clipped triangle
; 234  : 				CInternalPipelineRasterizeTri(tContext, clippedTris + 0);
; 235  : 
; 236  : 				break;

	jmp	SHORT $LN829@CDrawInsta
$LN19@CDrawInsta:

; 216  : 			{
; 217  : 			case -1: // CULL
; 218  : 				break;
; 219  : 
; 220  : 			case 0: // default case. no extra tris used
; 221  : 				// project triangle
; 222  : 				CInternalPipelineProjectTri(renderBuffer, triData);

	mov	rdx, r14
$LN829@CDrawInsta:

; 252  : 
; 253  : 			default:
; 254  : 				CInternalErrorPopup("Bad clipping state");
; 255  : 				break;
; 256  : 			}
; 257  : 
; 258  : 			// free extra triangles
; 259  : 			CInternalFree(clippedTris);

	mov	rcx, r12
	call	CInternalPipelineProjectTri
	mov	rcx, rbx
	call	CInternalPipelineRasterizeTri
$LN807@CDrawInsta:
	mov	rcx, rdi
	call	CInternalFree

; 260  : 
; 261  : 			// free triangle data
; 262  : 			CInternalFree(triData);

	mov	rcx, r14
	call	CInternalFree

; 263  : 
; 264  : 			// free triangle context
; 265  : 			CInternalFree(tContext);

	mov	rcx, rbx
	call	CInternalFree
	mov	rbx, QWORD PTR drawMesh$1$[rsp]

; 266  : 
; 267  : 			// increment triangleID
; 268  : 			triangleID++;

	inc	r15d
	mov	edi, DWORD PTR instanceID$1$[rsp]
	add	r13d, 3
	cmp	r13d, DWORD PTR [rbx+16]
	jb	$LL7@CDrawInsta
$LN2@CDrawInsta:

; 147  : 
; 148  : 	// loop all instances
; 149  : 	for (UINT32 instanceID = 0; instanceID < instanceCount; instanceID++) {

	inc	edi
	mov	DWORD PTR instanceID$1$[rsp], edi
	cmp	edi, DWORD PTR instanceCount$1$[rsp]
	jb	$LL4@CDrawInsta
	mov	r14, QWORD PTR drawContext$GSCopy$1$[rsp]
	lea	rbp, OFFSET FLAT:_csmint
	mov	r15, QWORD PTR [rsp+144]
	mov	r13, QWORD PTR [rsp+216]
$LN3@CDrawInsta:

; 269  : 		}
; 270  : 	}
; 271  : 
; 272  : 	// get end tick
; 273  : 	LARGE_INTEGER counterEndTick;
; 274  : 	QueryPerformanceCounter(&counterEndTick);

	lea	rcx, QWORD PTR counterEndTick$[rsp]
	call	QWORD PTR __imp_QueryPerformanceCounter

; 275  : 
; 276  : 	// calculate elapsed time
; 277  : 	LONGLONG counterTicksElapsed = counterEndTick.QuadPart - counterStartTick.QuadPart;

	mov	rax, QWORD PTR counterEndTick$[rsp]
	sub	rax, QWORD PTR counterStartTick$[rsp]
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	r12, QWORD PTR [rsp+208]
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 280  : 	LONGLONG elapsedMS = (counterTicksElapsed / _csmint.perfCounterHzMs.QuadPart);

	cdq
	idiv	QWORD PTR _csmint+1232
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	rdi, QWORD PTR [rsp+200]
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 281  : 	context->lastDrawTimeMS = (UINT64)elapsedMS;

	mov	QWORD PTR [r14+520], rax
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN812@CDrawInsta
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN812@CDrawInsta:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rbp+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 283  : 	_CSyncLeave(TRUE);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm_draw.c

; 283  : 	_CSyncLeave(TRUE);

	call	QWORD PTR __imp_LeaveCriticalSection
	mov	eax, 1
$LN1@CDrawInsta:

; 284  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 152				; 00000098H
	pop	r14
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
CDrawInstanced ENDP
_TEXT	ENDS
END
