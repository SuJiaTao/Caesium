; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30148.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@LINMDAFK@CTerminate@			; `string'
PUBLIC	??_C@_0L@OFEJAFOB@CLogErrors@			; `string'
PUBLIC	??_C@_05PFCPLDJG@CLock@				; `string'
EXTRN	__imp_DeleteCriticalSection:PROC
EXTRN	__imp_HeapDestroy:PROC
EXTRN	__imp_QueryPerformanceFrequency:PROC
EXTRN	__imp_InitializeCriticalSection:PROC
EXTRN	__imp_LeaveCriticalSection:PROC
EXTRN	__imp_EnterCriticalSection:PROC
EXTRN	__imp_HeapCreate:PROC
EXTRN	__security_check_cookie:PROC
COMM	_csmint:BYTE:04d8H
_DATA	ENDS
;	COMDAT ??_C@_05PFCPLDJG@CLock@
CONST	SEGMENT
??_C@_05PFCPLDJG@CLock@ DB 'CLock', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OFEJAFOB@CLogErrors@
CONST	SEGMENT
??_C@_0L@OFEJAFOB@CLogErrors@ DB 'CLogErrors', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LINMDAFK@CTerminate@
CONST	SEGMENT
??_C@_0L@LINMDAFK@CTerminate@ DB 'CTerminate', 00H	; `string'
CONST	ENDS
PUBLIC	CUnlock
PUBLIC	CLock
PUBLIC	CLogErrors
PUBLIC	CFreeError
PUBLIC	CGetLastError
PUBLIC	CMakeColor4
PUBLIC	CMakeColor3
PUBLIC	CFree
PUBLIC	CAlloc
PUBLIC	CTerminate
PUBLIC	CInitialize
PUBLIC	__real@3b808081
PUBLIC	__real@3c8efa39
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@437f0000
PUBLIC	__real@ba83126f
PUBLIC	__real@bf800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__GSHandlerCheck:PROC
EXTRN	_fdclass:PROC
EXTRN	memset:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$CUnlock DD imagerel $LN9
	DD	imagerel $LN9+87
	DD	imagerel $unwind$CUnlock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CLock DD	imagerel $LN9
	DD	imagerel $LN9+90
	DD	imagerel $unwind$CLock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CLogErrors DD imagerel $LN14
	DD	imagerel $LN14+189
	DD	imagerel $unwind$CLogErrors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CGetLastError DD imagerel $LN17
	DD	imagerel $LN17+226
	DD	imagerel $unwind$CGetLastError
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CTerminate DD imagerel $LN15
	DD	imagerel $LN15+230
	DD	imagerel $unwind$CTerminate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CInitialize DD imagerel $LN5
	DD	imagerel $LN5+15
	DD	imagerel $unwind$CInitialize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$CInitialize DD imagerel $LN5+15
	DD	imagerel $LN5+141
	DD	imagerel $chain$0$CInitialize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$CInitialize DD imagerel $LN5+141
	DD	imagerel $LN5+146
	DD	imagerel $chain$1$CInitialize
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@ba83126f
CONST	SEGMENT
__real@ba83126f DD 0ba83126fr			; -0.001
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3c8efa39
CONST	SEGMENT
__real@3c8efa39 DD 03c8efa39r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$CInitialize DD 021H
	DD	imagerel $LN5
	DD	imagerel $LN5+15
	DD	imagerel $unwind$CInitialize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$CInitialize DD 020521H
	DD	047405H
	DD	imagerel $LN5
	DD	imagerel $LN5+15
	DD	imagerel $unwind$CInitialize
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CInitialize DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CTerminate DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CGetLastError DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CLogErrors DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CLock DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CUnlock DD 010401H
	DD	04204H
xdata	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm.c
;	COMDAT CInitialize
_TEXT	SEGMENT
CInitialize PROC					; COMDAT

; 7    : CSMCALL BOOL CInitialize() {

$LN5:
	sub	rsp, 40					; 00000028H

; 8    : 	// check for already initailized
; 9    : 	if (_csmint.init == TRUE) return FALSE;

	xor	eax, eax
	cmp	DWORD PTR _csmint, 1
	je	SHORT $LN1@CInitializ

; 10   : 
; 11   : 	ZERO_BYTES(&_csmint, sizeof(_csmint));

	mov	QWORD PTR [rsp+32], rdi
	mov	ecx, 1240				; 000004d8H
	lea	rdi, OFFSET FLAT:_csmint

; 12   : 
; 13   : 	// create unsafe heap
; 14   : 	_csmint.heap = HeapCreate(HEAP_CREATE_ENABLE_EXECUTE, ZERO, ZERO);

	xor	r8d, r8d
	rep stosb
	mov	ecx, 262144				; 00040000H
	xor	edx, edx
	call	QWORD PTR __imp_HeapCreate

; 15   : 
; 16   : 	InitializeCriticalSection(&_csmint.lock);

	lea	rcx, OFFSET FLAT:_csmint+32
	mov	QWORD PTR _csmint+8, rax
	call	QWORD PTR __imp_InitializeCriticalSection

; 17   : 
; 18   : 	// setup perf freq
; 19   : 	QueryPerformanceFrequency(&_csmint.perfCounterHzMs);

	lea	rcx, OFFSET FLAT:_csmint+1232
	call	QWORD PTR __imp_QueryPerformanceFrequency

; 20   : 	_csmint.perfCounterHzMs.QuadPart /= 1000; // adjust for miliseconds
; 21   : 
; 22   : 	_csmint.init = TRUE;
; 23   : 	return TRUE;

	mov	rdi, QWORD PTR [rsp+32]
	mov	rax, 2361183241434822607		; 20c49ba5e353f7cfH
	imul	QWORD PTR _csmint+1232
	mov	DWORD PTR _csmint, 1
	sar	rdx, 7
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
	mov	eax, 1
	mov	QWORD PTR _csmint+1232, rdx
$LN1@CInitializ:

; 24   : }

	add	rsp, 40					; 00000028H
	ret	0
CInitialize ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm.c
;	COMDAT CTerminate
_TEXT	SEGMENT
CTerminate PROC						; COMDAT

; 26   : CSMCALL BOOL CTerminate() {

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN7@CTerminate
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN7@CTerminate:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0L@LINMDAFK@CTerminate@
	lea	rbx, OFFSET FLAT:_csmint
	mov	QWORD PTR [rbx+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm.c

; 27   : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm.c

; 27   : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 28   : 
; 29   : 	if (_csmint.allocateCount > 0) {

	cmp	DWORD PTR _csmint+28, 0
	jbe	SHORT $LN2@CTerminate
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN12@CTerminate
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN12@CTerminate:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rbx+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm.c

; 30   : 		_CSyncLeave(FALSE);

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm.c

; 30   : 		_CSyncLeave(FALSE);

	call	QWORD PTR __imp_LeaveCriticalSection
	xor	eax, eax

; 39   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@CTerminate:

; 31   : 	}
; 32   : 	
; 33   : 	HeapDestroy(&_csmint.heap);

	lea	rcx, OFFSET FLAT:_csmint+8
	call	QWORD PTR __imp_HeapDestroy

; 34   : 	DeleteCriticalSection(&_csmint.lock);

	lea	rcx, OFFSET FLAT:_csmint+32
	call	QWORD PTR __imp_DeleteCriticalSection

; 35   : 
; 36   : 	_csmint.init = FALSE;
; 37   : 
; 38   : 	return TRUE;

	mov	eax, 1
	mov	DWORD PTR _csmint, 0

; 39   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
CTerminate ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csm.c
;	COMDAT CGetLastError
_TEXT	SEGMENT
CGetLastError PROC					; COMDAT

; 67   : CSMCALL PCHAR CGetLastError(void) {

$LN17:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 69   : 	PCHAR buffer = CInternalAlloc(errBufferSize);

	mov	ecx, 255				; 000000ffH
	call	CInternalAlloc
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	ecx, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm.c

; 69   : 	PCHAR buffer = CInternalAlloc(errBufferSize);

	mov	rbx, rax
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	ecx, 128				; 00000080H
	jb	SHORT $LN9@CGetLastEr
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	ecx, DWORD PTR _csmint+1224
$LN9@CGetLastEr:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	mov	eax, ecx
	lea	rdi, OFFSET FLAT:_csmint
	lea	rcx, OFFSET FLAT:??_C@_0BG@DCEFHGBJ@CInternalGetLastError@
	mov	QWORD PTR [rdi+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 40   : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 40   : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection

; 41   : 	if (_csmint.lastError != NULL)

	mov	r8, QWORD PTR _csmint+16
	test	r8, r8
	je	SHORT $LN4@CGetLastEr

; 42   : 		strcpy_s(errBuffer, maxSize, _csmint.lastError);

	mov	edx, 255				; 000000ffH
	mov	rcx, rbx
	call	QWORD PTR __imp_strcpy_s
$LN4@CGetLastEr:
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN14@CGetLastEr
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN14@CGetLastEr:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rdi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 43   : 	_CSyncLeave();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 43   : 	_CSyncLeave();

	call	QWORD PTR __imp_LeaveCriticalSection
; File C:\Bailey\Programming\Caesium\csm.c

; 71   : 	return buffer;

	mov	rax, rbx

; 72   : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
CGetLastError ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm.c
;	COMDAT CLogErrors
_TEXT	SEGMENT
state$ = 48
CLogErrors PROC						; COMDAT

; 78   : CSMCALL void  CLogErrors(BOOL state) {

$LN14:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm.c

; 78   : CSMCALL void  CLogErrors(BOOL state) {

	mov	ebx, ecx
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN6@CLogErrors
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN6@CLogErrors:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rcx, OFFSET FLAT:??_C@_0L@OFEJAFOB@CLogErrors@
	lea	rdi, OFFSET FLAT:_csmint
	mov	QWORD PTR [rdi+rax*8+200], rcx
; File C:\Bailey\Programming\Caesium\csm.c

; 79   : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm.c

; 79   : 	_CSyncEnter();

	call	QWORD PTR __imp_EnterCriticalSection
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm.c

; 80   : 	_csmint.logErrors = state;

	mov	DWORD PTR _csmint+24, ebx
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	cmp	eax, 128				; 00000080H
	jb	SHORT $LN11@CLogErrors
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN11@CLogErrors:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	mov	QWORD PTR [rdi+rax*8+200], 0
; File C:\Bailey\Programming\Caesium\csm.c

; 81   : 	_CSyncLeave();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm.c

; 82   : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 81   : 	_CSyncLeave();

	rex_jmp	QWORD PTR __imp_LeaveCriticalSection
CLogErrors ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm.c
;	COMDAT CLock
_TEXT	SEGMENT
CLock	PROC						; COMDAT

; 84   : CSMCALL void CLock() {

$LN9:
	sub	rsp, 40					; 00000028H
; File C:\Bailey\Programming\Caesium\csmint.c

; 9    : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN6@CLock
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN6@CLock:
; File C:\Bailey\Programming\Caesium\csmint.c

; 12   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = funcname;

	lea	rdx, OFFSET FLAT:_csmint+200
	lea	rcx, OFFSET FLAT:??_C@_05PFCPLDJG@CLock@
	mov	QWORD PTR [rdx+rax*8], rcx
; File C:\Bailey\Programming\Caesium\csm.c

; 85   : 	_CSyncEnter();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 13   : 	_csmint.funcNameStackPtr++;

	inc	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm.c

; 86   : }

	add	rsp, 40					; 00000028H

; 85   : 	_CSyncEnter();

	rex_jmp	QWORD PTR __imp_EnterCriticalSection
CLock	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csmint_error.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm.c
; File C:\Bailey\Programming\Caesium\csmint.c
; File C:\Bailey\Programming\Caesium\csm.c
;	COMDAT CUnlock
_TEXT	SEGMENT
CUnlock	PROC						; COMDAT

; 88   : CSMCALL void CUnlock() {

$LN9:
	sub	rsp, 40					; 00000028H
; File C:\Bailey\Programming\Caesium\csmint.c

; 18   : 	if (_csmint.funcNameStackPtr >= CSMINT_FUNCNAMESTACK_SIZE)

	mov	eax, DWORD PTR _csmint+1224
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN6@CUnlock
; File C:\Bailey\Programming\Caesium\csmint_error.c

; 9    : 	MessageBoxA(NULL, message, "Caesium Fatal Error", MB_OK);

	xor	r9d, r9d
	lea	r8, OFFSET FLAT:??_C@_0BE@EKMGEMPI@Caesium?5Fatal?5Error@
	lea	rdx, OFFSET FLAT:??_C@_0BL@ELEHMINF@Faulty?5FuncNameStack?5State@
	xor	ecx, ecx
	call	QWORD PTR __imp_MessageBoxA
	mov	eax, DWORD PTR _csmint+1224
$LN6@CUnlock:
; File C:\Bailey\Programming\Caesium\csmint.c

; 21   : 	_csmint.funcNameStack[_csmint.funcNameStackPtr] = NULL;

	lea	rcx, OFFSET FLAT:_csmint+200
	mov	QWORD PTR [rcx+rax*8], 0
; File C:\Bailey\Programming\Caesium\csm.c

; 89   : 	_CSyncLeave();

	lea	rcx, OFFSET FLAT:_csmint+32
; File C:\Bailey\Programming\Caesium\csmint.c

; 23   : 	_csmint.funcNameStackPtr--;

	dec	DWORD PTR _csmint+1224
; File C:\Bailey\Programming\Caesium\csm.c

; 90   : }

	add	rsp, 40					; 00000028H

; 89   : 	_CSyncLeave();

	rex_jmp	QWORD PTR __imp_LeaveCriticalSection
CUnlock	ENDP
_TEXT	ENDS
END
